--- goo-0.155.orig/configure
+++ goo-0.155/configure
@@ -2037,9 +2037,9 @@
 cat > conftest.$ac_ext <<EOF
 #line 2039 "configure"
 #include "confdefs.h"
-
-int main() {
 __thread int testvar;
+int main() {
+
 ; return 0; }
 EOF
 if { (eval echo configure:2046: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
--- goo-0.155.orig/configure.in
+++ goo-0.155/configure.in
@@ -39,8 +39,8 @@
 fi
 AC_DEFINE(_REENTRANT)
 AC_MSG_CHECKING([whether the compiler supports thread-local variables])
-AC_TRY_COMPILE([],
-[__thread int testvar;], [
+AC_TRY_COMPILE([__thread int testvar;],
+[], [
 AC_DEFINE(HAVE_THREAD_LOCAL_VARIABLE)
 AC_MSG_RESULT([yes])], AC_MSG_RESULT([no]))
 AC_CHECK_LIB(pthread, pthread_create, [
--- goo-0.155.orig/c/grt.c
+++ goo-0.155/c/grt.c
@@ -49,6 +49,7 @@
   printf("ERROR: ");
   println(condition);
   YPbreak("");
+  return PNUL;
 }
 
 /* STACK */
@@ -143,7 +144,7 @@
   PINT i, size;
   P   c, y;
   c    = YPobject_class(x);
-  size = YPiu(YPclass_prop_len(c));
+  size = (PINT)YPiu(YPclass_prop_len(c));
   y    = YPobject_of(c, (P)size);
   for (i = 0; i < (PINT)size; i++)
     YPprop_elt_setter(YPprop_elt(x, (P)i), y, (P)i);
@@ -244,7 +245,7 @@
 
 unsigned long env_nallocd = 0;
 
-INLINE P ENVFAB (int n) {
+INLINE P ENVFAB (PINT n) {
   unsigned long snallocd = nallocd;
   ENV env = allocate(sizeof(ENV_DATA) + ((n - 1) * sizeof(P)));
   env_nallocd += nallocd - snallocd;
@@ -252,7 +253,7 @@
   return env;
 }
 
-P YPvm_fun_env_fab (P n) { return ENVFAB((int)n); }
+P YPvm_fun_env_fab (P n) { return ENVFAB((PINT)n); }
 
 P FABENV (int size, ...) {
   int i;
@@ -510,6 +511,7 @@
       return "<loc>";
     }
   }
+  return "BOGUS"; /* should be unreachable */
 }
 
 #define MIN(x,y) ((x)<(y) ? (x) : (y))
@@ -538,9 +540,9 @@
   } 
   switch (t) {
   case int_tag:
-    printf("%d", untag(adr)); return;
+    printf("%ld", untag(adr)); return;
   case chr_tag:
-    printf("%c", untag(adr)); return;
+    printf("%c", (char)untag(adr)); return;
   case loc_tag:
     printf("&0x%lx", tag((P)untag(adr), 0)); return;
   default:
@@ -551,7 +553,7 @@
   } else if (strcmp(typename, "<chr>") == 0) {
     printf("%c", (char)(PINT)YPprop_elt(adr, (P)0));
   } else if (strcmp(typename, "<loc>") == 0) {
-    printf("&0x%lx", YPprop_elt(adr, (P)0));
+    printf("&0x%lx", (PINT)YPprop_elt(adr, (P)0));
   } else if (strcmp(typename, "<flo>") == 0) {
     INTFLO x;
     x.i = (PINT)YPprop_elt(adr, (P)0);
@@ -640,21 +642,21 @@
       printf("]");
     }
     */
-    printf(" 0x%lx)", adr);
+    printf(" 0x%lx)", (PINT)adr);
   } else if (strcmp(typename, "<gen>") == 0) {
     printf("(GEN ");
     print_kind((P)YPmet_name(adr), 0, depth+1);
     print_kind(FUNSPECS(adr), 0, depth + 1);
-    printf(" 0x%lx)", adr);
+    printf(" 0x%lx)", (PINT)adr);
   } else if (strcmp(typename, "<file-out-port>") == 0) {
-    printf("(OUT-PORT 0x%lx)", adr);
+    printf("(OUT-PORT 0x%lx)", (PINT)adr);
   } else if (strcmp(typename, "<file-in-port>") == 0) {
-    printf("(IN-PORT 0x%lx)", adr);
+    printf("(IN-PORT 0x%lx)", (PINT)adr);
   } else {
     int i;
     P c       = YPobject_class(adr);
-    int size  = (int)YPiu(YPclass_prop_len(c));
-    int below = MIN(size, 10);
+    PINT size = (PINT)YPiu(YPclass_prop_len(c));
+    PINT below = MIN(size, 10);
     printf("(%s", typename);
     for (i = 0; i < below; i++) {
       printf(" "); 
@@ -664,7 +666,7 @@
 	printf("..."); break;
       }
     }
-    printf(" 0x%lx)", adr);
+    printf(" 0x%lx)", (PINT)adr);
   }} else {
     printf("<>");
   }
@@ -679,19 +681,19 @@
     printf("NUL");
   else {
     char* typename = type(adr);
-    printf("0x%lx", adr);
+    printf("0x%lx", (PINT)adr);
     if (typename) 
       printf(" ISA %s", typename);
   }
 }
-void desprop (int i, P adr) {
-  printf("%d: ", i);
+void desprop (PINT i, P adr) {
+  printf("%ld: ", i);
   prtobj(adr);
   printf("\n");
 }
 
 void desobj (P adr) {
-  int i;
+  PINT i;
   if (adr == PNUL) {
     printf("PNUL\n");
   } else {
@@ -709,15 +711,15 @@
       int genp  = strcmp(typename, "<gen>") == 0;
       int funp  = metp | genp;
       P c       = YPobject_class(adr);
-      int size  = (int)YPiu(YPclass_prop_len(c));
+      PINT size = (PINT)YPiu(YPclass_prop_len(c));
       int from  = funp ? 1 : 0;
-      int below = MIN(metp ? size - 1 : size, 10);
+      PINT below = MIN(metp ? size - 1 : size, 10);
       for (i = from; i < below; i++)
 	desprop(i, YPprop_elt(adr, (PINT)i));
       if (metp) {
 	int j;
 	ENV env = (ENV)YPprop_elt(adr, (P)FUNENVOFFSET);
-	printf("ENV SIZE %d\n", env->size);
+	printf("ENV SIZE %ld\n", env->size);
 	for (j = 0; j < env->size; j++, i++)
 	  desprop(i, ENVGET(env, j));
       }
@@ -814,7 +816,7 @@
 }
 
 P YevalSg2cYPprint_cpu_usage(char *message) {
-	return;
+	return PNUL;
 /*
   struct rusage usage;
   getrusage(RUSAGE_SELF, &usage);
@@ -965,7 +967,7 @@
 }
 
 P YPfab_dyn_var() {
-  T* key = (T*)allocate(sizeof(T));
+  int* key = (int*)allocate(sizeof(int));
   DYNFAB(key);
   return (P)key;
 }
@@ -1000,7 +1002,7 @@
   *key = dynvar_key++;
   if (dynvar_key > MAX_DYNVARS)
     XXCALL1(1, Yerror, YPsb("TOO MANY DYNAMIC VARIABLES."));
-  return (P)*key;
+  return (P)(PINT)*key;
 }
 
 REGS YPfab_regs() {
--- goo-0.155.orig/c/grt.h
+++ goo-0.155/c/grt.h
@@ -4,6 +4,8 @@
 #define IN_GRT
 #if !defined(_MSC_VER)
 #include "config.h"
+#define _GNU_SOURCE
+#include <unistd.h>
 #else
 #undef PINT
 #define NOGDI
@@ -13,15 +15,22 @@
 #undef PINT
 #undef WIN32
 #endif
+#ifdef WITH_THREADS
+#define GC_THREADS
+#define _REENTRANT
+#endif
 #include <time.h>
 #include <stdarg.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <setjmp.h>
 #include <math.h>
 #ifdef HAVE_POSIX_THREAD
 #include <pthread.h>
-#include <gc/gc_pthread_redirects.h>
+/* gc.h will do this for us after setting up its own configuration
+   macros properly; including it prematurely can backfire. */
+/* #include <gc/gc_pthread_redirects.h> */
 #endif
 
 #if defined(_MSC_VER)
@@ -46,6 +55,12 @@
 #define IMPORTEXPORT
 #endif
 
+#ifdef __GNUC__
+#define UNUSED __attribute__((__unused__))
+#else
+#define UNUSED
+#endif
+
 /* LOW LEVEL */
 
 typedef FILE*          PPORT;
@@ -79,6 +94,26 @@
 IMPORTEXPORT extern P YPopts(P loc, P len);
 IMPORTEXPORT extern P YPib(P i);
 
+IMPORTEXPORT extern P YOadd (P,P);
+IMPORTEXPORT extern P YOadd_new (P,P);
+IMPORTEXPORT extern P YOlen (P);
+IMPORTEXPORT extern P YOpair (P,P);
+IMPORTEXPORT extern P YOtail_setter (P,P);
+IMPORTEXPORT extern P YPallocate_stack (P);
+IMPORTEXPORT extern P YPdo_stack_frames (P fun);
+IMPORTEXPORT extern P YPfb (P);
+IMPORTEXPORT extern P YPfu (P);
+IMPORTEXPORT extern P YPhead_setter (P,P);
+IMPORTEXPORT extern P YPiu (P);
+IMPORTEXPORT extern P YPrep (P,P);
+IMPORTEXPORT extern P YPstr (P,P);
+IMPORTEXPORT extern P YPtail_setter (P,P);
+
+IMPORTEXPORT extern P YPunexec(P name);
+IMPORTEXPORT extern P YevalSg2cYPprint_cpu_usage(char *message);
+IMPORTEXPORT extern P allocate (unsigned long size);
+IMPORTEXPORT extern P allocate_atomic (unsigned long size);
+
 /*
   Not used yet.
 #define YPprim_nary_start(arg) va_list ap; va_start(ap, arg)
@@ -86,12 +121,12 @@
 #define YPprim_nary_end() va_end(ap)
 */
 
-#define YPEE(x, y)    ((x) == (y))
-#define YPeqQ(x, y)   ((x) == (y))
+#define YPEE(x, y)    ((PLOG)((x) == (y)))
+#define YPeqQ(x, y)   ((PLOG)((x) == (y)))
 #define YPbb(x)       (((x) == 0) ? YPfalse : YPtrue)
-#define YPbu(x)       ((x) == YPfalse)
-#define YPiE(x, y)    (((PINT)(x)) == ((PINT)(y)))
-#define YPiL(x, y)    (((PINT)(x)) <  ((PINT)(y)))
+#define YPbu(x)       ((PLOG)((x) == YPfalse))
+#define YPiE(x, y)    ((PLOG)(((PINT)(x)) == ((PINT)(y))))
+#define YPiL(x, y)    ((PLOG)(((PINT)(x)) <  ((PINT)(y))))
 #define YPiA(x, y)    (((PINT)(x)) +  ((PINT)(y)))
 #define YPi_(x, y)    (((PINT)(x)) -  ((PINT)(y)))
 #define YPiT(x, y)    (((PINT)(x)) *  ((PINT)(y)))
@@ -107,8 +142,8 @@
 #define YPiGG(x, y)   (((PINT)(x)) >> ((PINT)(y)))
 #define YPiLLL(x, y)  (((PINT)(x)) << ((PINT)(y))) /* TODO: FIX THIS <<< */
 #define YPiGGG(x, y)  (((PINT)(x)) >> ((PINT)(y))) /* TODO: FIX THIS >>> */
-#define YPcE(x, y)    (((PCHR)(PINT)(x)) == ((PCHR)(PINT)(y)))
-#define YPcL(x, y)    (((PCHR)(PINT)(x)) <  ((PCHR)(PINT)(y)))
+#define YPcE(x, y)    ((PLOG)(((PCHR)(PINT)(x)) == ((PCHR)(PINT)(y))))
+#define YPcL(x, y)    ((PLOG)(((PCHR)(PINT)(x)) <  ((PCHR)(PINT)(y))))
 
 #define RTVBOUNDP(x)  (((x) == PNUL) ? YPfalse : YPtrue)
 #define BOUNDP(x)     RTVBOUNDP(x)
@@ -145,11 +180,46 @@
 #define YPprop_elt_setter(z, x, i) (((OBJECT)(x))->values[(PINT)(i)] = (z))
 #define YPprop_dat_at(x, i)        (&(((OBJECT)(x))->values[(PINT)(i)]))
 
+IMPORTEXPORT extern P YPclass (P,P,P,P,P,P,P,P,P,P,P,P);
+IMPORTEXPORT extern P YPclass_ancestors_setter (P,P);
+IMPORTEXPORT extern P YPclass_children_setter (P,P);
+IMPORTEXPORT extern P YPclass_direct_props_setter (P,P);
+IMPORTEXPORT extern P YPclass_forward_setter (P,P);
+IMPORTEXPORT extern P YPclass_gens_setter (P,P);
+IMPORTEXPORT extern P YPclass_id_setter (P,P);
+IMPORTEXPORT extern P YPclass_mets_setter (P,P);
+IMPORTEXPORT extern P YPclass_prop_len_setter (P,P);
+IMPORTEXPORT extern P YPclass_props_setter (P,P);
+IMPORTEXPORT extern P YPclass_row_setter (P,P);
+
 /* FLO */
 
 IMPORTEXPORT extern P FLOINT (PFLO x);
 IMPORTEXPORT extern P YPflo_bits (P x);
 
+IMPORTEXPORT extern P YgooSmathYPfA(P x, P y);
+IMPORTEXPORT extern P YgooSmathYPfE(P x, P y);
+IMPORTEXPORT extern P YgooSmathYPfL(P x, P y);
+IMPORTEXPORT extern P YgooSmathYPfS(P x, P y);
+IMPORTEXPORT extern P YgooSmathYPfT(P x, P y);
+IMPORTEXPORT extern P YgooSmathYPf_(P x, P y);
+IMPORTEXPORT extern P YgooSmathYPfacos(P x);
+IMPORTEXPORT extern P YgooSmathYPfasin(P x);
+IMPORTEXPORT extern P YgooSmathYPfatan(P x);
+IMPORTEXPORT extern P YgooSmathYPfatan2(P y, P x);
+IMPORTEXPORT extern P YgooSmathYPfcos(P x);
+IMPORTEXPORT extern P YgooSmathYPfcosh(P x);
+IMPORTEXPORT extern P YgooSmathYPfi2f(P x);
+IMPORTEXPORT extern P YgooSmathYPflo_bits (P x);
+IMPORTEXPORT extern P YgooSmathYPflog(P x);
+IMPORTEXPORT extern P YgooSmathYPfpow(P x, P n);
+IMPORTEXPORT extern P YgooSmathYPfsin(P x);
+IMPORTEXPORT extern P YgooSmathYPfsinh(P x);
+IMPORTEXPORT extern P YgooSmathYPfsqrt(P x);
+IMPORTEXPORT extern P YgooSmathYPft(P x);
+IMPORTEXPORT extern P YgooSmathYPftan(P x);
+IMPORTEXPORT extern P YgooSmathYPftanh(P x);
+
 /* REP */
 
 #define REP_LEN_OFF 0
@@ -174,6 +244,9 @@
 #define YPtelt(x, i)           ((P)(YPprop_elt((x), (PINT)((char*)REP_DAT_OFF + (long)(i)))))
 #define YPtelt_setter(z, x, i) ((P)(YPprop_elt_setter((z), (x), (PINT)((char*)REP_DAT_OFF + (long)(i)))))
 
+IMPORTEXPORT extern P YPopts_tup (P,P,P);
+IMPORTEXPORT extern P YPtup (P,P);
+
 /* STR */
 
 #if !defined(_MSC_VER)
@@ -182,7 +255,7 @@
 
 IMPORTEXPORT extern P YPPsfab (P size, P fill);
 IMPORTEXPORT extern P YPsb (P str);
-#define YPsu(x)                ((P)(YPrep_dat(x)))
+#define YPsu(x)                ((char*)(YPrep_dat(x)))
 #define YPslen(x)              ((P)(YPprop_elt((x), (PINT)REP_LEN_OFF)))
 #define YPselt(x, i)           ((P)(PINT)(((PSTR)(YPsu(x)))[((PINT)(i))]))
 #define YPselt_setter(z, x, i) ((P)(PINT)(((PSTR)(YPsu(x)))[((PINT)(i))] = ((PCHR)(PINT)(z))))
@@ -201,6 +274,41 @@
     }                                                                         \
   } while (0)
 
+IMPORTEXPORT extern P YgooSsystemYPcompile (P cfile, P sofile, P incs, P libs);
+IMPORTEXPORT extern P YgooSsystemYPcreate_directory (P name);
+IMPORTEXPORT extern P YgooSsystemYPfile_existsQ (P name);
+IMPORTEXPORT extern P YgooSsystemYPfile_mtime (P name);
+IMPORTEXPORT extern P YgooSsystemYPfile_type (P name);
+IMPORTEXPORT extern P YgooSsystemYPload(P name);
+IMPORTEXPORT extern P YgooSsystemYPos_name ();
+IMPORTEXPORT extern P YgooSsystemYPos_val (P name);
+IMPORTEXPORT extern P YgooSsystemYPos_val_setter (P value, P name);
+IMPORTEXPORT extern P YgooSsystemYPtime ();
+
+IMPORTEXPORT extern P YtimeSeventYPevent_broadcast (P handle);
+IMPORTEXPORT extern P YtimeSeventYPevent_create (P name);
+IMPORTEXPORT extern P YtimeSeventYPevent_reset (P handle);
+IMPORTEXPORT extern P YtimeSeventYPevent_signal (P handle);
+IMPORTEXPORT extern P YtimeSeventYPevent_wait (P event, P lock);
+IMPORTEXPORT extern P YtimeSeventYPevent_wait_timed (P event, P lock,
+						     P timeout);
+
+IMPORTEXPORT extern P YtimeSlockYPlock_create (P name);
+IMPORTEXPORT extern P YtimeSlockYPlock_destroy (P handle);
+IMPORTEXPORT extern P YtimeSlockYPlock_lock (P handle);
+IMPORTEXPORT extern P YtimeSlockYPlock_try_lock (P handle);
+IMPORTEXPORT extern P YtimeSlockYPlock_unlock (P handle);
+
+IMPORTEXPORT extern P YtimeSthreadsYPthread_create (P function);
+IMPORTEXPORT extern P YtimeSthreadsYPthread_current ();
+IMPORTEXPORT extern P YtimeSthreadsYPthread_detach ();
+IMPORTEXPORT extern P YtimeSthreadsYPthread_goo_thread ();
+IMPORTEXPORT extern P YtimeSthreadsYPthread_goo_thread_setter (P value);
+IMPORTEXPORT extern P YtimeSthreadsYPthread_join (P thread);
+IMPORTEXPORT extern P YtimeSthreadsYPthread_priority (P thread);
+IMPORTEXPORT extern P YtimeSthreadsYPthread_priority_setter (P x, P thread);
+IMPORTEXPORT extern P YtimeSthreadsYPthread_sleep (P secs);
+IMPORTEXPORT extern P YtimeSthreadsYPthread_yield ();
 
 /* CLOSURES */
 
@@ -314,6 +422,10 @@
 #define FUNENVGET(f, i)    ENVGET(FUNENV((f)), (i))
 #define FUNENVPUT(z, f, i) ENVPUT((z), FUNENV((f)), (i))
 
+IMPORTEXPORT extern P YgooSfunYprop_bound_atQ (P,P);
+IMPORTEXPORT extern P YgooSfunYprop_value_at (P,P);
+IMPORTEXPORT extern P YgooSfunYprop_value_at_setter (P,P,P);
+
 // THREAD LOCAL VARIABLE SUPPORT
 
 #ifdef WITH_THREADS
@@ -364,28 +476,28 @@
 #define REGSCREF()    (regs?regs:(regs=REGSREF()))
 #define REGSSET(v)    TSET(tregs, (P)(v))
 #define DEFREGS()     REGS regs = REGSREF()
-#define DEFCREGS()    REGS regs = (REGS)0
-#define YPdef_regs()  regs = REGSREF()
-#define YPset_regs(x) regs = (REGS)(x)
+#define DEFCREGS()    REGS regs UNUSED = (REGS)0
+#define YPdef_regs()  (regs = REGSREF())
+#define YPset_regs(x) (regs = (REGS)(x))
 
 #define REG(x)       (regs->x)
 #define CREG(x)      (REGSCREF()->x)
 #define REGSET(x, v) (regs->x = (v))
 
-#define MAX_STACK_SIZE         70000
+#define MAX_STACK_SIZE         170000
 #define YPmax_stack_len()      (MAX_STACK_SIZE)
 
 #define YPfun_reg()            (Pfun)
 #define YPnext_methods_reg()   (REG(next_methods))
 #define YPnext_methods_reg_setter(x) (REG(next_methods) = (x))
 #define YPsp_reg()             (REG(sp))
-#define YPsp_elt(i)            (REG(sp)[(int)i])
+#define YPsp_elt(i)            (REG(sp)[(PINT)i])
 #define YPfp_reg()             (REG(fp))
 #define YPsp_reg_setter(value) (REGSET(sp, value))
 #define YPfp_reg_setter(value) (REGSET(fp, value))
 #define YPstack_reg()          (REG(stack))
-#define YPstack_check_regQ()          (P)(REG(stack_checkp))
-#define YPstack_check_regQ_setter(x)  (REGSET(stack_checkp, (int)x))
+#define YPstack_check_regQ()          (P)(PINT)(REG(stack_checkp))
+#define YPstack_check_regQ_setter(x)  (REGSET(stack_checkp, (int)(PINT)x))
 
 #define YPvpc()             (REG(vpc))
 #define YPvfn()             (REG(vfn))
@@ -441,6 +553,11 @@
   return ((P*)v)[(PINT)i] = x;
 }
 
+IMPORTEXPORT extern P YPtag (P,P);
+IMPORTEXPORT extern P YPtag_into (P,P);
+IMPORTEXPORT extern P YPuntag (P);
+IMPORTEXPORT extern P YPuntag_into (P);
+
 
 /* CALLS */
 
@@ -468,7 +585,7 @@
 */
 
 #define FUNREG()          *(REG(sp)-1)
-#define LINK_STACK()      P Pfun = FUNREG(); P Pnext_methods = REG(next_methods); *REG(sp) = REG(fp); REGSET(fp, REG(sp)); REGSET(sp, REG(sp)+1); 
+#define LINK_STACK()      P Pfun UNUSED = FUNREG(); P Pnext_methods UNUSED = REG(next_methods); *REG(sp) = REG(fp); REGSET(fp, REG(sp)); REGSET(sp, REG(sp)+1); 
 #define UNLINK_STACK()    {REGSET(sp, REG(fp));  REGSET(fp, *REG(sp)); }
 #define YPunlink_stack() (0);UNLINK_STACK()
 #define ARGLEN()          (REG(fp)[-2])
@@ -664,6 +781,18 @@
 #define RET(x) \
   { YPfun_val_check_type(regs, (x), Pfun); return (x); }
 
+IMPORTEXPORT extern P YOsingleton_isaQ (P,P);
+IMPORTEXPORT extern P YPfun_cache_setter (P,P);
+IMPORTEXPORT extern P YPgen_cache (P,P,P,P,P);
+IMPORTEXPORT extern P YPgen_cache_arg_pos_setter (P,P);
+IMPORTEXPORT extern P YPgen_cache_classes_setter (P,P);
+IMPORTEXPORT extern P YPgen_cache_singletons_setter (P,P);
+IMPORTEXPORT extern P YPgen_code_setter (P,P);
+IMPORTEXPORT extern P YPgen_mets_setter (P,P);
+IMPORTEXPORT extern P YPmet_env_setter (P,P);
+IMPORTEXPORT extern P YPpatch_early_generics ();
+IMPORTEXPORT extern P YPsingleton (P);
+
 /* NON-LOCAL EXITS */
 
 IMPORTEXPORT extern P do_exit (REGS regs );
@@ -767,7 +896,7 @@
 IMPORTEXPORT extern P regsym (P* adr, char *modstr, char *namestr);
 IMPORTEXPORT extern P YPdo_runtime_bindings (P fun);
 
-/* EOF OBJECT */
+/* I/O */
 
 STATIC_NOT_GRT_C INLINE P YPeof_objectQ (P x) { 
   return (P)(PLOG)((PINT)x == EOF); 
@@ -777,6 +906,20 @@
   return (P)EOF; 
 }
 
+IMPORTEXPORT extern P YgooSioSportYPclose_in_port (P s);
+IMPORTEXPORT extern P YgooSioSportYPclose_out_port (P s);
+IMPORTEXPORT extern PPORT YgooSioSportYPcurrent_in_port (void);
+IMPORTEXPORT extern PPORT YgooSioSportYPcurrent_out_port (void);
+IMPORTEXPORT extern P YgooSioSportYPforce_out (P s);
+IMPORTEXPORT extern P YgooSioSportYPget (P s);
+IMPORTEXPORT extern P YgooSioSportYPnewline (P s);
+IMPORTEXPORT extern P YgooSioSportYPopen_in_file (P name);
+IMPORTEXPORT extern P YgooSioSportYPopen_out_file (P name);
+IMPORTEXPORT extern P YgooSioSportYPpeek (P s);
+IMPORTEXPORT extern P YgooSioSportYPput (P s, P x);
+IMPORTEXPORT extern P YgooSioSportYPputs (P s, P x);
+IMPORTEXPORT extern P YgooSioSportYPreadyQ (P s);
+
 /* LOCATIVES */
 
 STATIC_NOT_GRT_C  INLINE P YPloc_val (P loc) {
--- goo-0.155.orig/c/g2c/goo/boot.c
+++ goo-0.155/c/g2c/goo/boot.c
@@ -984,13 +984,13 @@
 
 P YPallocate_stack(P num_) {
   P retF1;
-  P T0,T1,T2,T3;
+  P T0,T1,T2,T3,T4;
 DEFCREGS();
   (P)YPdef_regs();
-  T3 = (P)YPsp_reg();
-  retF1 = T3;
+  T4 = (P)YPsp_reg();
+  retF1 = T4;
   T1 = (P)YPsp_reg();
-  T2 = (P)YPiT((P)4,num_);
+  T3 = (P)(sizeof(P));  T2 = (P)YPiT(T3,num_);
   T0 = (P)YPiA(T1,T2);
   (P)YPsp_reg_setter(T0);
   return retF1;
--- goo-0.155.orig/c/g2c/goo/%system.c
+++ goo-0.155/c/g2c/goo/%system.c
@@ -6,8 +6,10 @@
 
 #include <sys/stat.h>
 #if !defined(_MSC_VER)
+#include <sys/wait.h>
 #include <unistd.h>
 #endif
+#include <ctype.h>
 #include <errno.h>
 
 extern P Yfab_sym;
@@ -236,6 +238,7 @@
   printf("Got to 8\n");
   return YPtrue;
 */
+  return PNUL;
 #endif
 }
 
@@ -269,7 +272,7 @@
   mod = dlopen(name, RTLD_NOW | RTLD_GLOBAL);
   if (mod == NULL)
   {
-    printf("FAILED TO LOAD %s BECAUSE %s\n", name, dlerror());
+    printf("FAILED TO LOAD %s BECAUSE %s\n", (char*)name, dlerror());
 	return YPfalse;
   }
   else {
--- goo-0.155.orig/c/g2c/goo/bignum.c
+++ goo-0.155/c/g2c/goo/bignum.c
@@ -785,7 +785,7 @@
 static inline PINT iu (P x) { return (PINT)IU(x); }
 static inline P    ib (PINT x) { return (P)tag((P)x, int_tag); }
 
-static inline mpz_init_zero(mpz_ptr z) {
+static inline void mpz_init_zero(mpz_ptr z) {
   z->_mp_size  = 0;
   z->_mp_alloc = 0;
   z->_mp_d     = &dummy_limb;
@@ -885,6 +885,7 @@
 
 P gmp_initialize () {
   mp_set_memory_functions(GC_malloc, gmp_realloc, do_nothing_free);
+  return PNUL;
 }
 
 
@@ -1630,7 +1631,7 @@
 LINK_STACK();
   ARG(x_, 0);
   ARG(y_, 1);
-  T3 = (P)( mpz_sgn(bignum_to_mpz(y_)) );  xF5279 = T3;
+  T3 = (P)( (PINT)mpz_sgn(bignum_to_mpz(y_)) );  xF5279 = T3;
   xF5280 = xF5279;
   tF5281 = (P)1;
   T2 = (P)YPiLL(xF5280,(P)2);
@@ -1649,7 +1650,7 @@
 LINK_STACK();
   ARG(x_, 0);
   ARG(y_, 1);
-  T3 = (P)( mpz_sgn(bignum_to_mpz(x_)) );  xF5282 = T3;
+  T3 = (P)( (PINT)mpz_sgn(bignum_to_mpz(x_)) );  xF5282 = T3;
   xF5283 = xF5282;
   tF5284 = (P)1;
   T2 = (P)YPiLL(xF5283,(P)2);
@@ -1668,7 +1669,7 @@
 LINK_STACK();
   ARG(x_, 0);
   ARG(y_, 1);
-  T3 = (P)( mpz_cmp(bignum_to_mpz(x_), bignum_to_mpz(y_)) );  xF5285 = T3;
+  T3 = (P)( (PINT)mpz_cmp(bignum_to_mpz(x_), bignum_to_mpz(y_)) );  xF5285 = T3;
   xF5286 = xF5285;
   tF5287 = (P)1;
   T2 = (P)YPiLL(xF5286,(P)2);
@@ -1687,7 +1688,7 @@
 LINK_STACK();
   ARG(x_, 0);
   ARG(y_, 1);
-  T3 = (P)( mpz_cmp(bignum_to_mpz(x_), bignum_to_mpz(y_)) );  xF5288 = T3;
+  T3 = (P)( (PINT)mpz_cmp(bignum_to_mpz(x_), bignum_to_mpz(y_)) );  xF5288 = T3;
   xF5289 = xF5288;
   tF5290 = (P)1;
   T2 = (P)YPiLL(xF5289,(P)2);
@@ -1979,7 +1980,7 @@
 LINK_STACK();
   ARG(x_, 0);
   ARG(y_, 1);
-  T1 = (P)( mpz_tstbit(bignum_to_mpz(x_), iu(y_)) );  T0 = (P)YPbb(T1);
+  T1 = (P)( (PLOG)mpz_tstbit(bignum_to_mpz(x_), iu(y_)) );  T0 = (P)YPbb(T1);
 UNLINK_STACK();
   RET(T0);
 }
@@ -2000,7 +2001,7 @@
   P T0,T1;
 LINK_STACK();
   ARG(x_, 0);
-  T1 = (P)( mpz_odd_p(bignum_to_mpz(x_)) );  T0 = (P)YPbb(T1);
+  T1 = (P)( (PLOG)mpz_odd_p(bignum_to_mpz(x_)) );  T0 = (P)YPbb(T1);
 UNLINK_STACK();
   RET(T0);
 }
@@ -2192,7 +2193,7 @@
   dividedF5316 = T5;
   resultF5317 = YPint((P)0);
   YPfalse;
-{  INTFLO iz;  iz.i = (P)YPfu(x_);
+{  INTFLO iz;  iz.i = (PINT)(P)YPfu(x_);
      if (rawint_fits_fixnum((PINT)iz.f))
        resultF5317 = ib((PINT)iz.f);
      else { 
--- goo-0.155.orig/c/g2c/time/%event.c
+++ goo-0.155/c/g2c/time/%event.c
@@ -12,27 +12,28 @@
 }
 
 P YtimeSeventYPevent_reset (P handle) {
-  return (P)pthread_cond_init((pthread_cond_t *)handle, NULL); // TODO: ????
+  return (P)(PINT)pthread_cond_init((pthread_cond_t *)handle, NULL); // TODO: ????
 }
 
 P YtimeSeventYPevent_pulse (P handle) {
   // return (P)PulseEvent((HANDLE)handle);
+  return PNUL;
 }
 
 P YtimeSeventYPevent_signal (P handle) {
-  return (P)pthread_cond_signal((pthread_cond_t *)handle);
+  return (P)(PINT)pthread_cond_signal((pthread_cond_t *)handle);
 }
 
 P YtimeSeventYPevent_broadcast (P handle) {
-  return (P)pthread_cond_broadcast((pthread_cond_t *)handle);
+  return (P)(PINT)pthread_cond_broadcast((pthread_cond_t *)handle);
 }
 
 P YtimeSeventYPevent_destroy (P handle) {
-  return (P)pthread_cond_destroy((pthread_cond_t *)handle);
+  return (P)(PINT)pthread_cond_destroy((pthread_cond_t *)handle);
 }
 
 P YtimeSeventYPevent_wait (P event, P lock) {
-  return (P)pthread_cond_wait
+  return (P)(PINT)pthread_cond_wait
     ((pthread_cond_t *)event, (pthread_mutex_t *)lock);
 }
 
@@ -42,7 +43,7 @@
   x.i = (PINT)timeout;
   time.tv_sec  = (time_t)truncf(x.f);
   time.tv_nsec = (long)((x.f - time.tv_sec) * 1000000000.0);
-  return (P)pthread_cond_timedwait
+  return (P)(PINT)pthread_cond_timedwait
     ((pthread_cond_t *)event, (pthread_mutex_t *)lock, &time);
 }
 
--- goo-0.155.orig/c/g2c/time/%threads.c
+++ goo-0.155/c/g2c/time/%threads.c
@@ -34,11 +34,11 @@
 }
 
 P YtimeSthreadsYPthread_yield () {
-  return (P)pthread_yield();
+  return (P)(PINT)pthread_yield();
 }
 
 P YtimeSthreadsYPthread_join (P thread) {
-  return (P)GC_pthread_join(thread);
+  return (P)(PINT)GC_pthread_join((pthread_t)thread, NULL);
 }
 
 P YtimeSthreadsYPthread_priority (P thread) {
@@ -53,7 +53,7 @@
 
 P YtimeSthreadsYPthread_sleep (P secs) {  
   INTFLO x;
-  int res;
+  PINT res;
   // struct timespec time, rem;
   x.i = (PINT)secs;
   // time.tv_sec  = (time_t)truncf(x.f);
@@ -68,7 +68,7 @@
 }
 
 P YtimeSthreadsYPthread_detach () {
-  return (P)pthread_detach(pthread_self());
+  return (P)(PINT)pthread_detach(pthread_self());
 }
 
 #elif defined(MSVC_THREAD)
--- goo-0.155.orig/c/g2c/time/%lock.c
+++ goo-0.155/c/g2c/time/%lock.c
@@ -11,19 +11,19 @@
 }
 
 P YtimeSlockYPlock_lock (P handle) {
-  return (P)pthread_mutex_lock((pthread_mutex_t *)handle);
+  return (P)(PINT)pthread_mutex_lock((pthread_mutex_t *)handle);
 }
 
 P YtimeSlockYPlock_try_lock (P handle) {
-  return (P)pthread_mutex_trylock((pthread_mutex_t *)handle);
+  return (P)(PINT)pthread_mutex_trylock((pthread_mutex_t *)handle);
 }
 
 P YtimeSlockYPlock_unlock (P handle) {
-  return (P)pthread_mutex_unlock((pthread_mutex_t *)handle);
+  return (P)(PINT)pthread_mutex_unlock((pthread_mutex_t *)handle);
 }
 
 P YtimeSlockYPlock_destroy (P handle) {
-  return (P)pthread_mutex_destroy((pthread_mutex_t *)handle);
+  return (P)(PINT)pthread_mutex_destroy((pthread_mutex_t *)handle);
 }
 
 #elif defined(MSVC_THREAD)
--- goo-0.155.orig/src/goo/%system.c
+++ goo-0.155/src/goo/%system.c
@@ -6,8 +6,10 @@
 
 #include <sys/stat.h>
 #if !defined(_MSC_VER)
+#include <sys/wait.h>
 #include <unistd.h>
 #endif
+#include <ctype.h>
 #include <errno.h>
 
 extern P Yfab_sym;
@@ -236,6 +238,7 @@
   printf("Got to 8\n");
   return YPtrue;
 */
+  return PNUL;
 #endif
 }
 
@@ -269,7 +272,7 @@
   mod = dlopen(name, RTLD_NOW | RTLD_GLOBAL);
   if (mod == NULL)
   {
-    printf("FAILED TO LOAD %s BECAUSE %s\n", name, dlerror());
+    printf("FAILED TO LOAD %s BECAUSE %s\n", (char*)name, dlerror());
 	return YPfalse;
   }
   else {
--- goo-0.155.orig/src/goo/boot.goo
+++ goo-0.155/src/goo/boot.goo
@@ -234,7 +234,7 @@
 (dl %allocate-stack (num)
   (%def-regs)
   (def ret (%sp-reg))
-  (set (%sp-reg) (%i+ (%sp-reg) (%i* (%raw 4) num)))
+  (set (%sp-reg) (%i+ (%sp-reg) (%i* (c-expr "sizeof(P)") num)))
   ret)
 
 ;; STRUCTURES ARE OBJECT TEMPLATES WITH 
--- goo-0.155.orig/src/goo/bignum.goo
+++ goo-0.155/src/goo/bignum.goo
@@ -11,7 +11,7 @@
 static inline PINT iu (P x) { return (PINT)IU(x); }
 static inline P    ib (PINT x) { return (P)tag((P)x, int_tag); }
 
-static inline mpz_init_zero(mpz_ptr z) {
+static inline void mpz_init_zero(mpz_ptr z) {
   z->_mp_size  = 0;
   z->_mp_alloc = 0;
   z->_mp_d     = &dummy_limb;
@@ -111,6 +111,7 @@
 
 P gmp_initialize () {
   mp_set_memory_functions(GC_malloc, gmp_realloc, do_nothing_free);
+  return PNUL;
 }
 
 }
@@ -194,16 +195,16 @@
 ;; can use this shortcut because bignums always have greater
 ;; magnitude than fixnums, so y > 0 => x < y
 (dm (< inline) (x|<fixnum> y|<bignum> => <log>)
-  (= #ei{ mpz_sgn(bignum_to_mpz($y)) } 1))
+  (= #ei{ (PINT)mpz_sgn(bignum_to_mpz($y)) } 1))
 
 (dm (< inline) (x|<bignum> y|<fixnum> => <log>)
-  (= #ei{ mpz_sgn(bignum_to_mpz($x)) } -1))
+  (= #ei{ (PINT)mpz_sgn(bignum_to_mpz($x)) } -1))
 
 (dm (< inline) (x|<bignum> y|<bignum> => <log>)
-  (= #ei{ mpz_cmp(bignum_to_mpz($x), bignum_to_mpz($y)) } -1))
+  (= #ei{ (PINT)mpz_cmp(bignum_to_mpz($x), bignum_to_mpz($y)) } -1))
 
 (dm (== inline) (x|<bignum> y|<bignum> => <log>)
-  (= #ei{ mpz_cmp(bignum_to_mpz($x), bignum_to_mpz($y)) } 0))
+  (= #ei{ (PINT)mpz_cmp(bignum_to_mpz($x), bignum_to_mpz($y)) } 0))
 
 (df (to-bignum inline) (x|<fixnum> => <bignum>)
   #eg{ fixnum_to_bignum($x) })
@@ -222,13 +223,13 @@
 (def-b       ~  "mpz_com")
 
 (dm (bit? inline) (x|<bignum> y|<fixnum> => <log>)
-  #eb{ mpz_tstbit(bignum_to_mpz($x), iu($y)) })
+  #eb{ (PLOG)mpz_tstbit(bignum_to_mpz($x), iu($y)) })
 
 (dm (even? inline) (x|<bignum> => <log>)
   (not (odd? x)))
 
 (dm (odd? inline) (x|<bignum> => <log>)
-  #eb{ mpz_odd_p(bignum_to_mpz($x)) })
+  #eb{ (PLOG)mpz_odd_p(bignum_to_mpz($x)) })
 
 ;;(dm (/ inline) (x|<bignum> y|<bignum> => <int>)
 ;;  (arithmetic-error "No int divide, consider trunc/"))
@@ -302,7 +303,7 @@
 (dm trunc/ (x|<flo> y|<flo> => (tup z|<int> rem|<flo>))
   (def divided (/ x y))
   (def result  0)
-  #{ INTFLO iz;  iz.i = $(%fu x);
+  #{ INTFLO iz;  iz.i = (PINT)$(%fu x);
      if (rawint_fits_fixnum((PINT)iz.f))
        $result = ib((PINT)iz.f);
      else { 
--- goo-0.155.orig/src/time/%event.c
+++ goo-0.155/src/time/%event.c
@@ -12,27 +12,28 @@
 }
 
 P YtimeSeventYPevent_reset (P handle) {
-  return (P)pthread_cond_init((pthread_cond_t *)handle, NULL); // TODO: ????
+  return (P)(PINT)pthread_cond_init((pthread_cond_t *)handle, NULL); // TODO: ????
 }
 
 P YtimeSeventYPevent_pulse (P handle) {
   // return (P)PulseEvent((HANDLE)handle);
+  return PNUL;
 }
 
 P YtimeSeventYPevent_signal (P handle) {
-  return (P)pthread_cond_signal((pthread_cond_t *)handle);
+  return (P)(PINT)pthread_cond_signal((pthread_cond_t *)handle);
 }
 
 P YtimeSeventYPevent_broadcast (P handle) {
-  return (P)pthread_cond_broadcast((pthread_cond_t *)handle);
+  return (P)(PINT)pthread_cond_broadcast((pthread_cond_t *)handle);
 }
 
 P YtimeSeventYPevent_destroy (P handle) {
-  return (P)pthread_cond_destroy((pthread_cond_t *)handle);
+  return (P)(PINT)pthread_cond_destroy((pthread_cond_t *)handle);
 }
 
 P YtimeSeventYPevent_wait (P event, P lock) {
-  return (P)pthread_cond_wait
+  return (P)(PINT)pthread_cond_wait
     ((pthread_cond_t *)event, (pthread_mutex_t *)lock);
 }
 
@@ -42,7 +43,7 @@
   x.i = (PINT)timeout;
   time.tv_sec  = (time_t)truncf(x.f);
   time.tv_nsec = (long)((x.f - time.tv_sec) * 1000000000.0);
-  return (P)pthread_cond_timedwait
+  return (P)(PINT)pthread_cond_timedwait
     ((pthread_cond_t *)event, (pthread_mutex_t *)lock, &time);
 }
 
--- goo-0.155.orig/src/time/%threads.c
+++ goo-0.155/src/time/%threads.c
@@ -34,11 +34,11 @@
 }
 
 P YtimeSthreadsYPthread_yield () {
-  return (P)pthread_yield();
+  return (P)(PINT)pthread_yield();
 }
 
 P YtimeSthreadsYPthread_join (P thread) {
-  return (P)GC_pthread_join(thread);
+  return (P)(PINT)GC_pthread_join((pthread_t)thread, NULL);
 }
 
 P YtimeSthreadsYPthread_priority (P thread) {
@@ -53,7 +53,7 @@
 
 P YtimeSthreadsYPthread_sleep (P secs) {  
   INTFLO x;
-  int res;
+  PINT res;
   // struct timespec time, rem;
   x.i = (PINT)secs;
   // time.tv_sec  = (time_t)truncf(x.f);
@@ -68,7 +68,7 @@
 }
 
 P YtimeSthreadsYPthread_detach () {
-  return (P)pthread_detach(pthread_self());
+  return (P)(PINT)pthread_detach(pthread_self());
 }
 
 #elif defined(MSVC_THREAD)
--- goo-0.155.orig/src/time/%lock.c
+++ goo-0.155/src/time/%lock.c
@@ -11,19 +11,19 @@
 }
 
 P YtimeSlockYPlock_lock (P handle) {
-  return (P)pthread_mutex_lock((pthread_mutex_t *)handle);
+  return (P)(PINT)pthread_mutex_lock((pthread_mutex_t *)handle);
 }
 
 P YtimeSlockYPlock_try_lock (P handle) {
-  return (P)pthread_mutex_trylock((pthread_mutex_t *)handle);
+  return (P)(PINT)pthread_mutex_trylock((pthread_mutex_t *)handle);
 }
 
 P YtimeSlockYPlock_unlock (P handle) {
-  return (P)pthread_mutex_unlock((pthread_mutex_t *)handle);
+  return (P)(PINT)pthread_mutex_unlock((pthread_mutex_t *)handle);
 }
 
 P YtimeSlockYPlock_destroy (P handle) {
-  return (P)pthread_mutex_destroy((pthread_mutex_t *)handle);
+  return (P)(PINT)pthread_mutex_destroy((pthread_mutex_t *)handle);
 }
 
 #elif defined(MSVC_THREAD)
--- goo-0.155.orig/debian/control
+++ goo-0.155/debian/control
@@ -0,0 +1,20 @@
+Source: goo
+Section: devel
+Priority: optional
+Maintainer: Aaron M. Ucko <ucko@debian.org>
+Build-Depends: debhelper (>> 7), dpkg-dev (>= 1.14.17), libgc-dev, libgmp3-dev
+Standards-Version: 3.8.0
+Homepage: http://www.googoogaga.org/
+
+Package: goo
+Architecture: any
+Depends: ${shlibs:Depends}
+Suggests: gcc, libgc-dev
+Description: generic object-orientator (programming language)
+ GOO is a dynamic, type-based, object-oriented language in the same family
+ as Dylan and Scheme.  It is designed to be simple, productive, powerful,
+ extensible, dynamic, efficient, and real-time.
+ .
+ Its main goal is to offer the best of both scripting and delivery
+ languages, while at the same time incorporating an extreme back-to-basics
+ philosophy.
--- goo-0.155.orig/debian/goo.1
+++ goo-0.155/debian/goo.1
@@ -0,0 +1,62 @@
+.TH GOO 1 "2005-08-04"
+.SH NAME
+goo, g2c \- generic object-orientator (programming language)
+.SH SYNOPSIS
+.B goo
+.br
+.B g2c
+.SH DESCRIPTION
+This manual page documents briefly the \fBgoo\fP and \fBg2c\fP commands.
+.PP
+\fBgoo\fP and \fBg2c\fP interactively evaluate statements in GOO, a
+dynamic, type-based, object-oriented language in the same family as
+Dylan and Scheme.
+The language is designed to be simple, productive, powerful,
+extensible, dynamic, efficient, and real-time.
+.PP
+\fBgoo\fP and \fBg2c\fP support two evaluation modes, controlled by
+the environment variable \fBGOO_EVAL_MODE\fP; the two commands differ
+only in which mode is the default.
+In \fBast\fP mode (short for "abstract syntax tree", and the default
+for \fBgoo\fP), they directly interpret parsed goo expressions.
+In \fBg2c\fP mode (the default for \fBg2c\fP), they instead translate
+expressions into dynamically compiled C code.
+.SH OPTIONS
+None.
+.SH USAGE
+Typing \fBgoo\fP or \fBg2c\fP at your shell will start up a \fBgoo\fP
+read-eval-print loop, which accepts s-expressions and top-level
+commands commencing with a comma.
+The following is a list of available commands:
+.TP
+\fB,quit\fP
+Exit the program.
+.TP
+\fB^C\fP\ (control-C)
+Invoke a recursive read-eval-print loop.
+.TP
+\fB,g2c-eval\fP
+Change to dynamic compilation evaluation.
+.TP
+\fB,ast-eval\fP
+Change to ast evaluation.
+.TP
+\fB,in\ ,\fP\fIname\fP
+Change to module \fIname\fP.
+.SH ENVIRONMENT
+.TP
+GOO_EVAL_MODE
+Determines evaluation mode, as documented in DESCRIPTION above.
+.TP
+GOO_ROOT
+Installation root (\fB/usr\fP on Debian systems); files needed at
+runtime can be found under \fB${GOO_ROOT}/lib/goo\fP.
+.SH SEE ALSO
+The full GOO reference manual: /usr/share/doc/goo/goo.pdf.gz or
+/usr/share/doc/goo/manual/goomanual.html .
+.SH AUTHOR
+goo was written by Jonathan Bachrach.
+.PP
+This manual page was written by Aaron M. Ucko <ucko@debian.org>, for
+the Debian project based on Jonathan's documentation (but may be used
+by others).
--- goo-0.155.orig/debian/rules
+++ goo-0.155/debian/rules
@@ -0,0 +1,62 @@
+#!/usr/bin/make -f
+
+CFLAGS += -Wall
+
+## Suppress some warnings that mostly just lead to noise.
+#CFLAGS += -Wno-sequence-point -Wno-pointer-sign -Wno-unused
+
+ifeq ($(shell dpkg-architecture -qDEB_HOST_ARCH),hppa)
+    CFLAGS += -ffunction-sections
+endif
+
+# Libgc doesn't (yet?) support threading on the Hurd, so we can't either.
+# See also http://bugs.debian.org/314367 .
+ifeq ($(shell dpkg-architecture -qDEB_HOST_ARCH_OS),hurd)
+    DEB_BUILD_OPTIONS += nothreads
+endif
+
+ifneq (,$(findstring nothreads,$(DEB_BUILD_OPTIONS)))
+# Explicitly specifying this option has the effect of confusing configure,
+# so leave it off and rely on the default being appropriate.
+#   DEB_CONFIGURE_EXTRA_FLAGS = --without-threads
+else
+    DEB_CONFIGURE_EXTRA_FLAGS = --with-threads
+endif
+
+build: build-stamp
+build-stamp:
+	dh build --before build
+# We need to be strict about requiring prototypes because many functions
+# return pointers, and their results may otherwise be misinterpreted on
+# 64-bit systems.  However, this flag inconveniently manages to make a
+# couple of configure's tests report false negatives, so we should pass it
+# only when actually building.
+	dh_auto_build -- CFLAGS="$(CFLAGS) -Werror-implicit-function-declaration"
+	dh build --after build
+	touch $@
+
+clean:
+	dh clean
+
+install: install-stamp
+install-stamp: build-stamp
+	dh install --until dh_prep
+# No support for DESTDIR yet :-/
+	dh_auto_install -- prefix=$(CURDIR)/debian/goo/usr
+	mv debian/goo/usr/bin/goo debian/goo/usr/bin/g2c
+	install -m 0755 -o root -g root debian/goo.sh debian/goo/usr/bin/goo
+	dh_installdocs -XCVS -X.svn -Xgooomanual
+	dh_installchangelogs txt/changes.txt
+	dh_installman debian/goo.1
+	dh install --remaining
+	touch $@
+
+binary-arch: install-stamp
+	dh binary-arch
+
+binary-indep: install-stamp
+	dh binary-indep
+
+binary: binary-arch # binary-indep
+
+.PHONY: build clean install binary binary-arch binary-indep
--- goo-0.155.orig/debian/watch
+++ goo-0.155/debian/watch
@@ -0,0 +1,3 @@
+version=3
+opts="uversionmangle=s/_/./g" \
+    http://people.csail.mit.edu/jrb/goo/goo-(.*)-any-dev.tar.gz
--- goo-0.155.orig/debian/changelog
+++ goo-0.155/debian/changelog
@@ -0,0 +1,194 @@
+goo (0.155-7) unstable; urgency=low
+
+  * Migrate from CDBS to Debhelper 7.
+  * Declare compliance with Policy 3.8.0.  (No changes needed.)
+
+ -- Aaron M. Ucko <ucko@debian.org>  Sat, 14 Jun 2008 17:26:08 -0400
+
+goo (0.155-6) unstable; urgency=low
+
+  * The "overdue spring cleaning" release.
+  * Clean up build dependencies, assuming a baseline of at least stable (etch).
+  * Advance to debhelper 6 on principle.
+  * Migrate home page annotation from long description to formal field.
+  * Clean up and clarify debian/copyright, following the machine-readable
+    format proposal (http://wiki.debian.org/Proposals/CopyrightFormat).
+  * Modernize doc-base section from Apps/Programming to Programming/Goo.
+  * Likewise modernize menu section to Applications/Programming.
+  * Override lintian regarding (upstream) CVS directories in source tree.
+  * Declare compliance with policy ("Standards-Version") 3.7.3.
+
+ -- Aaron M. Ucko <ucko@debian.org>  Wed, 26 Mar 2008 20:01:12 -0400
+
+goo (0.155-5) unstable; urgency=low
+
+  * Improve logic in debian/rules:
+    - Check DEB_HOST_* rather than DEB_BUILD_* for the sake of
+      cross-compilers.
+    - Honor the (nonstandard) DEB_BUILD_OPTIONS flag "nothreads".
+    - Never explicitly specify --without-threads, which ends up confusing
+      configure.
+  * Fix issues that led to crashes on 64-bit systems (closes: #325346):
+    - %allocate-stack: use sizeof(P) as the element size rather than
+      hardcoding 4.
+    - Ensure that no function is called without a prototype.
+    - Ensure that printf format strings and arguments match up.
+  * Take care of minor warnings that are either still of potential
+    significance or merely responsible for a lot of noise.
+  * Increase hardcoded MAX_STACK_SIZE from 70000 to 170000 [bytes] to keep
+    self-compilation from overflowing on 64-bit systems.
+  * Fix configure's test for thread-local-variable support.
+
+ -- Aaron M. Ucko <ucko@debian.org>  Mon,  5 Sep 2005 21:18:09 -0400
+
+goo (0.155-4) unstable; urgency=low
+
+  * Remove debian/conffiles and debian/dirs, which are redundant nowadays.
+  * Remove do-nothing maintainer script skeletons.
+  * Convert to CDBS (and debhelper 4).
+  * Don't install bogus "gooomanual" files.
+  * Fix grammar in debian/copyright.
+  * Make sure to quote all fields in debian/menu.
+  * Streamline wrapper script, and pass its arguments on to g2c.
+  * Note upstream changelog: txt/changes.txt.
+  * Add a rudimentary man page.
+  * Improve short description.
+  * Improve doc-base abstract, and add an entry for the PDF manual.
+  * Remove install-info-altdir cruft from emacsen install/remove scripts,
+    and enable -(-)no-site-file; also fix emacsen startup to use
+    debian-pkg-add-load-path-item.
+  * Update Standards-Version to 3.6.2 after verifying compliance.
+  * Prefix package-specific files used by debhelper with "goo.".
+  * Build without threads on the Hurd, as libgc does not (yet?) support
+    threading on that platform; since we base this check on
+    dpkg-architecture's DEB_BUILD_ARCH_OS variable, make sure to
+    build-depend on a suitable version of dpkg-dev.  (Closes: #314367.)
+  * Add a watch file.
+
+ -- Aaron M. Ucko <ucko@debian.org>  Fri, 26 Aug 2005 21:59:47 -0400
+
+goo (0.155-3) unstable; urgency=low
+
+  * New maintainer.  (Closes: #320076.)
+    - Thanks for maintaining the package up until now, Jonathan H!
+  * c/grt.h: parenthesize YP{def,set}_regs to fix FTBFS with GCC 4.
+    (Closes: #300102.)
+  * Version build-dependencies on libgc-dev and libgmp3-dev for the G++ 4
+    transition.  (Closes: #319551.)
+
+ -- Aaron M. Ucko <ucko@debian.org>  Fri, 29 Jul 2005 22:50:05 -0400
+
+goo (0.155-2) unstable; urgency=low
+
+  * Depend on libgc1 instead of libgc6c102
+
+ -- Jonathan Hseu <vomjom@debian.org>  Wed, 24 Mar 2004 04:41:13 -0600
+
+goo (0.155-1) unstable; urgency=low
+
+  * New upstream
+
+ -- Jonathan Hseu <vomjom@debian.org>  Wed, 10 Mar 2004 02:37:35 -0600
+
+goo (0.153-2) unstable; urgency=low
+
+  * Build-Depend on libgc-dev
+  * Package is rebuilt to depend on libgc1 which was recently renamed from
+    libgc6c102
+
+ -- Jonathan Hseu <vomjom@vomjom.org>  Wed, 20 Aug 2003 06:02:48 -0500
+
+goo (0.153-1) unstable; urgency=low
+
+  * New upstream
+
+ -- Jonathan Hseu <vomjom@debian.org>  Tue, 21 Jan 2003 21:13:45 -0600
+
+goo (0.146-1) unstable; urgency=low
+
+  * New upstream
+
+ -- Jonathan Hseu <vomjom@debian.org>  Tue,  3 Sep 2002 21:15:15 -0500
+
+goo (0.143-1) unstable; urgency=low
+
+  * New upstream
+
+ -- Jonathan Hseu <vomjom@debian.org>  Sat, 24 Aug 2002 14:54:11 -0500
+
+goo (0.142-1) unstable; urgency=low
+
+  * New upstream.
+
+ -- Jonathan Hseu <vomjom@debian.org>  Sat, 17 Aug 2002 01:34:40 -0500
+
+goo (0.140-3) unstable; urgency=low
+
+  * Fix for HPPA
+
+ -- Jonathan Hseu <vomjom@debian.org>  Sun, 21 Jul 2002 06:56:19 -0500
+
+goo (0.140-2) unstable; urgency=low
+
+  * Oops, change section from unknown -> devel
+
+ -- Jonathan Hseu <vomjom@debian.org>  Sun, 21 Jul 2002 05:59:28 -0500
+
+goo (0.140-1) unstable; urgency=low
+
+  * New upstream.
+
+ -- Jonathan Hseu <vomjom@debian.org>  Sun, 21 Jul 2002 03:54:03 -0500
+
+goo (0.133-6) unstable; urgency=low
+
+  * Move libgc6-dev and gcc from Depends to Suggests 
+  * Add an environment variable that sets evaluation mode
+  * Change /usr/bin/goo to use ast-eval mode
+
+ -- Jonathan Hseu <vomjom@debian.org>  Mon, 17 Jun 2002 21:30:42 -0500
+
+goo (0.133-5) unstable; urgency=low
+
+  * Add libgc6-dev and gcc to Depends
+
+ -- Jonathan Hseu <vomjom@debian.org>  Sat, 15 Jun 2002 03:44:57 -0500
+
+goo (0.133-4) unstable; urgency=low
+
+  * Yet another Ucko patch.  His notes:
+  * Compile with -ffunction-sections on HPPA.
+  * Conditionalize use of msync (fixing the Hurd build).
+  * Drop useless dependency on sharutils.
+
+ -- Jonathan Hseu <vomjom@debian.org>  Thu,  6 Jun 2002 19:16:46 -0400
+
+goo (0.133-3) unstable; urgency=medium
+
+  * Apply Aaron Ucko's patch.  The following are his notes:
+  * Urgency medium because this should address all the build failures.
+  * Use system -lgc rather than upstream i386 gc.a. (closes: Bug#148126)
+  * Fix 64-bit-unclean pointer->int casts; IA-64 binaries still segfault
+    immediately, though. :-/
+  * Compile in a default GOO_PATH of /usr/lib/goo, removing the need for
+    wrapper scripts.
+  * emacsen-startup: associate *.goo with goo-mode, provide autoloads for
+    goo-mode and run-goo.
+  * emacsen-install: don't compile goo-font-lock.el for xemacs; it
+    contains some FSF-isms, and nothing uses it directly anyway.
+    (closes: Bug#148948)
+
+ -- Jonathan Hseu <vomjom@debian.org>  Wed,  5 Jun 2002 23:47:25 -0500
+
+goo (0.133-2) unstable; urgency=low
+
+  * Fix goo-shell.el for xemacs (closes: Bug#148170)
+
+ -- Jonathan Hseu <vomjom@vomjom.org>  Fri, 31 May 2002 01:42:48 -0500
+
+goo (0.133-1) unstable; urgency=low
+
+  * Initial Release. (closes: Bug#147299)
+
+ -- Jonathan Hseu <vomjom@debian.org>  Sat, 18 May 2002 01:59:23 -0500
+
--- goo-0.155.orig/debian/goo.emacsen-startup
+++ goo-0.155/debian/goo.emacsen-startup
@@ -0,0 +1,19 @@
+;; -*-emacs-lisp-*-
+;;
+;; Emacs startup file for the Debian GNU/Linux goo package
+;;
+;; Originally contributed by Nils Naumann <naumann@unileoben.ac.at>
+;; Modified by Dirk Eddelbuettel <edd@debian.org>
+;; Adapted for dh-make by Jim Van Zandt <jrv@vanzandt.mv.com>
+
+;; The goo package follows the Debian/GNU Linux 'emacsen' policy and
+;; byte-compiles its elisp files for each 'emacs flavor' (emacs19,
+;; xemacs19, emacs20, xemacs20...).  The compiled code is then
+;; installed in a subdirectory of the respective site-lisp directory.
+;; We have to add this to the load-path:
+(debian-pkg-add-load-path-item
+ (concat "/usr/share/" (symbol-name flavor) "/site-lisp/goo"))
+(setq auto-mode-alist (cons '("\\.goo\\'" . goo-mode) auto-mode-alist))
+
+(autoload 'goo-mode "goo" "Major mode for editing Goo code." t)
+(autoload 'run-goo  "goo-shell" "Run an inferior Goo process." t)
--- goo-0.155.orig/debian/goo.install
+++ goo-0.155/debian/goo.install
@@ -0,0 +1 @@
+emacs/*.el usr/share/emacs/site-lisp/goo
--- goo-0.155.orig/debian/compat
+++ goo-0.155/debian/compat
@@ -0,0 +1 @@
+7
--- goo-0.155.orig/debian/goo.sh
+++ goo-0.155/debian/goo.sh
@@ -0,0 +1,4 @@
+#!/bin/sh
+: ${GOO_EVAL_MODE:=ast}
+export GOO_EVAL_MODE
+exec /usr/bin/g2c "$@"
--- goo-0.155.orig/debian/goo.emacsen-remove
+++ goo-0.155/debian/goo.emacsen-remove
@@ -0,0 +1,10 @@
+#!/bin/sh -e
+# /usr/lib/emacsen-common/packages/remove/goo
+
+FLAVOR=$1
+PACKAGE=goo
+
+if [ ${FLAVOR} != emacs ]; then
+    echo remove/${PACKAGE}: purging byte-compiled files for ${FLAVOR}
+    rm -rf /usr/share/${FLAVOR}/site-lisp/${PACKAGE}
+fi
--- goo-0.155.orig/debian/goo.doc-base
+++ goo-0.155/debian/goo.doc-base
@@ -0,0 +1,14 @@
+Document: goo
+Title: GOO (generic object-orientator) Reference Manual
+Author: Jonathan Bachrach
+Abstract: Full documentation for the GOO programming language, a dynamic,
+ type-based, object-oriented language in the same family as Dylan and
+ Scheme.
+Section: Programming/Goo
+
+Format: HTML
+Index: /usr/share/doc/goo/manual/goomanual.html
+Files: /usr/share/doc/goo/manual/*.html
+
+Format: PDF
+Files: /usr/share/doc/goo/goo.pdf.gz
--- goo-0.155.orig/debian/copyright
+++ goo-0.155/debian/copyright
@@ -0,0 +1,32 @@
+This package originates at http://www.googoogaga.org/ .
+
+Files: debian/*
+Copyright: © 2002-2004 Jonathan Hseu <vomjom@debian.org>
+           © 2005-2008 Aaron M. Ucko <ucko@debian.org>
+License: GPL-2+
+    The packaging is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+Files: c/unexelf.c
+Copyright: © 1985-2000 Free Software Foundation, Inc.
+License: GPL-2+
+Files: c/unexw32.c
+Copyright: © 1994 Free Software Foundation, Inc.
+License: GPL-2+
+
+Files: emacs/goo-font-lock.el
+Copyright: © 1992-2001 Free Software Foundation, Inc.
+License: GPL-2+
+
+Files: src/samurui/treegoo.*
+Copyright: © 2000 Red Hat, Inc., Jonathan Blandford <jrb@redhat.com>
+License: GPL-2+
+
+Files: *
+Copyright: © 2001-2004 Jonathan Bachrach.
+License: GPL-2+
+
+On Debian systems, the complete text of the GNU General Public License,
+version 2, can be found in `/usr/share/common-licenses/GPL-2'.
--- goo-0.155.orig/debian/goo.emacsen-install
+++ goo-0.155/debian/goo.emacsen-install
@@ -0,0 +1,41 @@
+#! /bin/sh -e
+# /usr/lib/emacsen-common/packages/install/goo
+
+# Written by Jim Van Zandt <jrv@vanzandt.mv.com>, borrowing heavily
+# from the install scripts for gettext by Santiago Vila
+# <sanvila@ctv.es> and octave by Dirk Eddelbuettel <edd@debian.org>.
+
+FLAVOR=$1
+PACKAGE=goo
+
+if [ ${FLAVOR} = emacs ]; then exit 0; fi
+
+echo install/${PACKAGE}: Handling install for emacsen flavor ${FLAVOR}
+
+FLAVORTEST=`echo $FLAVOR | cut -c-6`
+if [ ${FLAVORTEST} = xemacs ] ; then
+    SITEFLAG="-no-site-file"
+else
+    SITEFLAG="--no-site-file"
+fi
+FLAGS="${SITEFLAG} -q -batch -l path.el -f batch-byte-compile"
+
+ELDIR=/usr/share/emacs/site-lisp/${PACKAGE}
+ELCDIR=/usr/share/${FLAVOR}/site-lisp/${PACKAGE}
+
+install -m 755 -d ${ELCDIR}
+cd ${ELDIR}
+case "${FLAVOR}" in
+    xemacs*) FILES='goo.el goo-shell.el' ;;
+    *)       FILES=`echo *.el` ;;
+esac
+cp ${FILES} ${ELCDIR}
+cd ${ELCDIR}
+
+cat << EOF > path.el
+(setq load-path (cons "." load-path) byte-compile-warnings nil)
+EOF
+${FLAVOR} ${FLAGS} ${FILES}
+rm -f *.el path.el
+
+exit 0
--- goo-0.155.orig/debian/goo.docs
+++ goo-0.155/debian/goo.docs
@@ -0,0 +1,2 @@
+README.TXT
+doc/manual/
--- goo-0.155.orig/debian/goo.menu
+++ goo-0.155/debian/goo.menu
@@ -0,0 +1,2 @@
+?package(goo):needs="text" section="Applications/Programming" \
+  title="goo" command="/usr/bin/goo"
--- goo-0.155.orig/debian/goo.links
+++ goo-0.155/debian/goo.links
@@ -0,0 +1 @@
+usr/share/man/man1/goo.1 usr/share/man/man1/g2c.1
--- goo-0.155.orig/debian/source.lintian-overrides
+++ goo-0.155/debian/source.lintian-overrides
@@ -0,0 +1 @@
+goo source: source-contains-cvs-control-dir
