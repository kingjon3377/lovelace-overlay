From f4c1da73bf6463f17669faf73c64898b69253d08 Mon Sep 17 00:00:00 2001
From: John Lindgren <john.lindgren@aol.com>
Date: Sat, 4 Jul 2015 12:50:18 -0400
Subject: [PATCH] Port to Audacious 3.6+.

This fixes #23.
---
 imms/clients/audacious/audplugin.cc   | 148 ++++++++++++++++++----------------
 imms/clients/audacious/audplugindef.c |  35 --------
 imms/clients/audacious/rules.mk       |  20 ++---
 imms/configure.ac                     |  28 +------
 imms/vars.mk.in                       |   4 +-
 5 files changed, 86 insertions(+), 149 deletions(-)
 delete mode 100644 imms/clients/audacious/audplugindef.c

diff --git a/imms/clients/audacious/audplugin.cc b/imms/clients/audacious/audplugin.cc
index e028ddb..7c66d5f 100644
--- a/imms/clients/audacious/audplugin.cc
+++ b/imms/clients/audacious/audplugin.cc
@@ -24,56 +24,77 @@
 #include <iostream>
 #include <time.h>
 
-extern "C" {
-#include <audacious/plugin.h>
-#include <audacious/audctrl.h>
-#include <audacious/drct.h>
 #include <libaudcore/audstrings.h>
-#include <audacious/playlist.h>
-#include <audacious/misc.h>
-}
+#include <libaudcore/drct.h>
+#include <libaudcore/mainloop.h>
+#include <libaudcore/playlist.h>
+#include <libaudcore/plugin.h>
+#include <libaudcore/runtime.h>
 
 #include "immsconf.h"
-#include "cplugin.h"
 #include "immsutil.h"
 #include "clientstub.h"
 
+#define USE_XIDLE true
+
 using std::string;
-using std::cerr;
-using std::endl;
+
+class IMMSPlugin : public GeneralPlugin
+{
+public:
+    static const char about[];
+
+    static constexpr PluginInfo info = {
+        "IMMS",
+        nullptr,
+        about
+    };
+
+    constexpr IMMSPlugin() : GeneralPlugin(info, false) {}
+
+    bool init();
+    void cleanup();
+};
+
+IMMSPlugin aud_plugin_instance;
+
+const char IMMSPlugin::about[] =
+    "Intelligent Multimedia Management System\n\n"
+    "IMMS is an intelligent playlist plugin for Audacious that tracks your "
+    "listening patterns and dynamically adapts to your taste.\n\n"
+    "It is incredibly unobtrusive and easy to use as it requires no direct "
+    "user interaction.\n\n"
+    "For more information please visit:\n"
+    "http://www.luminal.org/wiki/index.php/IMMS\n\n"
+    "Written by Michael \"mag\" Grigoriev <mag@luminal.org>";
 
 // Local vars
+static QueuedFunc timer;
+
 int cur_plpos, next_plpos = -1, pl_length = -1,
     last_plpos = -1, last_song_length = -1;
 int good_length = 0, song_length = 0,
-    busy = 0, just_enqueued = 0, ending = 0;
-bool shuffle = true, select_pending = false, xidle_val = false;
+    just_enqueued = 0, ending = 0;
+bool shuffle = true, select_pending = false;
 
 string cur_path = "", last_path = "";
 
+static void do_checks(void *);
+
 // Wrapper that frees memory
 string imms_get_playlist_item(int at)
 {
-    if (at > pl_length - 1)
-        return "";
-    char* uri = 0;
-    while (!uri) uri = aud_playlist_entry_get_filename(aud_playlist_get_active (), at);
-    string result = uri;
-    if(uri) str_unref(uri);
-
-    gchar* realfn = g_filename_from_uri(result.c_str(), NULL, NULL);
-    char* decoded = g_filename_to_utf8(realfn ? realfn : result.c_str(),
-                                       -1, NULL, NULL, NULL);
-    if (decoded) result = decoded;
-    free(realfn);
-    free(decoded);
-    return result;
+    int pl = aud_playlist_get_playing();
+    String uri = aud_playlist_entry_get_filename(pl, at);
+    StringBuf fn = uri ? uri_to_filename(uri, false) : StringBuf();
+    return fn ? string(fn) : "";
 }
 
 static void player_reset_selection()
 {
-    gint playlist = aud_playlist_get_active();
-    aud_playlist_queue_delete (playlist, aud_playlist_queue_find_entry(playlist, next_plpos), 1);
+    int pl = aud_playlist_get_playing();
+    int qp = aud_playlist_queue_find_entry(pl, next_plpos);
+    aud_playlist_queue_delete(pl, qp, 1);
     next_plpos = -1;
 }
 
@@ -101,7 +122,8 @@ struct FilterOps
     static void set_next(int next)
     {
         next_plpos = next;
-        aud_playlist_queue_insert(aud_playlist_get_active (), -1, next_plpos);
+        int pl = aud_playlist_get_playing();
+        aud_playlist_queue_insert(pl, -1, next_plpos);
         select_pending = false;
         just_enqueued = 2;
     }
@@ -115,28 +137,22 @@ struct FilterOps
     }
     static int get_length()
     {
-        return aud_playlist_entry_count(aud_playlist_get_active());
+        int pl = aud_playlist_get_playing();
+        return aud_playlist_entry_count(pl);
     }
-}; 
+};
 
-void imms_setup(int use_xidle)
+bool IMMSPlugin::init()
 {
-    xidle_val = use_xidle;
-    if (imms)
-        imms->setup(use_xidle);
+    imms = new XMMSClient();
+    imms->setup(USE_XIDLE);
+    timer.start(200, do_checks, nullptr);
+    return true;
 }
 
-void imms_init()
-{
-    if (!imms)
-    {
-        imms = new XMMSClient();
-        busy = 0;
-    }
-}
-
-void imms_cleanup(void)
+void IMMSPlugin::cleanup()
 {
+    timer.stop();
     delete imms;
     imms = 0;
 }
@@ -162,10 +178,10 @@ static void do_song_change()
         next_plpos = (cur_plpos + 1) % pl_length;
 }
 
-static void check_playlist()
+static void check_playlist(int pl)
 {
     // update playlist length
-    int new_pl_length = aud_playlist_entry_count(aud_playlist_get_active());
+    int new_pl_length = aud_playlist_entry_count(pl);
     if (new_pl_length != pl_length)
     {
         pl_length = new_pl_length;
@@ -182,19 +198,20 @@ static void check_time()
                             ? ending < 10 : -(ending > 0);
 }
 
-void do_checks()
+static void do_checks(void *)
 {
-    check_playlist();
+    int pl = aud_playlist_get_playing();
+    check_playlist(pl);
 
     if (imms->check_connection())
     {
         select_pending = false;
-        imms->setup(xidle_val);
-        imms->playlist_changed(pl_length =
-                aud_playlist_entry_count(aud_playlist_get_active()));
+        imms->setup(USE_XIDLE);
+        pl_length = aud_playlist_entry_count(pl);
+        imms->playlist_changed(pl_length);
         if (aud_drct_get_playing())
         {
-            last_plpos = cur_plpos = aud_playlist_get_position(aud_playlist_get_active());
+            last_plpos = cur_plpos = aud_playlist_get_position(pl);
             last_path = cur_path = imms_get_playlist_item(cur_plpos);
             imms->start_song(cur_plpos, cur_path);
         }
@@ -204,10 +221,11 @@ void do_checks()
     if (!aud_drct_get_playing())
         return;
 
-    cur_plpos = aud_playlist_get_position(aud_playlist_get_active());
-    
+    cur_plpos = aud_playlist_get_position(pl);
+
     // check if xmms is reporting the song length correctly
-    song_length = aud_playlist_entry_get_length(aud_playlist_get_active(), cur_plpos, FALSE);
+    Tuple tu = aud_playlist_entry_get_tuple(pl, cur_plpos);
+    song_length = tu.get_int(Tuple::Length);
     if (song_length > 1000)
         good_length++;
 
@@ -223,15 +241,15 @@ void do_checks()
         if (last_path != cur_path)
         {
             do_song_change();
-            gint playlist = aud_playlist_get_active();
-            aud_playlist_queue_delete(playlist, aud_playlist_queue_find_entry(playlist, next_plpos), 1);
+            int qp = aud_playlist_queue_find_entry(pl, next_plpos);
+            aud_playlist_queue_delete(pl, qp, 1);
             return;
         }
     }
 
     check_time();
 
-    bool newshuffle = aud_get_bool(NULL, "shuffle");
+    bool newshuffle = aud_get_bool(nullptr, "shuffle");
     if (!newshuffle && shuffle)
         player_reset_selection();
     shuffle = newshuffle;
@@ -239,19 +257,9 @@ void do_checks()
     if (!shuffle)
         return;
 
-    int qlength = aud_playlist_queue_count(aud_playlist_get_active());
+    int qlength = aud_playlist_queue_count(pl);
     if (qlength > 1)
         player_reset_selection();
     else if (!qlength)
         enqueue_next();
 }
-
-void imms_poll()
-{
-    if (busy)
-        return;
-
-    ++busy;
-    do_checks();
-    --busy;
-}
diff --git a/imms/clients/audacious/audplugindef.c b/imms/clients/audacious/audplugindef.c
deleted file mode 100644
index 8c49cf8..0000000
--- a/imms/clients/audacious/audplugindef.c
+++ /dev/null
@@ -1,35 +0,0 @@
-#include <audacious/plugin.h>
-#include <audacious/audctrl.h>
-#include <audacious/drct.h>
-#include <libaudcore/audstrings.h>
-
-#include "immsconf.h"
-
-bool_t init(void);
-void about(void);
-void configure(void);
-void cleanup(void);
-
-/*
-static GeneralPlugin imms_gp =
-{
-    PACKAGE_STRING,
-    init,
-    cleanup,
-    about,
-    configure,
-    NULL,
-    NULL,
-};
-
-GeneralPlugin *gp_plugin_list[] = { &imms_gp, NULL };
-
-SIMPLE_GENERAL_PLUGIN(imms, gp_plugin_list);
-*/
-AUD_GENERAL_PLUGIN(
-        .name = PACKAGE_NAME,
-        .init = init,
-        .cleanup = cleanup,
-        .about = about,
-        .configure = configure
-)
diff --git a/imms/clients/audacious/rules.mk b/imms/clients/audacious/rules.mk
index 6bcee3b..a0a9ac1 100644
--- a/imms/clients/audacious/rules.mk
+++ b/imms/clients/audacious/rules.mk
@@ -16,22 +16,12 @@
 # along with this program; if not, write to the Free Software
 # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 #
-libaudaciousimms.so: audplugindef.o audplugin.o audaciousinterface.o clientstubbase.o libimmscore.a 
-libaudaciousimms-LIBS = $(AUDACIOUSLDFLAGS)
+libaudaciousimms.so: audplugin.o clientstubbase.o libimmscore.a
+libaudaciousimms-LIBS = $(AUDACIOUSLDFLAGS) $(GLIB2LDFLAGS)
 
-audaciousinterface-CPPFLAGS=$(AUDACIOUSCPPFLAGS)
-audplugindef-CPPFLAGS=$(AUDACIOUSCPPFLAGS)
-audplugin-CPPFLAGS=$(AUDACIOUSCPPFLAGS)
+audplugin-CPPFLAGS=$(AUDACIOUSCPPFLAGS) $(GLIB2CPPFLAGS)
 
-audaciousinterface.o: bmpinterface.c
-	$(call compile, $(CC), $<, $@, $($*-CFLAGS) $(CFLAGS) $($*-CPPFLAGS) $(CPPFLAGS))
-
-AUDACIOUSDESTDIR=""
-ifeq ($(shell id -u), 0)
-	AUDACIOUSDESTDIR=`pkg-config --variable=general_plugin_dir audacious`
-else
-	AUDACIOUSDESTDIR=${HOME}/.audacious/Plugins/General
-endif
+AUDACIOUSDESTDIR=`pkg-config --variable=plugin_dir audacious`
 
 libaudaciousimms.so_install: libaudaciousimms.so
-	${INSTALL} -D $^ $(AUDACIOUSDESTDIR)/libaudaciousimms.so
+	${INSTALL} -D $^ $(AUDACIOUSDESTDIR)/General/libaudaciousimms.so
diff --git a/imms/configure.ac b/imms/configure.ac
index 6dd24d6..34e121a 100644
--- a/imms/configure.ac
+++ b/imms/configure.ac
@@ -356,33 +356,7 @@ else
     fi
 fi
 
-PKG_CHECK_MODULES(audacious, [audacious >= 2.4 gtk+-3.0], [], [with_audacious=no])
-PKG_CHECK_MODULES(dbus_glib, [dbus-glib-1 >= 0.70], [], [with_audacious=no])
-
-LIBS="$audacious_LIBS $dbus_glib_LIBS"
-CPPFLAGS="$audacious_CFLAGS $dbus_glib_CFLAGS"
-
-AC_CHECK_HEADERS(audacious/plugin.h,, [with_audacious=no])
-
-if test "$with_audacious" != "no"; then
-    AC_LANG_PUSH(C)
-dnl    AC_CHECK_HEADERS(gtk/gtk.h,, [with_audacious=no])
-    AC_CHECK_HEADERS(audacious/drct.h,, [with_audacious=no])
-    AC_MSG_CHECKING([for aud_playlist_queue_insert in -laudcore])
-    AC_TRY_LINK([#include <audacious/drct.h>
-                 #include <audacious/plugin.h>
-                 #include <audacious/dbus.h>
-                 #include <audacious/playlist.h>
-
-                  AUD_GENERAL_PLUGIN();],
-                [aud_playlist_queue_insert(aud_playlist_get_active(),-1,0)],
-                [AC_MSG_RESULT(yes)],
-                [with_audacious="no"
-                 AC_MSG_RESULT(no)]);
-    AC_DEFINE(AUDACIOUS, 1, [Define for Audacious 2.5 support])
-    audacious_CFLAGS="$audacious_CFLAGS -DAUDACIOUS"
-    AC_LANG_POP(C)
-fi
+PKG_CHECK_MODULES(audacious, [audacious >= 3.6], [], [with_audacious=no])
 
 if test "$with_audacious" = "no"; then
     AC_MSG_ERROR([Not building audacious plugin])
diff --git a/imms/vars.mk.in b/imms/vars.mk.in
index f60eb3f..a67aa57 100644
--- a/imms/vars.mk.in
+++ b/imms/vars.mk.in
@@ -48,8 +48,8 @@ CXXFLAGS=@CXXFLAGS@ -fno-rtti
 GLIB2LDFLAGS=`pkg-config glib-2.0 --libs`
 GLIB1LDFLAGS=`pkg-config glib --libs`
 
-AUDACIOUSCPPFLAGS=@audacious_CFLAGS@ @dbus_glib_CFLAGS@ -I../clients/xmms/
-AUDACIOUSLDFLAGS=@audacious_LIBS@ @dbus_glib_LIBS@
+AUDACIOUSCPPFLAGS=@audacious_CFLAGS@ -std=c++11
+AUDACIOUSLDFLAGS=@audacious_LIBS@
 
 LDFLAGS=-L. @LIBS@ @LDFLAGS@
 
