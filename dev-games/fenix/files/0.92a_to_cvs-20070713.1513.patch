# Copyright (C) 2007  Miriam Ruiz <little_miry@yahoo.es>
# Licensed under the GPL, see /usr/share/common-licenses/GPL

Index: common/files.c
===================================================================
--- common/files.c	2007-08-28 14:40:08.000000000 +0200
+++ common/files.c	2007-08-28 14:41:08.000000000 +0200
@@ -120,7 +120,7 @@
 
 /* Guarda una cadena "cuoteada" al disco */
 
-int file_puts (file * fp, const char * buffer)
+int file_qputs (file * fp, const char * buffer)
 {
 	char dest[1024], * optr ;
 	const char * ptr ;
@@ -158,7 +158,7 @@
 
 /* Recupera una cadena de un fichero y la "descuotea" */
 
-int file_gets (file * fp, char * buffer, int len)
+int file_qgets (file * fp, char * buffer, int len)
 {
 	char * ptr, * result = NULL ;
 
@@ -221,6 +221,63 @@
 	return strlen(buffer) ;
 }
 
+/* Guarda una cadena al disco */
+
+int file_puts (file * fp, const char * buffer)
+{
+	return file_write (fp, buffer, strlen(buffer)) ;
+}
+
+/* Recupera una cadena de un fichero y la "descuotea" */
+
+int file_gets (file * fp, char * buffer, int len)
+{
+	char * ptr, * result = NULL ;
+
+	if (fp->type == F_XFILE)
+	{
+		XFILE * xf ;
+		int l = 0;
+		char * ptr = result = buffer ;
+
+		xf = &x_file[fp->n] ;
+
+		fseek (xf->fp, fp->pos, SEEK_SET) ;
+		while (l < len)
+		{
+			if (fp->pos >= xf->offset + xf->size)
+			{
+				fp->eof = 1 ;
+				break ;
+			}
+			fread (ptr, 1, 1, xf->fp) ;
+			l++ ;
+			fp->pos++ ;
+			if (*ptr++ == '\n') break ;
+		}
+		*ptr = 0 ;
+		fp->pos = ftell(xf->fp) ;
+
+	    if (l == 0) return 0 ;
+
+	}
+	else if (fp->type == F_GZFILE)
+	{
+		result = gzgets (fp->gz, buffer, len) ;
+	}
+	else
+	{
+		result = fgets(buffer, len, fp->fp);
+	}
+
+	if (result == NULL) {
+	    buffer[0] = 0 ;
+	    return 0 ;
+	}
+
+	return strlen(buffer) ;
+}
+
 /* Escribe en un fichero binario un dato de tipo entero */
 
 int file_writeSint8 (file * fp, Sint8 * buffer)
Index: configure
===================================================================
--- configure	2007-08-28 14:39:47.000000000 +0200
+++ configure	2007-08-28 14:41:08.000000000 +0200
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.56 for fenix 0.92a.
+# Generated by GNU Autoconf 2.56 for fenix 0.93.
 #
 # Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
 # Free Software Foundation, Inc.
@@ -266,8 +266,8 @@
 # Identity of this package.
 PACKAGE_NAME='fenix'
 PACKAGE_TARNAME='fenix'
-PACKAGE_VERSION='0.92a'
-PACKAGE_STRING='fenix 0.92a'
+PACKAGE_VERSION='0.93'
+PACKAGE_STRING='fenix 0.93'
 PACKAGE_BUGREPORT=''
 
 # Factoring default headers for most tests.
@@ -776,7 +776,7 @@
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures fenix 0.92a to adapt to many kinds of systems.
+\`configure' configures fenix 0.93 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -843,7 +843,7 @@
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of fenix 0.92a:";;
+     short | recursive ) echo "Configuration of fenix 0.93:";;
    esac
   cat <<\_ACEOF
 
@@ -942,7 +942,7 @@
 test -n "$ac_init_help" && exit 0
 if $ac_init_version; then
   cat <<\_ACEOF
-fenix configure 0.92a
+fenix configure 0.93
 generated by GNU Autoconf 2.56
 
 Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
@@ -957,7 +957,7 @@
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by fenix $as_me 0.92a, which was
+It was created by fenix $as_me 0.93, which was
 generated by GNU Autoconf 2.56.  Invocation command line was
 
   $ $0 $@
@@ -1881,7 +1881,7 @@
 
 # Define the identity of the package.
  PACKAGE=fenix
- VERSION=0.92a
+ VERSION=0.93
 
 
 cat >>confdefs.h <<_ACEOF
@@ -4975,7 +4975,7 @@
 } >&5
 cat >&5 <<_CSEOF
 
-This file was extended by fenix $as_me 0.92a, which was
+This file was extended by fenix $as_me 0.93, which was
 generated by GNU Autoconf 2.56.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -5033,7 +5033,7 @@
 
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
-fenix config.status 0.92a
+fenix config.status 0.93
 configured by $0, generated by GNU Autoconf 2.56,
   with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
 
Index: configure.in
===================================================================
--- configure.in	2007-08-28 14:39:48.000000000 +0200
+++ configure.in	2007-08-28 14:41:08.000000000 +0200
@@ -1,4 +1,4 @@
-AC_INIT(fenix,0.92a)
+AC_INIT(fenix,0.93)
 
 AC_CANONICAL_SYSTEM
 AC_ARG_PROGRAM
Index: fxc/src/c_code.c
===================================================================
--- fxc/src/c_code.c	2007-08-28 14:38:23.000000000 +0200
+++ fxc/src/c_code.c	2007-08-28 14:41:09.000000000 +0200
@@ -58,7 +58,7 @@
 {
     if (typedef_is_pointer(exp->type))
     {
-        codeblock_add (code, MN_POINTER2BOL, 0) ;
+//        codeblock_add (code, MN_POINTER2BOL, 0) ;
         exp->type = typedef_new(TYPE_DWORD) ;
     }
 
@@ -79,13 +79,13 @@
 {
     if (typedef_is_pointer(left->type))
     {
-        codeblock_add (code, MN_POINTER2BOL, 1) ;
+//        codeblock_add (code, MN_POINTER2BOL, 1) ;
         left->type = typedef_new(TYPE_DWORD) ;
     }
 
     if (typedef_is_pointer(right->type))
     {
-        codeblock_add (code, MN_POINTER2BOL, 0) ;
+//        codeblock_add (code, MN_POINTER2BOL, 0) ;
         right->type = typedef_new(TYPE_DWORD) ;
     }
 
@@ -402,8 +402,8 @@
 {
     VARIABLE           * var = NULL ;
     VARSPACE           * here = from ;
-    VARSPACE           * privars = proc ? proc->privars : 0 ;
-    VARSPACE           * pubvars = proc ? proc->pubvars : 0 ;
+    VARSPACE           * privars = (proc ? proc->privars : NULL) ;
+    VARSPACE           * pubvars = (proc ? proc->pubvars : NULL) ;
     expresion_result    res, ind ;
 
     if (here) token_next() ;
@@ -710,12 +710,14 @@
                     else
                         strdelchars (validtypes, "P") ;
                     break ;
+                case TYPE_POINTER:
+                    strdelchars (validtypes, "SFIWB") ;
+                    break ;
                 default:
                     break ;
             }
 
-            if (strlen(validtypes) != 1)
-                compile_error (MSG_INVALID_PARAMT) ;
+            if (strlen(validtypes) != 1) compile_error (MSG_INVALID_PARAMT) ;
 
             /* Eliminate all functions that are not selected */
 
@@ -764,11 +766,10 @@
         }
     }
 
-    if (proc_count > 1)
-        compile_error (MSG_MULTIPLE_PROCS_FOUND, proc_name);
-    if (proc_count == 0)
-        compile_error (MSG_INCORRECT_PARAMC, proc_name, min_params) ;
+    if (proc_count > 1) compile_error (MSG_MULTIPLE_PROCS_FOUND, proc_name);
+    if (proc_count == 0) compile_error (MSG_INCORRECT_PARAMC, proc_name, min_params) ;
     codeblock_add (code, MN_SYSCALL, procs[0]->code) ;
+
     return procs[0] ;
 }
 
@@ -1433,7 +1434,7 @@
     {
         part = compile_factor() ;
         if (part.lvalue) codeblock_add (code, mntype(part.type, 0) | MN_PTR, 0) ;
-        codeblock_add (code, mntype(part.type, 0) | MN_NEG, 0) ;
+        codeblock_add (code, (mntype(part.type, 0) == MN_FLOAT ? MN_FLOAT : 0) | MN_NEG, 0) ;
         res.type = part.type ;
         if (typedef_is_integer(part.type) ||
             typedef_base(part.type) == TYPE_FLOAT)
@@ -1448,13 +1449,13 @@
     else if (token.type == IDENTIFIER && token.code == identifier_not) /* "NOT" or "!" */
     {
         part = compile_factor() ;
-        if (part.lvalue) codeblock_add (code, mntype(part.type, 0) | MN_PTR, 0) ;
+        if (part.lvalue) codeblock_add (code, (mntype(part.type, 0) == MN_FLOAT ? MN_FLOAT : 0) | MN_PTR, 0) ;
         if (typedef_is_pointer(part.type))
         {
-            codeblock_add (code, mntype(part.type, 0) | MN_POINTER2BOL, 0) ;
+//            codeblock_add (code, mntype(part.type, 0) | MN_POINTER2BOL, 0) ;
             part.type = typedef_new(TYPE_DWORD) ;
         }
-        codeblock_add (code, mntype(part.type, 0) | MN_NOT, 0) ;
+        codeblock_add (code, (mntype(part.type, 0) == MN_FLOAT ? MN_FLOAT : 0) | MN_NOT, 0) ;
         if (typedef_is_integer(part.type) ||
             typedef_is_pointer(part.type) ||
             typedef_base(part.type) == TYPE_FLOAT)
@@ -1471,13 +1472,13 @@
     else if (token.type == IDENTIFIER && token.code == identifier_bnot) /* "BNOT" or "~" */
     {
         part = compile_factor() ;
-        if (part.lvalue) codeblock_add (code, mntype(part.type, 0) | MN_PTR, 0) ;
+        if (part.lvalue) codeblock_add (code, (mntype(part.type, 0) == MN_FLOAT ? MN_FLOAT : 0) | MN_PTR, 0) ;
         if (typedef_is_pointer(part.type))
         {
-            codeblock_add (code, mntype(part.type, 0) | MN_POINTER2BOL, 0) ;
+//            codeblock_add (code, mntype(part.type, 0) | MN_POINTER2BOL, 0) ;
             part.type = typedef_new(TYPE_DWORD) ;
         }
-        codeblock_add (code, mntype(part.type, 0) | MN_BNOT, 0) ;
+        codeblock_add (code, (mntype(part.type, 0) == MN_FLOAT ? MN_FLOAT : 0) | MN_BNOT, 0) ;
         if (typedef_is_integer(part.type))
         {
             res.constant = part.constant ;
@@ -1997,6 +1998,7 @@
 {
     expresion_result left = compile_comparison (), right, res ;
     int et1;
+    int et2;
 
     token_next() ;
     if (token.type == IDENTIFIER && token.code == identifier_and) /* "AND" or "&&" */
@@ -2031,17 +2033,24 @@
     if (token.type == IDENTIFIER && token.code == identifier_or) /* "OR" or "||" */
     {
         et1 = codeblock_label_add(code);
+        et2 = codeblock_label_add(code);
 
         if (left.lvalue) codeblock_add (code, MN_PTR, 0) ;
         check_integer_type (&left) ;
-        codeblock_add (code, MN_JTTRUE, et1) ;
+        codeblock_add (code, MN_JTFALSE, et1) ;
+
+        codeblock_add (code, MN_POP, 0);
+        codeblock_add (code, MN_PUSH, 1);
+        codeblock_add (code, MN_JUMP, et2);
+
+        codeblock_label_set (code, et1, code->current) ;
         right = compile_compseq() ;
         if (right.lvalue) codeblock_add (code, MN_PTR, 0) ;
         check_integer_type (&right) ;
 
         codeblock_add (code, MN_OR, 0) ;
 
-        codeblock_label_set (code, et1, code->current) ;
+        codeblock_label_set (code, et2, code->current) ;
 /*
         if (left.lvalue) codeblock_add (code, MN_PTR, 0) ;
         right = compile_compseq() ;
@@ -2568,7 +2577,7 @@
     }
     if (typedef_base(res.type) == TYPE_POINTER && t < 8)
     {
-        codeblock_add (code, MN_POINTER2BOL, 0) ;
+/*        codeblock_add (code, MN_POINTER2BOL, 0) ; */
         res.type = typedef_new(t) ; /* Pointer 2 Int */
     }
     if (typedef_base(res.type) == TYPE_FLOAT && t < 8)
@@ -3045,7 +3054,8 @@
                 }
                 if (token.type != IDENTIFIER || token.code != identifier_semicolon) /* ";" */
                     compile_error (MSG_EXPECTED, ";") ;
-                codeblock_loop_start (code, loop, code->current) ;
+
+                codeblock_label_set (code, et1, code->current) ;
 
                 if (dcb_options & DCB_DEBUG) {
                     codeblock_add (code, MN_SENTENCE, forline) ;
@@ -3069,7 +3079,7 @@
                 codeblock_add (code, MN_JUMP, et2) ;
 
                 /* Incrementos */
-                codeblock_label_set (code, et1, code->current) ;
+                codeblock_loop_start (code, loop, code->current) ;
 
                 if (dcb_options & DCB_DEBUG) {
                     codeblock_add (code, MN_SENTENCE, forline) ;
@@ -3089,7 +3099,8 @@
                 }
                 if (token.type != IDENTIFIER || token.code != identifier_rightp)    /* ")" */
                     compile_error (MSG_EXPECTED, ")") ;
-                codeblock_add (code, MN_REPEAT, loop) ;
+
+                codeblock_add (code, MN_JUMP, et1) ;
 
                 /* Bloque */
                 codeblock_label_set (code, et2, code->current) ;
@@ -3099,7 +3110,7 @@
                 compile_block(p) ;
                 code->loop_active = last_loop ;
 
-                codeblock_add (code, MN_JUMP, et1) ;
+                codeblock_add (code, MN_REPEAT, loop) ;
                 codeblock_loop_end (code, loop, code->current) ;
                 continue ;
             }
@@ -3240,6 +3251,8 @@
                 CODEBLOCK_POS var_pos;
                 CODEBLOCK_POS var_end;
 
+                et1 = codeblock_label_add (code) ;
+
                 // Compile the variable access
 
                 loop = codeblock_loop_add(code) ;
@@ -3249,10 +3262,8 @@
                 var_pos = codeblock_pos(code);
                 res = compile_value () ;
                 var_end = codeblock_pos(code);
-                if (!res.lvalue)
-                    compile_error (MSG_VARIABLE_REQUIRED) ;
-                if (!typedef_is_integer(res.type))
-                    compile_error (MSG_INTEGER_REQUIRED);
+                if (!res.lvalue) compile_error (MSG_VARIABLE_REQUIRED) ;
+                if (!typedef_is_integer(res.type)) compile_error (MSG_INTEGER_REQUIRED);
 
                 // Compile the assignation of first value
 
@@ -3264,7 +3275,8 @@
 
                 // Compile the loop termination check
 
-                codeblock_loop_start (code, loop, code->current) ;
+                codeblock_label_set (code, et1, code->current) ;
+
                 codeblock_add_block (code, var_pos, var_end);
                 codeblock_add (code, MN_PTR | mntype(res.type, 0), 0);
                 token_next() ;
@@ -3277,10 +3289,8 @@
                 {
                     CODEBLOCK_POS p = codeblock_pos(code);
                     expresion_result r = compile_expresion(1, 0, typedef_base(res.type)) ;
-                    if (!r.constant)
-                        compile_error (MSG_CONSTANT_EXP);
-                    if (!typedef_is_integer(r.type))
-                        compile_error (MSG_INTEGER_REQUIRED);
+                    if (!r.constant) compile_error (MSG_CONSTANT_EXP);
+                    if (!typedef_is_integer(r.type)) compile_error (MSG_INTEGER_REQUIRED);
                     inc = r.value;
 
                     codeblock_setpos(code, p);
@@ -3288,8 +3298,7 @@
                         codeblock_add (code, MN_LTE, 0) ;
                     else
                     {
-                        if (inc == 0)
-                            compile_error (MSG_INVALID_STEP) ;
+                        if (inc == 0) compile_error (MSG_INVALID_STEP) ;
                         codeblock_add (code, MN_GTE, 0) ;
                     }
                 }
@@ -3318,6 +3327,8 @@
 
                 // Compile the increment and looping code
 
+                codeblock_loop_start (code, loop, code->current) ;
+
                 codeblock_add_block (code, var_pos, var_end);
                 if (inc == 1)
                     codeblock_add (code, MN_INC | mntype(res.type, 0), 1) ;
@@ -3329,7 +3340,8 @@
                     codeblock_add (code, MN_VARADD | mntype(res.type, 0), 0) ;
                 }
                 codeblock_add (code, MN_POP, 0) ;
-                codeblock_add (code, MN_REPEAT, loop) ;
+                codeblock_add (code, MN_JUMP, et1) ;
+
                 codeblock_loop_end (code, loop, code->current) ;
                 continue ;
             }
@@ -3338,8 +3350,18 @@
 
             if (token.code == identifier_repeat) /* "REPEAT" */
             {
+                et1 = codeblock_label_add (code) ;
+                et2 = codeblock_label_add (code) ;
+
                 loop = codeblock_loop_add (code) ;
+
+                codeblock_add (code, MN_JUMP, et1) ;
+
                 codeblock_loop_start (code, loop, code->current) ;
+
+                codeblock_add (code, MN_JUMP, et2) ;
+                codeblock_label_set (code, et1, code->current) ;
+
                 if (dcb_options & DCB_DEBUG) {
                     codeblock_add (code, MN_SENTENCE, line_count + (current_file << 24)) ;
                 }
@@ -3348,6 +3370,9 @@
                 code->loop_active = loop ;
                 compile_block(p) ;
                 code->loop_active = last_loop ;
+
+                codeblock_label_set (code, et2, code->current) ;
+
                 if (dcb_options & DCB_DEBUG) {
                     codeblock_add (code, MN_SENTENCE, line_count + (current_file << 24)) ;
                 }
@@ -3370,7 +3395,7 @@
                     if (token.type != IDENTIFIER || token.code != identifier_semicolon) /* ";" */
                         compile_error (MSG_EXPECTED, ";") ;
                 }
-                codeblock_add (code, MN_REFALSE, loop) ;
+                codeblock_add (code, MN_JFALSE, et1) ;
                 codeblock_loop_end (code, loop, code->current) ;
                 continue ;
             }
Index: fxc/src/c_debug.c
===================================================================
--- fxc/src/c_debug.c	2007-08-28 14:38:23.000000000 +0200
+++ fxc/src/c_debug.c	2007-08-28 14:41:09.000000000 +0200
@@ -144,7 +144,7 @@
 	{ "STR2FLOAT", MN_STR2FLOAT, 1 },
 	{ "FLOAT2STR", MN_FLOAT2STR, 1 },
 	{ "POINTER2STR", MN_POINTER2STR, 1 },
-	{ "POINTER2BOL", MN_POINTER2BOL, 1 },
+//	{ "POINTER2BOL", MN_POINTER2BOL, 1 },
 
 	{ "A2STR", MN_A2STR, 0 },
 	{ "STR2A", MN_STR2A, 0 },
Index: fxc/src/c_main.c
===================================================================
--- fxc/src/c_main.c	2007-08-28 14:41:03.000000000 +0200
+++ fxc/src/c_main.c	2007-08-28 14:41:09.000000000 +0200
@@ -621,35 +621,35 @@
     }
 
     if (tcode == identifier_word){
-        if (is_declare && proc->declared && proc->type != signed_prefix ? TYPE_SHORT : TYPE_WORD)
+        if (is_declare && proc->declared && proc->type != (signed_prefix ? TYPE_SHORT : TYPE_WORD))
             compile_error (MSG_PROTO_ERROR) ;
         proc->type = signed_prefix ? TYPE_SHORT : TYPE_WORD;
         signed_prefix = unsigned_prefix = 0;
     }
 
     if (tcode == identifier_dword){
-        if (is_declare && proc->declared && proc->type != signed_prefix ? TYPE_INT : TYPE_DWORD)
+        if (is_declare && proc->declared && proc->type != (signed_prefix ? TYPE_INT : TYPE_DWORD))
             compile_error (MSG_PROTO_ERROR) ;
         proc->type = signed_prefix ? TYPE_INT : TYPE_DWORD;
         signed_prefix = unsigned_prefix = 0;
     }
 
     if (tcode == identifier_byte){
-        if (is_declare && proc->declared && proc->type != signed_prefix ? TYPE_SBYTE : TYPE_BYTE)
+        if (is_declare && proc->declared && proc->type != (signed_prefix ? TYPE_SBYTE : TYPE_BYTE))
             compile_error (MSG_PROTO_ERROR) ;
         proc->type = signed_prefix ? TYPE_SBYTE : TYPE_BYTE;
         signed_prefix = unsigned_prefix = 0;
     }
 
     if (tcode == identifier_int){
-        if (is_declare && proc->declared && proc->type != unsigned_prefix ? TYPE_DWORD : TYPE_INT)
+        if (is_declare && proc->declared && proc->type != (unsigned_prefix ? TYPE_DWORD : TYPE_INT))
             compile_error (MSG_PROTO_ERROR) ;
         proc->type = unsigned_prefix ? TYPE_DWORD : TYPE_INT;
         signed_prefix = unsigned_prefix = 0;
     }
 
     if (tcode == identifier_short){
-        if (is_declare && proc->declared && proc->type != unsigned_prefix ? TYPE_WORD : TYPE_SHORT)
+        if (is_declare && proc->declared && proc->type != (unsigned_prefix ? TYPE_WORD : TYPE_SHORT))
             compile_error (MSG_PROTO_ERROR) ;
         proc->type = unsigned_prefix ? TYPE_WORD : TYPE_SHORT;
         signed_prefix = unsigned_prefix = 0;
@@ -920,11 +920,10 @@
        los datos declarados aquí tienen el mismo efecto que si son
        declarados externamente y afectarán a todos los procesos (Ya no va mas esto, ahora los datos locales son locales, Splinter) */
 
-    if (!proc->declared) {
         while ( token.type == IDENTIFIER && ( token.code == identifier_local  ||
                                               token.code == identifier_public ||
                                               token.code == identifier_private ) ) {
-            if ( token.code == identifier_local || token.code == identifier_public )
+        if ((!proc->declared) && (token.code == identifier_local || token.code == identifier_public))
             {
                 /* (2006/11/19 19:34 GMT-03:00, Splinter - jj_arg@yahoo.com) */
                 /* Ahora las declaraciones locales, son solo locales al proceso, pero visibles desde todo proceso */
@@ -940,7 +939,6 @@
 
             token_next () ;
         }
-    }
 
     /* Gestiona procesos cuyos parámetros son variables locales */
 
Index: fxc/src/dcbw.c
===================================================================
--- fxc/src/dcbw.c	2007-08-28 14:39:51.000000000 +0200
+++ fxc/src/dcbw.c	2007-08-28 14:41:09.000000000 +0200
@@ -74,11 +74,9 @@
         if (!fp) return ;
         while (!file_eof(fp))
         {
-            file_gets (fp, buffer, sizeof(buffer)) ;
-            if (strchr(buffer, '\n'))
-                *strchr(buffer,'\n') = 0 ;
-            if (buffer[0] == '#' || !buffer[0])
-                continue ;
+            file_qgets (fp, buffer, sizeof(buffer)) ;
+            if (strchr(buffer, '\n')) *strchr(buffer,'\n') = 0 ;
+            if (buffer[0] == '#' || !buffer[0]) continue ;
             dcb_add_file(buffer) ;
         }
         file_close(fp) ;
Index: fxc/src/error.c
===================================================================
--- fxc/src/error.c	2007-08-28 14:38:23.000000000 +0200
+++ fxc/src/error.c	2007-08-28 14:41:09.000000000 +0200
@@ -54,6 +54,7 @@
 	int	   size ;
 	char * msg = NULL ;
 	struct _errmsg * err = NULL ;
+	int len;
 
 	/* open the desired localized error file, check for existence if not open EN default */
 	strcpy(fname,"msg/") ;
@@ -65,7 +66,7 @@
 	fp = file_open(fname,"r") ;
 
 	if (fp) {
-		while (file_gets (fp,line,1024)) {
+		while (len = file_qgets (fp,line,1024)) {
 			// Check for multiline...
 			if (line[0]=='_') {
 				// must resize the string and concatenate
Index: fxc/src/main_div.c
===================================================================
--- fxc/src/main_div.c	2007-08-28 14:38:23.000000000 +0200
+++ fxc/src/main_div.c	2007-08-28 14:41:10.000000000 +0200
@@ -183,6 +183,7 @@
 "   y ; \n"
 "   z ; \n"
 "   graph ; \n"
+"   palette = -1 ; \n"
 "   flags ; \n"
 "   size = 100 ; \n"
 "   angle ; \n"
@@ -194,11 +195,12 @@
 "   alpha = 255 ; \n"
 "   size_x = 100 ; \n"
 "   size_y = 100 ; \n"
-"   blendop ; \n"
+"   blendop = 0; \n"
 "   STRUCT _saved_ \n"
 "       x ; \n"
 "       y ; \n"
 "       graph ; \n"
+"       palette ; \n"
 "       angle ; \n"
 "       alpha ; \n"
 "       blendop ; \n"
Index: fxc/src/sysstub.c
===================================================================
--- fxc/src/sysstub.c	2007-08-28 14:38:24.000000000 +0200
+++ fxc/src/sysstub.c	2007-08-28 14:41:10.000000000 +0200
@@ -76,8 +76,7 @@
 	last[1].next = NULL ;
 	last++ ;
 	sysproc_count++ ;
-	if (sysproc_count == MAX_SYSPROCS)
-		compile_error (MSG_TOO_MANY_SYSPROCS) ;
+	if (sysproc_count == MAX_SYSPROCS) compile_error (MSG_TOO_MANY_SYSPROCS) ;
 
 	/* If the fast-access list is already filled, free it to fill it again
 	 * in sysproc_get. We should add the new process to the list, but this
@@ -123,10 +122,8 @@
 
 		for (s = sysprocs ; s->name ; s++)
 		{
-			if (s->id == 0) 
-				s->id = identifier_search_or_add(s->name) ;
-			if (s->id > sysproc_maxid)
-				sysproc_maxid = s->id;
+			if (s->id == 0) s->id = identifier_search_or_add(s->name) ;
+			if (s->id > sysproc_maxid) sysproc_maxid = s->id;
 
 			s->next = NULL;
 		}
@@ -135,8 +132,7 @@
 
 		sysproc_maxid = ((sysproc_maxid+1) & ~31) + 32;
 		sysproc_list  = (SYSPROC * *) calloc (sysproc_maxid, sizeof(SYSPROC*));
-		if (sysproc_list == NULL)
-			abort();
+		if (sysproc_list == NULL) abort();
 
 		/* Fill it */
 
@@ -176,8 +172,7 @@
 	SYSPROC * * table;
 	int found = 0 ;
 
-	if (s == NULL)
-		return NULL;
+	if (s == NULL) return NULL;
 
 	table = malloc(sizeof(SYSPROC *) * 32) ;
 	do
Index: fxi/inc/fmath.h
===================================================================
--- fxi/inc/fmath.h	2007-08-28 14:38:24.000000000 +0200
+++ fxi/inc/fmath.h	2007-08-28 14:41:10.000000000 +0200
@@ -24,15 +24,23 @@
  *
  */
 
+#ifndef _FMATH_H
+    #define _FMATH_H
+
 /* Rutinas matemáticas de punto fijo, basadas en Allegro */
 
 #ifndef M_PI
 #define M_PI           3.14159265358979323846  /* pi */
 #endif
 
+    #ifndef ABS
+    #define ABS(x) (((x) < 0) ? -(x):(x))
+    #endif
 #ifndef MAX
-#define MAX(a,b)        ((a)>(b) ? (a):(b))
-#define MIN(a,b)        ((a)<(b) ? (a):(b))
+    #define MAX(a, b)  (((a) > (b)) ? (a) : (b))
+    #endif
+    #ifndef MIN
+    #define MIN(a, b)  (((a) < (b)) ? (a) : (b))
 #endif
 
 typedef long int fixed ;
@@ -122,3 +130,5 @@
 {
 	return ftofix (fixtof(x) / fixtof(y)) ;
 }
+
+#endif
Index: fxi/inc/fxi.h
===================================================================
--- fxi/inc/fxi.h	2007-08-28 14:38:24.000000000 +0200
+++ fxi/inc/fxi.h	2007-08-28 14:41:10.000000000 +0200
@@ -55,6 +55,8 @@
 #include "files.h"
 #include "xctype.h"
 
+#include "fmath.h"
+
 /*
  *  CONSTANTS
  */
Index: fxi/inc/grlib.h
===================================================================
--- fxi/inc/grlib.h	2007-08-28 14:38:24.000000000 +0200
+++ fxi/inc/grlib.h	2007-08-28 14:41:10.000000000 +0200
@@ -42,6 +42,8 @@
 extern int				enable_16bits ;      /* 1 = 16bpp MODE on                */
 extern int				enable_filtering ;   /* 1 = 16bpp filter MODE on         */
 
+extern DRAWING_OBJECT * drawing_objects ;
+
 extern Uint16			syscolor16 ;
 extern int				syscolor8 ;			 /* Color for drawing primitives	 */
 extern Uint16           fntcolor16 ;
@@ -132,9 +134,19 @@
 extern int          palette_loaded ;        /* ¿Se ha cargado ya la paleta inicial ? */
 extern int          palette_changed ;       /* Poner a 1 cuando se cambien colores   */
 extern int          fade_on ;               /* ¿Hay un fade activo?                  */
+extern int          fade_set ;              /* ¿Hay un fade seteado pero inactivo?   */
 extern int          fade_step ;             /* Si lo hay, posición (0=off)           */
 
-extern int          gr_read_pal           (file * file) ;
+
+extern PALETTE * pal_new(PALETTE * basepal);
+extern PALETTE * pal_new2(unsigned char * datapal);
+
+extern void pal_destroy(PALETTE * pal);
+extern void pal_refresh(PALETTE * pal);
+
+extern PALETTE    * gr_read_pal             (file * fp) ;
+extern PALETTE    * gr_read_pal_with_gamma  (file * fp);
+
 extern void         gr_refresh_palette    () ;
 extern void         gr_fade_init          (int pr, int pg, int pb, int speed) ;
 extern void         gr_fade_step          () ;
@@ -204,6 +216,7 @@
 extern GRAPH * bitmap_new_syslib (int w, int h, int depth, int frames) ;
 extern GRAPH * bitmap_get        (int libid, int mapcode) ;
 extern void    bitmap_destroy    (GRAPH * map) ;
+extern void    bitmap_destroy_fake (GRAPH * map) ;
 extern void    bitmap_add_cpoint (GRAPH *map, int x, int y) ;
 extern void    bitmap_set_cpoint (GRAPH * map, Uint32 point, int x, int y);
 extern void    bitmap_analize    (GRAPH * bitmap) ;
@@ -310,6 +323,9 @@
 extern void gr_drawing_destroy (int id) ;
 extern void gr_drawing_move    (int id, int x, int y) ;
 
+extern void draw_object (DRAWING_OBJECT * dr, REGION * clip) ;
+extern int info_object (DRAWING_OBJECT * dr, REGION * clip) ;
+
 /* Bitmaps */
 
 extern void gr_blit          (GRAPH * dest, REGION * clip, int x, int y, int flags, GRAPH * gr) ;
Index: fxi/inc/grlib_st.h
===================================================================
--- fxi/inc/grlib_st.h	2007-08-28 14:38:24.000000000 +0200
+++ fxi/inc/grlib_st.h	2007-08-28 14:41:11.000000000 +0200
@@ -95,6 +95,16 @@
 }
 CPOINT ;
 
+typedef struct _palette
+{
+    SDL_Color       rgb[256] ;
+    Uint16          colorequiv[256] ;
+    int             use;
+    struct _palette * next ;
+    struct _palette * prev ;
+}
+PALETTE ;
+
 typedef struct _bitmap
 {
     void      * data ;				/* Pointer to the bitmap data at current frame */
@@ -112,6 +122,8 @@
     Uint32      ncpoints;			/* Number of control points */
     Uint32      offset ;			/* Offset of the graphic (in the FPG file) */
 
+    PALETTE   * palette ;           /* Palette for 8 bits graphics */
+
     Sint16    * blend_table ;		/* Pointer to 16 bits blend table if any */
 
     int         modified ;			/* 1 if bitmap needs analysis */
Index: fxi/inc/instance_st.h
===================================================================
--- fxi/inc/instance_st.h	2007-08-28 14:38:24.000000000 +0200
+++ fxi/inc/instance_st.h	2007-08-28 14:41:11.000000000 +0200
@@ -27,6 +27,10 @@
 #ifndef __INSTANCE_ST_H
 #define __INSTANCE_ST_H
 
+//#ifndef __I_PROCDEF_H
+//#include "i_procdef.h"
+//#endif
+
 #define STACK_NO_RETURN_VALUE	0x8000
 #define STACK_SIZE_MASK			0x7FFF
 
@@ -67,7 +71,6 @@
 
 	/* Function support */
 
-/*	struct _instance * waiting_for ; */
 	struct _instance * called_by ;
 
 	/* The first integer at the stack is the stack size,
@@ -80,15 +83,15 @@
 	struct _procdef  * inproc ;
 	void             * inpridata ;
 
+    int switchval;
+    int switchval_string;
+    int cased;
+
 	int               breakpoint;
 
 }
 INSTANCE ;
 
-//#ifndef __I_PROCDEF_H
-//#include "i_procdef.h"
-//#endif
-
 /* Macros para acceder a datos locales o privados de una instancia */
 #define LOCDWORD(a,b) ( *(Sint32 *) ((Uint8 *)(a->locdata)+b) )
 #define LOCWORD(a,b)  ( *(Uint16 *) ((Uint8 *)(a->locdata)+b) )
Index: fxi/src/Be_compat/be_compat.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ fxi/src/Be_compat/be_compat.cpp	2007-08-28 14:41:11.000000000 +0200
@@ -0,0 +1,29 @@
+/*-------------------------------------------------------------------------------------------------------
+Copyright (c) 2003 Joseba GarcÃ­a Etxebarria, under the GPL, as described
+on copying in the (Fenix)/COPYING file.
+This file provides a thin BeOS->C compatibility layer, as the BeOS kits are
+designed for C++.
+Now alert dialogs are created using the system call, but this may change as to
+be able to use it in fullscreen modes (writting my own implementation of the
+dialog using BDirectWindow)
+We don't need to create a BApplication objet, SDL does that for us.
+-------------------------------------------------------------------------------------------------------*/
+#include <sys/types.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <be/interface/Alert.h>
+
+extern "C" __declspec(dllexport) void be_alert(const char *error) {
+	char *error_msg;
+	int len;
+	error_msg = strdup(error);
+
+	for (len = strlen(error_msg); len && (error_msg[len-1] == '\n'); --len)
+		error_msg[len-1] = 0;
+
+	BAlert * alert_p = new BAlert("FXI Error", error_msg, "OK", NULL, NULL, B_WIDTH_AS_USUAL, B_STOP_ALERT);
+	alert_p -> Go();
+	free (error_msg);
+}
Index: fxi/src/Be_compat/be_compat.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ fxi/src/Be_compat/be_compat.h	2007-08-28 14:41:11.000000000 +0200
@@ -0,0 +1,5 @@
+#ifndef _BE_COMPAT_H
+#define _BE_COMPAT_H
+
+void be_alert (const char *error);
+#endif
Index: fxi/src/Be_compat/libbe_compat.proj
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ fxi/src/Be_compat/libbe_compat.proj	2007-08-28 14:41:11.000000000 +0200
@@ -0,0 +1 @@
+MIDE
\ No newline at end of file
Index: fxi/src/dcbr.c
===================================================================
--- fxi/src/dcbr.c	2007-08-28 14:40:57.000000000 +0200
+++ fxi/src/dcbr.c	2007-08-28 14:41:11.000000000 +0200
@@ -124,7 +124,7 @@
 
     while (!file_eof(fp))
     {
-        file_gets (fp, line, 2048) ;
+        file_qgets (fp, line, 2048) ;
         trim(line);
         if (allocated == count)
         {
Index: fxi/src/fbm.c
===================================================================
--- fxi/src/fbm.c	2007-08-28 14:39:54.000000000 +0200
+++ fxi/src/fbm.c	2007-08-28 14:41:11.000000000 +0200
@@ -87,6 +87,46 @@
 	}
 }
 
+
+
+
+
+
+
+
+int fbm_insert_frame(gr, frame, where)
+{
+}
+
+int fbm_remove_frame(gr, frame)
+{
+}
+
+int fbm_insert_keyframe(gr, keyframe, where)
+{
+}
+
+int fbm_remove_keyframe(gr, keyframe)
+{
+}
+
+int fbm_insert_sequence(gr, seq, where)
+{
+}
+
+int fbm_remove_sequence(gr, seq)
+{
+}
+
+
+
+
+
+
+
+
+
+
 /*
  *  FUNCTION : fbm_load_from
  *
@@ -173,11 +213,13 @@
 		fbm_error = _("FBM file is corrupt");
 		return NULL;
 	}
+/*
 	if (header.width > FBM_MAX_WIDTH || header.height > FBM_MAX_HEIGHT)
 	{
 		fbm_error = "FBM file is corrupt";
 		return NULL;
 	}
+*/
 
 	// Allocate space in memory for the data
 
@@ -229,9 +271,8 @@
 					{
 						fbm_error = _("FBM file is truncated");
 						error = 1;
+						break;
 					}
-					else
-					{
 						if (!palette_loaded) {
 							for (n = 0 ; n < 256 ; n++)
 							{
@@ -239,16 +280,13 @@
 								palette[n].g = color_palette[3*n + 1];
 								palette[n].b = color_palette[3*n + 2];
 							}
+                    }
 
-
-							// bug 62 : initialization of palette vars
+                    graph->palette = pal_new2(color_palette);
 
 							palette_loaded = 1 ;
 							palette_changed = 1 ;
 						}
-
-					}
-				}
 				break;
 
 			case 1:				// Read the sequences
@@ -302,9 +340,9 @@
 			case 4:				// Read the graphic data
 
             	if (graph->depth == 1)
-            		size = (graph->width + 7)/8 /* * graph->height*/;
+            		size = (graph->width + 7)/8 ;
             	else
-            		size = graph->width /* * map->height */ * graph->depth / 8;
+            		size = graph->width * graph->depth / 8;
 
                 h = graph->height * graph->frames;
 
@@ -328,8 +366,9 @@
 
 	if (error)
 	{
-		if (graph != NULL)
+		if (graph) {
 			bitmap_destroy(graph);
+		}
 		else
 		{
 			if (sequences) free(sequences);
@@ -396,6 +435,7 @@
 	static char			color_palette[768];
     char                * data_copy = NULL;
     char                * data = NULL;
+    SDL_Color           * gpal = NULL;
 
 	// Prepare the header
 
@@ -446,11 +486,13 @@
 
 	if (map->depth == 8 && with_palette)
 	{
+        if (map->palette) gpal = map->palette->rgb; else gpal = palette;
+
 		for (n = 0 ; n < 256 ; n++)
 		{
-			color_palette[3*n + 0] = palette[n].r;
-			color_palette[3*n + 1] = palette[n].g;
-			color_palette[3*n + 2] = palette[n].b;
+			color_palette[3*n    ] = gpal[n].r;
+			color_palette[3*n + 1] = gpal[n].g;
+			color_palette[3*n + 2] = gpal[n].b;
 		}
 
 		if (file_write (fp, &color_palette, 768) != 768)
@@ -512,9 +554,9 @@
 	// Write the graphic data
 
 	if (map->depth == 1)
-		size = (map->width + 7)/8 /* * map->height*/;
+		size = (map->width + 7)/8 ;
 	else
-		size = map->width /* * map->height */ * map->depth / 8;
+		size = map->width * map->depth / 8;
 
 	if (map->depth == 16)
 	{
Index: fxi/src/f_cd.c
===================================================================
--- fxi/src/f_cd.c	2007-08-28 14:38:24.000000000 +0200
+++ fxi/src/f_cd.c	2007-08-28 14:41:11.000000000 +0200
@@ -105,11 +105,11 @@
 	GLODWORD(CD_TRACK)  = sdl_cd->cur_track;
 	FRAMES_TO_MSF (sdl_cd->cur_frame, &GLODWORD(CD_MINUTE), &GLODWORD(CD_SECOND), &GLODWORD(CD_SUBFRAME));
 
-	for (i = 0, pos = CD_TRACKINFO ; i < sdl_cd->numtracks ; i++, pos += 4)
+	for (i = 0, pos = CD_TRACKINFO ; i < sdl_cd->numtracks ; i++, pos += 16)
 	{
 		total += sdl_cd->track[i].length;
 		GLODWORD(pos) = (sdl_cd->track[i].type == SDL_AUDIO_TRACK);
-		FRAMES_TO_MSF (sdl_cd->track[i].length, &GLODWORD(pos+1), &GLODWORD(pos+2), &GLODWORD(pos+3));
+		FRAMES_TO_MSF (sdl_cd->track[i].length, &GLODWORD(pos+4), &GLODWORD(pos+8), &GLODWORD(pos+12));
 	}
 	FRAMES_TO_MSF (total, &GLODWORD(CD_MINUTES), &GLODWORD(CD_SECONDS), &GLODWORD(CD_FRAMES));
 	return 1;
@@ -239,7 +239,7 @@
 	return !SDL_CDStop(sdl_cd);
 }
 
-
+/*
 int fxi_cd_numtracks(INSTANCE * my, int * params)
 {
 	if (params[0] < 0 || params[0] >= SDL_CDNumDrives()) return 0;
@@ -270,4 +270,5 @@
 
 	return sdl_cd->cur_track;
 }
+*/
 
Index: fxi/src/fgc.c
===================================================================
--- fxi/src/fgc.c	2007-08-28 14:39:54.000000000 +0200
+++ fxi/src/fgc.c	2007-08-28 14:41:11.000000000 +0200
@@ -75,6 +75,7 @@
 	FGC_HEADER	header;
 	Uint32 *	offsets;
 	Uint32		i;
+	PALETTE *   pal = NULL;
 
 	// Open the file and check the header and version
 
@@ -145,6 +146,8 @@
 			return -1;
 		}
 
+        pal = pal_new2(color_palette);
+
 		if (!palette_loaded)
 		{
 			for (i = 0 ; i < 256 ; i++)
@@ -171,10 +174,14 @@
 			break;
 		}
 		grlib_add_map (id, graph);
+		if (graph->depth == 8 && !graph->palette) pal_map_assign(id, graph, pal);
 	}
 
 	free(offsets);
 	file_close(fp);
+
+    pal_destroy(pal); // Elimino la instancia inicial
+
 	return (i == header.count ? id : -1);
 }
 
@@ -199,6 +206,7 @@
 	file *		fp;
 	int			i, n;
 	Uint32 *    offsets;
+	int         palette_saved = 0;
 
 	// Check the parameters 
 	
@@ -219,12 +227,10 @@
 
 	for (i = 0 ; i < lib->map_reserved ; i++)
 	{
-		if (lib->maps[i] == NULL)
-			continue;
+		if (lib->maps[i] == NULL) continue;
 
 		// Maps with code > 999 are not inside a collection
-		if (lib->maps[i]->code > 999)
-			continue;
+		if (lib->maps[i]->code > 999) continue;
 
 		header.count++;
 		if (header.depth == 0)
@@ -264,17 +270,14 @@
 
 	for (i = n = 0 ; i < lib->map_reserved ; i++)
 	{
-		if (lib->maps[i] == NULL)
-			continue;
+		if (lib->maps[i] == NULL) continue;
 		// Maps with code > 999 are not inside a collection
-		if (lib->maps[i]->code > 999)
-			continue;
+		if (lib->maps[i]->code > 999) continue;
 
 		if (n == 0)
 		{
 			offsets[n] = sizeof(FGC_HEADER) + 4*header.count;
-			if (header.depth == 8)
-				offsets[n] += 768;
+			if (header.depth == 8) offsets[n] += 768;
 		}
 		
 		offsets[n+1] = offsets[n] + fbm_size(lib->maps[i], 0, 0);
@@ -307,37 +310,41 @@
 		return 0;
 	} 
 	
+	// Write each graphic
+
+	for (i = n = 0 ; i < lib->map_reserved ; i++)
+	{
+		if (lib->maps[i] == NULL)
+			continue;
+		// Maps with code > 999 are not inside a collection
+		if (lib->maps[i]->code > 999)
+			continue;
+
 	// Write the graphic palette
 
-	if (header.depth == 8)
+		if (!palette_saved && header.depth == 8)
 	{
 		static char color_palette[768];
+			SDL_Color * gpal = palette ;
+
+			if (lib->maps[i]->palette) gpal = lib->maps[i]->palette->rgb; else gpal = palette;
 
 		for (i = 0 ; i < 256 ; i++)
 		{
-			color_palette[3*i + 0] = palette[i].r;
-			color_palette[3*i + 1] = palette[i].g;
-			color_palette[3*i + 2] = palette[i].b;
+				color_palette[3*i    ] = gpal[i].r;
+				color_palette[3*i + 1] = gpal[i].g;
+				color_palette[3*i + 2] = gpal[i].b;
 		}
 		if (file_write(fp, color_palette, 768) != 768)
 		{
-			fgc_error = _("Write error, FGC file is truncated");
+				fgc_error = "Error al escribir, FGC truncado";
 			free(offsets);
 			file_close(fp);
 			return -1;
 		} 
+			palette_saved = 1;
 	}
 
-	// Write each graphic
-
-	for (i = n = 0 ; i < lib->map_reserved ; i++)
-	{
-		if (lib->maps[i] == NULL)
-			continue;
-		// Maps with code > 999 are not inside a collection
-		if (lib->maps[i]->code > 999)
-			continue;
-
 		assert (file_pos(fp) == (int)offsets[n]);
 
 		if (!fbm_save_to (lib->maps[i], fp, 0))
Index: fxi/src/fnc_exports.c
===================================================================
--- fxi/src/fnc_exports.c	2007-08-28 14:39:54.000000000 +0200
+++ fxi/src/fnc_exports.c	2007-08-28 14:41:12.000000000 +0200
@@ -72,6 +72,8 @@
     { "file_write"                      , file_write                  },
     { "file_gets"                       , file_gets                   },
     { "file_puts"                       , file_puts                   },
+    { "file_qgets"                      , file_qgets                  },
+    { "file_qputs"                      , file_qputs                  },
     { "file_size"                       , file_size                   },
     { "file_pos"                        , file_pos                    },
     { "file_seek"                       , file_seek                   },
Index: fxi/src/fpl.c
===================================================================
--- fxi/src/fpl.c	2007-08-28 14:39:55.000000000 +0200
+++ fxi/src/fpl.c	2007-08-28 14:44:03.000000000 +0200
@@ -100,7 +100,7 @@
 	}
 
 	for (n = 0 ; n < 256 ; n++) {
-		palette[n].r = color_palette[3*n + 0];
+		palette[n].r = color_palette[3*n    ];
 		palette[n].g = color_palette[3*n + 1];
 		palette[n].b = color_palette[3*n + 2];
 	}
@@ -135,7 +135,7 @@
 
 	for (n = 0 ; n < 256 ; n++)
 	{
-		color_palette[3*n + 0] = palette[n].r;
+		color_palette[3*n    ] = palette[n].r;
 		color_palette[3*n + 1] = palette[n].g;
 		color_palette[3*n + 2] = palette[n].b;
 	}
Index: fxi/src/g_blendop.c
===================================================================
--- fxi/src/g_blendop.c	2007-08-28 14:38:25.000000000 +0200
+++ fxi/src/g_blendop.c	2007-08-28 14:41:12.000000000 +0200
@@ -323,8 +323,8 @@
 			r = GETR(i);
 			g = GETG(i);
 			b = GETB(i);
-			max = r > g ? r > b ? r : g : g > b ? g : b ;
-			min = r < g ? r < b ? r : g : g < b ? g : b ;
+			max = (r > g) ? (r > b) ? r : g : (g > b) ? g : b ;
+			min = (r < g) ? (r < b) ? r : g : (g < b) ? g : b ;
 			r = (max+min)/2;
 			blend[i] = MAKERGB(r, r, r) ;
 		}
@@ -336,7 +336,7 @@
 			r = GETR(i);
 			g = GETG(i);
 			b = GETB(i);
-			max = r > g ? r > b ? r : g : g > b ? g : b ;
+			max = (r > g) ? (r > b) ? r : g : (g > b) ? g : b ;
 			blend[i] = MAKERGB(max, max, max) ;
 		}
 	}
Index: fxi/src/g_blit.c
===================================================================
--- fxi/src/g_blit.c	2007-08-28 14:39:55.000000000 +0200
+++ fxi/src/g_blit.c	2007-08-28 14:41:12.000000000 +0200
@@ -96,6 +96,8 @@
 Sint16  * ghost2;
 Uint8   * ghost8;
 
+Uint16 * pcolorequiv = NULL ;
+
 /*
     Calculates additive blend value
 */
@@ -243,9 +245,6 @@
  *
  */
 
-extern Sint16 * ghost1;
-extern Sint16 * ghost2;
-extern Uint8  * ghost8;
 /*
 void draw_span_1to1(GRAPH * dest, GRAPH * orig, int x, int y, int pixels,
                     int s, int t, int incs, int inct)
@@ -287,8 +286,7 @@
 }
 */
 
-void draw_span_1to8(GRAPH * dest, GRAPH * orig, int x, int y, int pixels,
-                    int s, int t, int incs, int inct)
+void draw_span_1to8(GRAPH * dest, GRAPH * orig, int x, int y, int pixels, int s, int t, int incs, int inct)
 {
     Uint8 * ptr = (Uint8 *)dest->data + dest->pitch*y + x ;
     int cs = s, ct = t, i;
@@ -302,8 +300,7 @@
     }
 }
 
-void draw_span_8to8_nocolorkey(GRAPH * dest, GRAPH * orig, int x, int y, int pixels,
-                                int s, int t, int incs, int inct)
+void draw_span_8to8_nocolorkey(GRAPH * dest, GRAPH * orig, int x, int y, int pixels, int s, int t, int incs, int inct)
 {
     Uint8 * ptr = (Uint8 *)dest->data + dest->pitch*y + x;
     int cs = s, ct = t, i;
@@ -401,7 +398,7 @@
     for (i = 0 ; i < pixels ; i++)
     {
         Uint8 * tex = (Uint8 *)orig->data + orig->pitch*(ct >> 16) + (cs >> 16);
-        if (*tex != 0) *ptr = colorequiv[*tex];
+        if (*tex != 0) *ptr = pcolorequiv[*tex];
         ptr++;
         cs += incs, ct += inct;
     }
@@ -417,7 +414,7 @@
     for (i = 0 ; i < pixels ; i++)
     {
         Uint8 * tex = (Uint8 *)orig->data + orig->pitch*(ct >> 16) + (cs >> 16);
-        if (*tex != 0) *ptr = ablend(colorequiv[*tex],*ptr);
+        if (*tex != 0) *ptr = ablend(pcolorequiv[*tex],*ptr);
         ptr++;
         cs += incs, ct += inct;
     }
@@ -432,7 +429,7 @@
     for (i = 0 ; i < pixels ; i++)
     {
         Uint8 * tex = (Uint8 *)orig->data + orig->pitch*(ct >> 16) + (cs >> 16);
-        if (*tex != 0) *ptr = ablend((Uint16)(ghost1[colorequiv[*tex]] + ghost2[*ptr]),*ptr);
+        if (*tex != 0) *ptr = ablend((Uint16)(ghost1[pcolorequiv[*tex]] + ghost2[*ptr]),*ptr);
         ptr++;
         cs += incs, ct += inct;
     }
@@ -447,7 +444,7 @@
     for (i = 0 ; i < pixels ; i++)
     {
         Uint8 * tex = (Uint8 *)orig->data + orig->pitch*(ct >> 16) + (cs >> 16);
-        if (*tex != 0) *ptr = ghost1[colorequiv[*tex]] + ghost2[*ptr];
+        if (*tex != 0) *ptr = ghost1[pcolorequiv[*tex]] + ghost2[*ptr];
         ptr++;
         cs += incs, ct += inct;
     }
@@ -462,7 +459,7 @@
     for (i = 0 ; i < pixels ; i++)
     {
         Uint8 * tex = (Uint8 *)orig->data + orig->pitch*(ct >> 16) + (cs >> 16);
-        *ptr++ = colorequiv[*tex];
+        *ptr++ = pcolorequiv[*tex];
         cs += incs, ct += inct;
     }
 }
@@ -659,7 +656,7 @@
 
     for (i = 0 ; i < pixels ; i++)
     {
-        if (*tex != 0) *scr = colorequiv[*tex];
+        if (*tex != 0) *scr = pcolorequiv[*tex];
         scr++;
         tex += incs;
     }
@@ -671,7 +668,7 @@
 
     for (i = 0 ; i < pixels ; i++)
     {
-        if (*tex != 0) *scr = ablend(colorequiv[*tex], *scr);
+        if (*tex != 0) *scr = ablend(pcolorequiv[*tex], *scr);
         scr++;
         tex += incs;
     }
@@ -683,7 +680,7 @@
 
     for (i = 0 ; i < pixels ; i++)
     {
-        if (*tex != 0) *scr = ablend((Uint16)(ghost1[colorequiv[*tex]] + ghost2[*scr]),*scr);
+        if (*tex != 0) *scr = ablend((Uint16)(ghost1[pcolorequiv[*tex]] + ghost2[*scr]),*scr);
         scr++;
         tex += incs;
     }
@@ -695,7 +692,7 @@
 
     for (i = 0 ; i < pixels ; i++)
     {
-        if (*tex != 0) *scr = ghost1[colorequiv[*tex]] + ghost2[*scr];
+        if (*tex != 0) *scr = ghost1[pcolorequiv[*tex]] + ghost2[*scr];
         scr++;
         tex += incs;
     }
@@ -707,7 +704,7 @@
 
     for (i = 0 ; i < pixels ; i++)
     {
-        *scr++ = colorequiv[*tex];
+        *scr++ = pcolorequiv[*tex];
         tex += incs;
     }
 }
@@ -1025,12 +1022,9 @@
 
     /* Analize the bitmap if needed (find if no color key used */
 
-    if (gr->modified)
-        bitmap_analize (gr) ;
+    if (gr->modified) bitmap_analize (gr) ;
 
-    if (gr->info_flags & GI_NOCOLORKEY) {
-        flags |= B_NOCOLORKEY ;
-    }
+    if (gr->info_flags & GI_NOCOLORKEY) flags |= B_NOCOLORKEY ;
 
     /* Setup the 16 bits translucency tables if necessay */
 
@@ -1059,8 +1053,7 @@
         ghost8 = (Uint8 *)trans_table ;
     }
 /*
-    if ((flags & B_TRANSLUCENT) && !trans_table_updated)
-        gr_make_trans_table() ;
+    if ((flags & B_TRANSLUCENT) && !trans_table_updated) gr_make_trans_table() ;
 */
     #ifdef MMX_FUNCTIONS
     if (MMX_available) {
@@ -1100,6 +1093,8 @@
     }
     else if (dest->depth == 16 && gr->depth == 8)
     {
+        pcolorequiv = gr->palette ? gr->palette->colorequiv : colorequiv ;
+
         if (flags & B_TRANSLUCENT){
             if(flags & B_ABLEND){
                 bt=0;
@@ -1347,11 +1342,9 @@
 
     /* Analize the bitmap if needed (find if no color key used */
 
-    if (gr->modified)
-        bitmap_analize (gr) ;
+    if (gr->modified) bitmap_analize (gr) ;
 
-    if (gr->info_flags & GI_NOCOLORKEY)
-        flags |= B_NOCOLORKEY ;
+    if (gr->info_flags & GI_NOCOLORKEY) flags |= B_NOCOLORKEY ;
 
     /* Setup the 16 bits translucency tables if necessay */
 
@@ -1379,9 +1372,9 @@
         ghost1 = ghost2 = colorghost ;
         ghost8 = (Uint8 *)trans_table ;
     }
+
 /*
-    if ((flags & B_TRANSLUCENT) && !trans_table_updated)
-        gr_make_trans_table() ;
+    if ((flags & B_TRANSLUCENT) && !trans_table_updated) gr_make_trans_table() ;
 */
     #ifdef MMX_FUNCTIONS
     if (MMX_available) {
@@ -1448,6 +1441,8 @@
     }
     else if (dest->depth == 16 && gr->depth == 8)
     {
+        pcolorequiv = gr->palette ? gr->palette->colorequiv : colorequiv ;
+
         if (flags & B_TRANSLUCENT){
             if(flags & B_ABLEND){
                 bt=0;
@@ -1479,9 +1474,10 @@
             }else if(flags & B_SBLEND){
                 bt=1;
                 draw_hspan = draw_hspan_16to16_tablend;
-            }else
+            }else{
                 draw_hspan = draw_hspan_16to16_translucent;
         }
+        }
         else if(flags & B_ABLEND){
             bt=0;
             draw_hspan = draw_hspan_16to16_ablend;
@@ -1569,10 +1565,8 @@
 
     /* Mirror the texture coordinates if needed */
 
-    if (flags & B_HMIRROR)
-        s = gr->width - 1 - s;
-    if (flags & B_VMIRROR)
-        t = gr->height - 1 - t;
+    if (flags & B_HMIRROR) s = gr->width - 1 - s;
+    if (flags & B_VMIRROR) t = gr->height - 1 - t;
 
     /* Calculate the initial pointers and advances */
 
@@ -1583,10 +1577,8 @@
     tex_inc   = gr->pitch ;
     direction = 1;
 
-    if (flags & B_VMIRROR)
-        tex_inc = -tex_inc;
-    if (flags & B_HMIRROR)
-        direction = -1;
+    if (flags & B_VMIRROR) tex_inc = -tex_inc;
+    if (flags & B_HMIRROR) direction = -1;
 
     if (p > 0)
     {
@@ -1597,6 +1589,7 @@
             tex = (Uint8 *)tex + tex_inc;
         }
     }
+
     dest->modified = 1 ;
 }
 
Index: fxi/src/g_console.c
===================================================================
--- fxi/src/g_console.c	2007-08-28 14:39:56.000000000 +0200
+++ fxi/src/g_console.c	2007-08-28 14:41:12.000000000 +0200
@@ -53,9 +53,9 @@
 #define CHARHEIGHT 8
 
 #define CONSOLE_HISTORY 512
-#define CONSOLE_LINES   16
-#define CONSOLE_COLUMNS 52
-#define COMMAND_HISTORY 64
+#define CONSOLE_LINES   25
+#define CONSOLE_COLUMNS 80
+#define COMMAND_HISTORY 128
 
 #define HELPTXT _( \
             "¬02Process Info¬07\n"                                          \
@@ -82,11 +82,11 @@
             "¬02Process Interaction¬07\n"                                   \
             "¬04RUN proc [args]¬07  Run a process\n"                        \
             "¬04KILL proc      ¬07  Kill a process\n"                       \
-            "¬04WEAKUP proc    ¬07  Weakup a process\n"                     \
+            "¬04WAKEUP proc    ¬07  Wakeup a process\n"                     \
             "¬04SLEEP proc     ¬07  Sleep a process\n"                      \
             "¬04FREEZE proc    ¬07  Freeze a process\n"                     \
             "¬04KILLALL proc   ¬07  Kill all process with criteria\n"       \
-            "¬04WEAKUPALL proc ¬07  Weakup all process with criteria\n"     \
+            "¬04WAKEUPALL proc ¬07  Wakeup all process with criteria\n"     \
             "¬04SLEEPALL proc  ¬07  Sleep all process with criteria\n"      \
             "¬04FREEZEALL proc ¬07  Freeze all process with criteria\n"     \
             "\n"                                                            \
@@ -367,6 +367,7 @@
     }
 }
 
+extern int * stack_gptr;
 
 void gr_con_draw()
 {
@@ -377,6 +378,14 @@
     if (!console_initialized)
         return ;
 
+    if (console_columns > scrbitmap->width / CHARWIDTH) {
+        console_columns = scrbitmap->width / CHARWIDTH ;
+    }
+
+    if (console_lines > ( scrbitmap->height - CHARHEIGHT * 2 ) / CHARHEIGHT) {
+        console_lines = ( scrbitmap->height - CHARHEIGHT * 2 ) / CHARHEIGHT ;
+    }
+
     if (console_showing)
     {
         if (con_y < console_lines*CHARHEIGHT)
@@ -396,14 +405,6 @@
         if (con_y < 0) { con_y = 0 ; vy = CHARHEIGHT ; return ; }
     }
 
-    if ( scrbitmap->width < console_columns * CHARWIDTH ) {
-        console_columns = scrbitmap->width / CHARWIDTH ;
-    }
-
-    if ( scrbitmap->height < console_lines * CHARHEIGHT ) {
-        console_lines = ( scrbitmap->height - CHARHEIGHT * 2 ) / CHARHEIGHT ;
-    }
-
     x = (scrbitmap->width - console_columns*CHARWIDTH)/2 ;
     y = -console_lines*CHARHEIGHT + con_y ;
 
@@ -421,8 +422,8 @@
             gr_sys_color (console_showcolor, 0) ;
             gr_sys_puts (scrbitmap,
                          (scrbitmap->width - strlen(result)*CHARWIDTH)/2,
-                         con_y <= 0 ? 2:con_y+CHARHEIGHT, result, strlen(result));
-            gr_mark_rect (0, con_y <= 0 ? 2:con_y+CHARHEIGHT, scr_width, CHARHEIGHT);
+                         (con_y <= 0) ? 2:con_y+CHARHEIGHT, result, strlen(result));
+            gr_mark_rect (0, (con_y <= 0) ? 2:con_y+CHARHEIGHT, scr_width, CHARHEIGHT);
         }
     }
 
@@ -1228,7 +1229,7 @@
             _snprintf (result.name, sizeof(result.name), "%g", base) ;
             return ;
         }
-        op = token.name[0] == '*' ? 1: token.name[0] == '/' ? 2:3 ;
+        op = (token.name[0] == '*') ? 1: (token.name[0] == '/') ? 2:3 ;
         get_token() ;
     }
 }
@@ -1259,7 +1260,7 @@
             _snprintf (result.name, sizeof(result.name), "%g", base) ;
             return ;
         }
-        op = token.name[0] == '+' ? 1:-1 ;
+        op = (token.name[0] == '+') ? 1:-1 ;
         get_token() ;
     }
 }
@@ -1286,7 +1287,7 @@
     }
 
     memset (part, 0, sizeof(buffer));
-    strncpy (part, here, token_ptr - here - (token.type != NOTOKEN ? 1:0));
+    strncpy (part, here, token_ptr - here - ((token.type != NOTOKEN) ? 1:0));
 
     if (result.type == T_CONSTANT)
     {
@@ -1485,7 +1486,7 @@
         return ;
     }
 
-    if (strncmp (action, "BREAK", 5) == 0)
+    if (strcmp (action, "BREAK") == 0)
     {
         if (*ptr) {
             if (*ptr >= '0' && *ptr <= '9')
@@ -1549,7 +1550,7 @@
         return ;
     }
 
-    if (strncmp (action, "DELETE", 6) == 0)
+    if (strcmp (action, "DELETE") == 0)
     {
         if (*ptr) {
             if (*ptr >= '0' && *ptr <= '9')
@@ -1607,9 +1608,9 @@
         return ;
     }
 
-    if (strncmp (action, "LOCAL", 5) == 0 ||
-        strncmp (action, "PRIVATE", 7) == 0 ||
-        strncmp (action, "PUBLIC", 6) == 0)
+    if (strcmp (action, "LOCALS") == 0 ||
+        strcmp (action, "PRIVATES") == 0 ||
+        strcmp (action, "PUBLICS") == 0)
     {
         int show_locals = action[0] == 'L';
         int show_public = action[0] == 'P' && action[1] == 'U' ;
@@ -1682,7 +1683,7 @@
         return ;
     }
 
-    if (strncmp (action, "RUN", 3) == 0)
+    if (strcmp (action, "RUN") == 0)
     {
         if (*ptr) {
             aptr = action;
@@ -1758,10 +1759,10 @@
         }
     }
 
-    if (strncmp (action, "KILLALL", 7) == 0 ||
-        strncmp (action, "SLEEPALL", 8) == 0 ||
-        strncmp (action, "WEAKUPALL", 9) == 0 ||
-        strncmp (action, "FREEZEALL", 9) == 0 )
+    if (strcmp (action, "KILLALL") == 0 ||
+        strcmp (action, "SLEEPALL") == 0 ||
+        strcmp (action, "WAKEUPALL") == 0 ||
+        strcmp (action, "FREEZEALL") == 0 )
     {
         char    act = *action;
         int     found = 0;
@@ -1797,10 +1798,10 @@
         return ;
     }
 
-    if (strncmp (action, "KILL", 4) == 0 ||
-        strncmp (action, "SLEEP", 5) == 0 ||
-        strncmp (action, "WEAKUP", 6) == 0 ||
-        strncmp (action, "FREEZE", 6) == 0 )
+    if (strcmp (action, "KILL") == 0 ||
+        strcmp (action, "SLEEP") == 0 ||
+        strcmp (action, "WAKEUP") == 0 ||
+        strcmp (action, "FREEZE") == 0 )
     {
         char act=*action;
         i = findproc(NULL, action, ptr);
Index: fxi/src/g_conversion.c
===================================================================
--- fxi/src/g_conversion.c	2007-08-28 14:39:56.000000000 +0200
+++ fxi/src/g_conversion.c	2007-08-28 14:41:13.000000000 +0200
@@ -76,10 +76,8 @@
 	int      i, color, inc, next = 0, factor;
 	Uint16 * table16 = NULL;
 
-	if (alpha16_tables_ok == count)
-		return;
-	if (count <= 0 || count > 128)
-		return;
+	if (alpha16_tables_ok == count) return;
+	if (count <= 0 || count > 128) return;
 
 	inc = 256/count;
 
@@ -394,10 +392,9 @@
 
 		for (x = 0 ; x < graph->width ; x++, ptr++)
 		{
-			*ptr = (
-				  Rtable[((*ptr & Rmask) >> Rshift)]
-				| Gtable[((*ptr & Gmask) >> Gshift)]
-				| Btable[((*ptr & Bmask) >> Bshift)] );
+			*ptr = (Rtable[((*ptr & Rmask) >> Rshift)] |
+			        Gtable[((*ptr & Gmask) >> Gshift)] |
+			        Btable[((*ptr & Bmask) >> Bshift)] );
 		}
 	}
 }
@@ -418,8 +415,7 @@
 
 Uint16 * gr_alpha16 (int alpha)
 {
-	if (alpha16_tables_ok == 0)
-		init_alpha16_tables(GLODWORD(ALPHA_STEPS));
+	if (alpha16_tables_ok == 0) init_alpha16_tables(GLODWORD(ALPHA_STEPS));
 	return alpha16[alpha];
 }
 
Index: fxi/src/g_draw.c
===================================================================
--- fxi/src/g_draw.c	2007-08-28 14:39:56.000000000 +0200
+++ fxi/src/g_draw.c	2007-08-28 14:41:13.000000000 +0200
@@ -46,17 +46,15 @@
 #include "files.h"
 #include "grlib.h"
 
-#define ABS(x) ((x) < 0 ? -(x):(x))
-
 int      syscolor8 = 15 ;
 Uint16   syscolor16 = 0xFFFF ;
-Uint16   syscolor16_alpha;
+Uint16   syscolor16_alpha = 0xFFFF ;
 int      drawing_alpha = 255;
-Uint16 * drawing_alpha16;
-Uint8  * drawing_alpha8;
+Uint16 * drawing_alpha16 = NULL ;
+Uint8  * drawing_alpha8 = NULL ;
 Uint32   drawing_stipple = 0xFFFFFFFF;
 
-static DRAWING_OBJECT * drawing_objects = NULL;
+DRAWING_OBJECT * drawing_objects = NULL;
 
 #ifdef __GNUC__
 #define _inline inline
@@ -72,8 +70,7 @@
     {
         register int n;
 
-        for (n = length ; n ; n--, ptr++)
-            *ptr = drawing_alpha8[(syscolor8 << 8) + *ptr];
+        for (n = length; n; n--, ptr++) *ptr = drawing_alpha8[(syscolor8 << 8) + *ptr];
     }
 }
 
@@ -85,18 +82,16 @@
     {
         for (n = length ; n ; n--, ptr++)
         {
-            if (drawing_stipple & 1)
-                *ptr = syscolor8;
-            drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+            if (drawing_stipple & 1) *ptr = syscolor8;
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
         }
     }
     else
     {
         for (n = length ; n ; n--, ptr++)
         {
-            if (drawing_stipple & 1)
-                *ptr = drawing_alpha8[(syscolor8 << 8) + *ptr];
-            drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+            if (drawing_stipple & 1) *ptr = drawing_alpha8[(syscolor8 << 8) + *ptr];
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
         }
     }
 }
@@ -107,13 +102,11 @@
 
     if (drawing_alpha == 255)
     {
-        for (n = length ; n ; n--)
-            *ptr++ = syscolor16 ;
+        for (n = length; n; n--) *ptr++ = syscolor16 ;
     }
     else
     {
-        for (n = length ; n ; n--, ptr++)
-            *ptr = drawing_alpha16[*ptr] + syscolor16_alpha ;
+        for (n = length; n; n--, ptr++) *ptr = drawing_alpha16[*ptr] + syscolor16_alpha ;
     }
 }
 
@@ -125,18 +118,16 @@
     {
         for (n = length ; n ; n--, ptr++)
         {
-            if (drawing_stipple & 1)
-                *ptr = syscolor16 ;
-            drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+            if (drawing_stipple & 1) *ptr = syscolor16 ;
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
         }
     }
     else
     {
         for (n = length ; n ; n--, ptr++)
         {
-            if (drawing_stipple & 1)
-                *ptr = drawing_alpha16[*ptr] + syscolor16_alpha ;
-            drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+            if (drawing_stipple & 1) *ptr = drawing_alpha16[*ptr] + syscolor16_alpha ;
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
         }
     }
 }
@@ -173,8 +164,7 @@
 
 int gr_get_pixel (GRAPH * dest, int x, int y)
 {
-    if (x < 0 || y < 0 || x >= (int)dest->width || y >= (int)dest->height)
-        return -1 ;
+    if (x < 0 || y < 0 || x >= (int)dest->width || y >= (int)dest->height) return -1 ;
 
     switch (dest->depth)
     {
@@ -208,8 +198,7 @@
 
 void gr_put_pixel (GRAPH * dest, int x, int y, int color)
 {
-    if (x < 0 || y < 0 || x >= (int)dest->width || y >= (int)dest->height)
-        return ;
+    if (x < 0 || y < 0 || x >= (int)dest->width || y >= (int)dest->height) return ;
 
     dest->modified = 1 ;
 
@@ -221,12 +210,14 @@
         case 16:
             _Pixel16(((Uint16 *)dest->data) + x + dest->pitch*y/2, color, gr_alpha16(drawing_alpha)[color]) ;
             break;
+
         case 1:
             if (color)
-                ((Uint8 *)dest->data)[x/8 + dest->pitch*y] |= (0x80 >> (x & 7)) ;
+                (((Uint8 *)dest->data)[x / 8 + dest->pitch * y]) |= (0x80 >> (x & 7)) ;
             else
-                ((Uint8 *)dest->data)[x/8 + dest->pitch*y] &= ~(0x80 >> (x & 7)) ;
+                (((Uint8 *)dest->data)[x / 8 + dest->pitch * y]) &= ~(0x80 >> (x & 7)) ;
             break;
+
         default:
             gr_error (_("gr_put_pixel: Unsupported colour depth"));
     }
@@ -252,6 +243,8 @@
 {
     if (clip && x >= clip->x && x <= clip->x2 && y >= clip->y && y <= clip->y2)
         gr_put_pixel (dest, x, y, color);
+
+    dest->modified = 1;
 }
 
 /*
@@ -273,8 +266,7 @@
 
     memset (dest->data, 0, dest->pitch * dest->height) ;
 
-    if (dest == background)
-        background_is_black = 1;
+    if (dest == background) background_is_black = 1;
 }
 
 /*
@@ -300,21 +292,46 @@
     switch (dest->depth)
     {
         case 8:
-            for (y = 0 ; y < dest->height ; y++)
-                memset ((Uint8 *)dest->data + dest->pitch * y, color, dest->width) ;
+        {
+            memset (dest->data, color, dest->pitch * dest->height) ;
+/*
+            Uint8 * data = dest->data ;
+            for (y = 0; y < dest->height; y++) {
+                memset (data, color, dest->pitch) ;
+                data += dest->pitch ;
+            }
+*/
             break;
+        }
+
         case 16:
+        {
+            Uint8 * data = dest->data ;
             for (y = 0 ; y < dest->height ; y++)
             {
-                Uint16 * ptr = (Uint16 *)dest->data + dest->pitch*y/2;
-                int n, m = dest->width ;
-                for (n = 0 ; n < m ; n++) *ptr++ = color ;
+                Uint16 * ptr = (Uint16 *)data ;
+                int n ;
+                for (n = 0; n < dest->width; n++) *ptr++ = color ;
+                data += dest->pitch ;
             }
             break;
+        }
+
         case 1:
-            for (y = 0 ; y < dest->height ; y++)
-                memset ((Uint8 *)dest->data + dest->pitch * y, color ? 0xFF:0, dest->width/8) ;
+        {
+            int c = color ? 0xFF : 0 ;
+            memset (dest->data, c, dest->pitch * dest->height) ;
+/*
+            Uint8 * data = dest->data ;
+            int c = color ? 0xFF : 0 ;
+            for (y = 0; y < dest->height; y++) {
+                memset (data, c, dest->pitch) ;
+                data += dest->pitch ;
+            }
+*/
             break;
+        }
+
         default:
             gr_error (_("gr_clear_as: Unsupported colour depth"));
     }
@@ -324,6 +341,87 @@
 }
 
 /*
+ *  FUNCTION : gr_clear_region
+ *
+ *  Clear a region bitmap (paint all pixels as 0 [transparent])
+ *
+ *  PARAMS :
+ *      dest            Bitmap to clear
+ *      region          Region to clear or NULL for the whole screen
+ *
+ *  RETURN VALUE :
+ *      None
+ *
+ */
+
+void gr_clear_region (GRAPH * dest, REGION * region)
+{
+    REGION base_region ;
+    int y, n, l ;
+
+    if (!dest) dest = scrbitmap ;
+    dest->modified = 1 ;
+
+    if (!region)
+    {
+        region = &base_region ;
+        region->x = 0 ;
+        region->y = 0 ;
+        region->x2 = dest->width - 1 ;
+        region->y2 = dest->height - 1 ;
+    }
+    else
+    {
+        base_region = *region ;
+        region = &base_region ;
+        region->x = MAX(MIN(region->x, region->x2), 0) ;
+        region->y = MAX(MIN(region->y, region->y2), 0) ;
+        region->x2 = MIN(MAX(region->x, region->x2), dest->width - 1) ;
+        region->y2 = MIN(MAX(region->y, region->y2), dest->height - 1) ;
+    }
+
+    switch (dest->depth)
+    {
+        case 8:
+        {
+            Uint8 * data = ((Uint8 *)dest->data) + dest->pitch * region->y + region->x ;
+            l = region->x2 - region->x + 1;
+            for (y = region->y; y <= region->y2; y++) {
+                memset (data, 0, l) ;
+                data += dest->pitch ;
+            }
+
+            break ;
+        }
+
+        case 16:
+        {
+            Uint8 * data = ((Uint8 *)dest->data) + dest->pitch * region->y + region->x * 2;
+            l = region->x2 - region->x + 1;
+            for (y = region->y; y <= region->y2; y++) {
+                Uint16 * ptr = (Uint16 *)data ;
+                for (n = 0; n < l; n++) *ptr++ = 0 ;
+                data += dest->pitch ;
+            }
+            break ;
+        }
+
+        case 1:
+        {
+            Uint8 * data = ((Uint8 *)dest->data) + region->x / 8 ;
+            l = (region->x2 - region->x - 1) / 8 + 1 ;
+            for (y = region->y; y <= region->y2; y++) {
+                /* Esta debe ser cambiada, por bits */
+                memset (data, 0, l) ;
+                data += dest->pitch ;
+            }
+            break ;
+        }
+    }
+
+}
+
+/*
  *  FUNCTION : gr_vline
  *
  *  Draw a vertical rectangle
@@ -342,8 +440,11 @@
 void gr_vline (GRAPH * dest, REGION * clip, int x, int y, int h)
 {
     REGION base_clip ;
+    int old_stipple = drawing_stipple;
 
     if (!dest) dest = scrbitmap ;
+    dest->modified = 1 ;
+
     if (!clip)
     {
         clip = &base_clip ;
@@ -353,15 +454,13 @@
         clip->y2 = dest->height-1 ;
     }
 
-    dest->modified = 1 ;
-
-    if (h < 0) h = -h, y -= h-1 ;
+    if (h < 0) h = -h, y -= (h - 1) ;
     if (x < clip->x || x > clip->x2) return ;
 
     if (y < clip->y) h += y-clip->y, y = clip->y ;
-    if (y+h > clip->y2) h = clip->y2+1-y ;
+    if (y + h > clip->y2) h = clip->y2 - y + 1 ;
 
-    if (h < 1) return ;
+    if (h < 0) return ;
 
     if (dest->depth == 8)
     {
@@ -371,9 +470,8 @@
         {
             while (h--)
             {
-                if (drawing_stipple & 1)
-                    _Pixel8 (ptr, syscolor8) ;
-                drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+                if (drawing_stipple & 1) _Pixel8 (ptr, syscolor8) ;
+                drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
                 ptr += dest->pitch ;
             }
         }
@@ -389,15 +487,15 @@
     else if (dest->depth == 16)
     {
         Uint16 * ptr = dest->data ;
-        ptr += dest->pitch * y / 2 + x ;
+        int inc = dest->pitch / 2 ;
+        ptr += inc * y + x ;
         if (drawing_stipple != 0xFFFFFFFF)
         {
             while (h--)
             {
-                if (drawing_stipple & 1)
-                    _Pixel16 (ptr, syscolor16, syscolor16_alpha) ;
-                drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
-                ptr += dest->pitch / 2 ;
+                if (drawing_stipple & 1) _Pixel16 (ptr, syscolor16, syscolor16_alpha) ;
+                drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
+                ptr += inc ;
             }
         }
         else
@@ -405,10 +503,43 @@
             while (h--)
             {
                 _Pixel16 (ptr, syscolor16, syscolor16_alpha) ;
-                ptr += dest->pitch / 2 ;
+                ptr += inc ;
+            }
+        }
+    }
+    else if (dest->depth == 1)
+    {
+        Uint8 * ptr = dest->data;
+        int mask ;
+        ptr += dest->pitch * y + x / 8;
+        mask = (1 << (7-(x & 7)));
+        if (drawing_stipple != 0xFFFFFFFF)
+        {
+            while (h--)
+            {
+                if (drawing_stipple & 1) {
+                    if (!syscolor8)
+                        *ptr &= ~mask;
+                    else
+                        *ptr |= mask;
+                }
+                drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
+                ptr += dest->pitch ;
+            }
+        } else {
+            while (h--)
+            {
+                if (!syscolor8)
+                    *ptr &= ~mask;
+                else
+                    *ptr |= mask;
+                ptr += dest->pitch ;
             }
         }
     }
+
+    drawing_stipple = old_stipple;
+
 }
 
 /*
@@ -430,6 +561,7 @@
 void gr_hline (GRAPH * dest, REGION * clip, int x, int y, int w)
 {
     REGION base_clip ;
+    int old_stipple = drawing_stipple;
 
     if (!dest) dest = scrbitmap ;
     if (!clip)
@@ -443,13 +575,13 @@
 
     dest->modified = 1 ;
 
-    if (w < 0) w = -w, x -= w-1 ;
+    if (w < 0) w = -w, x -= (w - 1) ;
     if (y < clip->y || y > clip->y2) return ;
 
     if (x < clip->x) w += x-clip->x, x = clip->x ;
-    if (x+w > clip->x2) w = clip->x2+1-x ;
+    if (x + w > clip->x2) w = clip->x2 - x + 1 ;
 
-    if (w < 1) return ;
+    if (w < 0) return ;
 
     if (dest->depth == 8)
     {
@@ -475,6 +607,26 @@
         int mask ;
         ptr += dest->pitch * y + x/8;
         mask = (1 << (7-(x & 7)));
+
+        if (drawing_stipple != 0xFFFFFFFF)
+        {
+            while (w--)
+            {
+                if (drawing_stipple & 1) {
+                    if (!syscolor8)
+                        *ptr &= ~mask;
+                    else
+                        *ptr |= mask;
+                }
+                mask >>= 1;
+                if (!mask)
+                {
+                    mask = 0x80;
+                    ptr++;
+                }
+                drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
+            }
+        } else {
         while (w--)
         {
             if (!syscolor8)
@@ -491,6 +643,9 @@
     }
 }
 
+    drawing_stipple = old_stipple;
+}
+
 /*
  *  FUNCTION : gr_box
  *
@@ -513,6 +668,8 @@
     REGION base_clip ;
 
     if (!dest) dest = scrbitmap ;
+    dest->modified = 1 ;
+
     if (!clip)
     {
         clip = &base_clip ;
@@ -521,18 +678,29 @@
         clip->x2 = dest->width-1 ;
         clip->y2 = dest->height-1 ;
     }
+    else
+    {
+        base_clip = *clip ;
+        clip = &base_clip ;
+        clip->x = MAX(MIN(clip->x, clip->x2), 0) ;
+        clip->y = MAX(MIN(clip->y, clip->y2), 0) ;
+        clip->x2 = MIN(MAX(clip->x, clip->x2), dest->width - 1) ;
+        clip->y2 = MIN(MAX(clip->y, clip->y2), dest->height - 1) ;
+    }
 
-    dest->modified = 1 ;
-
-    if (w < 0) w = -w, x -= w ;
-    if (h < 0) h = -h, y -= h ;
+    if (w < 0) w = -w, x -= (w - 1) ;
+    if (h < 0) h = -h, y -= (h - 1) ;
 
     if (x < clip->x) w += x-clip->x, x = clip->x ;
     if (y < clip->y) h += y-clip->y, y = clip->y ;
-    if (x+w > clip->x2) w = clip->x2+1-x ;
-    if (y+h > clip->y2) h = clip->y2+1-y ;
 
-    if (w < 1 || h < 1) return ;
+    if (x + w > clip->x2) w = clip->x2 - x + 1 ;
+    if (y + h > clip->y2) h = clip->y2 - y + 1 ;
+
+    if (w < 0 || h < 0) return ;
+
+    if (!w) w++;
+    if (!h) h++;
 
     if (dest->depth == 8)
     {
@@ -547,17 +715,23 @@
     else if (dest->depth == 16)
     {
         Uint16 * ptr = dest->data ;
-        ptr += dest->pitch * y / 2 + x ;
+        int inc = dest->pitch / 2 ;
+        ptr += dest->pitch / 2 * y + x ;
         while (h--)
         {
             _HLine16_nostipple (ptr, w) ;
-            ptr += dest->pitch/2 ;
+            ptr += inc ;
         }
     }
     else if (dest->depth == 1)
     {
+        int old_stipple = drawing_stipple;
+        drawing_stipple = 0xFFFFFFFF;
+
         while (h--)
             gr_hline (dest, clip, x, y+h, w);
+
+        drawing_stipple = old_stipple;
     }
 }
 
@@ -582,18 +756,17 @@
 {
     int stipple = drawing_stipple;
 
-    if (w < 0) w = -w, x -= w ;
-    if (h < 0) h = -h, y -= h ;
+    dest->modified = 1;
+
+    if (w < 0) w = -w, x -= (w - 1);
+    if (h < 0) h = -h, y -= (h - 1);
+
+    if (w)                 gr_hline (dest, clip, x        , y        , w     ) ;
+    if ((w - 1) && h && w) gr_vline (dest, clip, x + w - 1, y        , h     ) ;
+    if ((h - 1) && w && h) gr_hline (dest, clip, x + w - 1, y + h - 1, -w    ) ;
+    if (h)                 gr_vline (dest, clip, x        , y + h - 1, -h    ) ;
 
-    gr_hline (dest, clip, x, y, w) ;
-    if (h > 1)
-        gr_vline (dest, clip, x+w-1, y, h) ;
     drawing_stipple = stipple;
-    if (w > 1 && h > 1)
-    {
-        gr_vline (dest, clip, x, y, h) ;
-        gr_hline (dest, clip, x, y+h-1, w) ;
-    }
 }
 
 /*
@@ -615,8 +788,9 @@
 void gr_circle (GRAPH * dest, REGION * clip, int x, int y, int r)
 {
     int cx = 0, cy = r ;
-    int lcx = -1, lcy = -1;
+    int lcy = -1;
     int df = 1-r, de = 3, dse = -2*r + 5 ;
+    int old_stipple = drawing_stipple;
     REGION base_clip ;
     int color = 0;
 
@@ -631,7 +805,8 @@
     }
 
     dest->modified = 1 ;
-    if (dest->depth == 8) {
+
+    if (dest->depth == 8 || dest->depth == 1) {
         color = syscolor8;
     } else if (dest->depth == 16) {
         color = syscolor16;
@@ -639,36 +814,34 @@
 
     do {
         if (drawing_stipple & 1) {
-
-            if (lcx != cx) {
                 gr_put_pixelc (dest, clip, x-cx, y-cy, color) ;
-                if (x-cx!=x+cx)
-                    gr_put_pixelc (dest, clip, x+cx, y-cy, color) ;
-                if (y-cy != y+cy) {
+            if (cx) gr_put_pixelc (dest, clip, x+cx, y-cy, color) ;
+
+            if (cy) {
                     gr_put_pixelc (dest, clip, x-cx, y+cy, color) ;
-                    if (x-cx!=x+cx)
-                        gr_put_pixelc (dest, clip, x+cx, y+cy, color) ;
+                if (cx) gr_put_pixelc (dest, clip, x+cx, y+cy, color) ;
                 }
-                if (y-cx != y-cy) {
+
+            if (cx != cy) {
                     gr_put_pixelc (dest, clip, x-cy, y-cx, color) ;
-                    if (x-cy!=x+cy)
-                        gr_put_pixelc (dest, clip, x+cy, y-cx, color) ;
+                if (cy) gr_put_pixelc (dest, clip, x+cy, y-cx, color) ;
                 }
-                if (y-cx != y+cx && y+cy != y+cx) {
+
+            if (cx && cy != cx) {
                     gr_put_pixelc (dest, clip, x-cy, y+cx, color) ;
-                    if (x-cy!=x+cy)
-                        gr_put_pixelc (dest, clip, x+cy, y+cx, color) ;
-                }
+                if (cy) gr_put_pixelc (dest, clip, x+cy, y+cx, color) ;
             }
         }
-        drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+        drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
 
-        lcx = cx; lcy = cy;
+        lcy = cy;
         cx++ ;
         if (df < 0) df += de,  de += 2, dse += 2 ;
         else        df += dse, de += 2, dse += 4, cy-- ;
     } while (cx <= cy) ;
 
+    drawing_stipple = old_stipple;
+
 }
 
 
@@ -691,31 +864,29 @@
 void gr_fcircle (GRAPH * dest, REGION * clip, int x, int y, int r)
 {
     int cx = 0, cy = r ;
-    int lcx = -1, lcy = -1;
     int df = 1-r, de = 3, dse = -2*r + 5 ;
     int old_stipple = drawing_stipple;
     drawing_stipple = 0xFFFFFFFF;
 
+    dest->modified = 1;
     do
     {
-        if (lcy != cy) {
-            gr_hline (dest, clip, x-cx, y-cy, 2*cx) ;
-            if (y-cy != y+cy)
-                gr_hline (dest, clip, x-cx, y+cy, 2*cx) ;
-        }
-        if (lcx != cx) {
-            if (y-cx != y-cy)
-                gr_hline (dest, clip, x-cy, y-cx, 2*cy) ;
-            if (y-cx != y+cx && y+cy != y+cx)
-                gr_hline (dest, clip, x-cy, y+cx, 2*cy) ;
+        if (cx != cy) {
+            gr_hline (dest, clip, x-cy, y-cx, 2*cy+1) ;
+            if (cx) gr_hline (dest, clip, x-cy, y+cx, 2*cy+1) ;
+        }
+        if (df < 0) {
+            df += de,  de += 2, dse += 2 ;
+        } else {
+            df += dse, de += 2, dse += 4;
+            gr_hline (dest, clip, x-cx, y-cy, 2*cx+1) ;
+            if (cy) gr_hline (dest, clip, x-cx, y+cy, 2*cx+1) ;
+            cy-- ;
         }
-
-        lcx = cx; lcy = cy;
         cx++ ;
-        if (df < 0) df += de,  de += 2, dse += 2 ;
-        else        df += dse, de += 2, dse += 4, cy-- ;
     }
     while (cx <= cy) ;
+
     drawing_stipple = old_stipple;
 }
 
@@ -740,6 +911,7 @@
     int n, m, hinc, vinc ;
     int i1, i2, dd ;
     REGION base_clip ;
+    int old_stipple = drawing_stipple;
 
     if (!w) {
         gr_vline (dest, clip, x, y, h) ;
@@ -764,42 +936,47 @@
 
     /* Clipping de la línea - INCORRECTO pero funcional */
 
+/* TODO: SE NECESITA CORREGIR CLIPPING EN LINE */
+#if 0
     if (x < clip->x) /* izquierda */
     {
-        if (x+w < clip->x) return;
+        if ((x + w) < clip->x) return ;
         n = clip->x - x ;
         m = w ? n*h/ABS(w) : 0;
         x += n, w -= n, y += m, h -= m ;
         if (w == 0) return;
     }
-    if (x+w < clip->x) /* w < 0 */
+    if ((x + w) < clip->x) /* w < 0 */
     {
-        n = clip->x - (x+w) ; m = w ? n*h/ABS(w) : 0 ;
+        n = clip->x - (x + w) ;
+        m = w ? n * h / ABS(w) : 0 ;
         w += n, h -= m ;
         if (w == 0) return;
     }
     if (y < clip->y) /* arriba */
     {
-        if (y+h < clip->y) return;
-        m = clip->y - y ; n = h ? m*w/ABS(h) : 0 ;
+        if ((y + h) < clip->y) return ;
+        m = clip->y - y ;
+        n = h ? m * w / ABS(h) : 0 ;
         x += n, w -= n, y += m, h -= m ;
         if (h == 0) return;
     }
-    if (y+h < clip->y) /* h < 0 */
+    if ((y + h) < clip->y) /* h < 0 */
     {
-        m = clip->y - (y+h) ; n = h ? m*w/ABS(h) : 0;
+        m = clip->y - (y + h) ;
+        n = h ? m * w / ABS(h) : 0 ;
         w -= n, h += m ;
         if (h == 0) return;
     }
     if (x > clip->x2) /* derecha */
     {
-        if (x+w > clip->x2) return;
+        if ((x + w) > clip->x2) return ;
         n = x - clip->x2 ;
         m = w ? n*h/ABS(w) : 0;
         x -= n, w += n, y += m, h -= m ;
         if (w == 0) return;
     }
-    if (x+w > clip->x2) /* w > 0 */
+    if ((x + w) > clip->x2) /* w > 0 */
     {
         n = (x+w) - clip->x2 ;
         m = w ? n*h/ABS(w) : 0;
@@ -808,22 +985,23 @@
     }
     if (y > clip->y2) /* abajo */
     {
-        if (y+h > clip->y2) return;
+        if ((y + h) > clip->y2) return ;
         m = y - clip->y2 ;
         n = m*w/ABS(h);
         x += n, w -= n, y -= m, h += m ;
         if (h == 0) return;
     }
-    if (y+h > clip->y2) /* h > 0 */
+
+    if ((y + h) > clip->y2) /* h > 0 */
     {
         m = (y+h) - clip->y2 ;
         n = h ? m*w/ABS(h) : 0;
         w -= n, h -= m ;
         if (h == 0) return;
     }
-
-    hinc = w > 0 ? 1:-1 ;
-    vinc = h > 0 ? dest->pitch:-(int)dest->pitch ;
+#endif
+    hinc = (w > 0) ? 1 : -1 ;
+    vinc = (h > 0) ? dest->pitch : -(int)dest->pitch ;
     if (dest->depth == 16) vinc /= 2;
 
     /* Aquí va una implementación deprisa y corriendo de Bresenham */
@@ -831,17 +1009,10 @@
     w = ABS(w) ;
     h = ABS(h) ;
 
-    if (w > h)
-    {
-        i1 = 2 * h ;
-        dd = i1 - w ;
-        i2 = dd - w ;
-    }
-    else
-    {
-        i1 = 2 * w ;
-        dd = i1 - h ;
-        i2 = dd - h ;
+    if (w > h) {
+        i1 = 2 * h ; dd = i1 - w ; i2 = dd - w ;
+    } else {
+        i1 = 2 * w ; dd = i1 - h ; i2 = dd - h ;
     }
 
     if (dest->depth == 8)
@@ -850,17 +1021,15 @@
 
         if (w > h) while (w--)
         {
-            if (drawing_stipple & 1)
-                _Pixel8(ptr, syscolor8) ;
-            drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+            if (drawing_stipple & 1) _Pixel8(ptr, syscolor8) ;
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
             if (dd >= 0) ptr += hinc+vinc, dd += i2 ;
             else         ptr += hinc,      dd += i1 ;
         }
         else while (h--)
         {
-            if (drawing_stipple & 1)
-                _Pixel8(ptr, syscolor8 ) ;
-            drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+            if (drawing_stipple & 1) _Pixel8(ptr, syscolor8) ;
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
             if (dd >= 0) ptr += vinc+hinc, dd += i2 ;
             else         ptr += vinc,      dd += i1 ;
         }
@@ -872,18 +1041,45 @@
         if (w > h) while (w--)
         {
             if (drawing_stipple & 1) _Pixel16(ptr, syscolor16, syscolor16_alpha) ;
-            drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
             if (dd >= 0) ptr += hinc+vinc, dd += i2 ;
             else         ptr += hinc,      dd += i1 ;
         }
         else while (h--)
         {
             if (drawing_stipple & 1) _Pixel16(ptr, syscolor16, syscolor16_alpha) ;
-            drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
             if (dd >= 0) ptr += vinc+hinc, dd += i2 ;
             else         ptr += vinc,      dd += i1 ;
         }
     }
+    else if(dest->depth == 1)
+    {
+        Uint8 * ptr = dest->data + dest->pitch * y + x / 8;
+        Uint8 mask, rmask ;
+        mask = (1 << (7-(x & 7)));
+
+        if (hinc < 0) rmask = 0x01 ; else rmask = 0x80 ;
+
+        if (w > h) while (w--)
+        {
+            if (drawing_stipple & 1) if (!syscolor8) *ptr &= ~mask; else *ptr |= mask;
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
+            if (dd >= 0) ptr += vinc, dd += i2 ;
+            else                      dd += i1 ;
+            if (hinc < 0) mask <<= 1; else mask >>= 1; if (!mask) mask = rmask, ptr += hinc ;
+        }
+        else while (h--)
+        {
+            if (drawing_stipple & 1) if (!syscolor8) *ptr &= ~mask ; else *ptr |= mask;
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
+            if (dd >= 0) { ptr += vinc, dd += i2 ; if (hinc < 0) mask <<= 1; else mask >>= 1; if (!mask) mask = rmask, ptr += hinc ; }
+            else           ptr += vinc, dd += i1 ;
+        }
+    }
+
+    drawing_stipple = old_stipple;
+
 }
 
 /*
@@ -929,14 +1125,13 @@
     int i;
     int n = 1;
 
+    dest->modified = 1;
+
     /* Compute number of iterations */
 
-    if(level < 1)
-        level=1;
-    if(level >= 15)
-        level=15;
-    while (level-- > 0)
-        n*= 2;
+    if(level < 1) level=1;
+    if(level >= 15) level=15;
+    while (level-- > 0) n*= 2;
     delta = 1.0f / (float)n;
 
     /* Compute finite differences */
@@ -993,6 +1188,7 @@
     switch (dr->type)
     {
         case DRAWOBJ_CIRCLE:
+        case DRAWOBJ_FCIRCLE:
             newclip.x  = dr->x1-dr->x2;
             newclip.y  = dr->y1-dr->x2;
             newclip.x2 = dr->x1+dr->x2;
@@ -1034,7 +1230,7 @@
  *
  */
 
-static void draw_object (DRAWING_OBJECT * dr, REGION * clip)
+void draw_object (DRAWING_OBJECT * dr, REGION * clip)
 {
     int b8 = syscolor8;
     int b16 = syscolor16;
@@ -1042,6 +1238,8 @@
     syscolor8 = dr->color8;
     syscolor16 = dr->color16;
 
+    if (drawing_alpha!=255) gr_setalpha(drawing_alpha);
+
     switch (dr->type)
     {
         case DRAWOBJ_LINE:
@@ -1165,8 +1363,7 @@
 
             dr->x1 += incx;
             dr->y1 += incy;
-            if (dr->type == DRAWOBJ_CIRCLE || dr->type == DRAWOBJ_FCIRCLE)
-                return;
+            if (dr->type == DRAWOBJ_CIRCLE || dr->type == DRAWOBJ_FCIRCLE) return;
             dr->x2 += incx;
             dr->y2 += incy;
             dr->x3 += incx;
@@ -1250,7 +1447,6 @@
         syscolor16 = c ;
     }
 
-    if (drawing_alpha != 255)
-        syscolor16_alpha = gr_alpha16(drawing_alpha)[syscolor16];
+    if (drawing_alpha != 255) syscolor16_alpha = gr_alpha16(drawing_alpha)[syscolor16];
 }
 
Index: fxi/src/g_font.c
===================================================================
--- fxi/src/g_font.c	2007-08-28 14:39:56.000000000 +0200
+++ fxi/src/g_font.c	2007-08-28 14:41:13.000000000 +0200
@@ -159,8 +159,7 @@
 		for (y = 0 ; y < height ; y++, ptr += bitmap->pitch)
 			memcpy (ptr, charptr + linesize*y, linesize);
 
-		if (bitmap->modified > 0)
-			bitmap->modified = 0 ;
+		if (bitmap->modified > 0) bitmap->modified = 0 ;
 		bitmap->info_flags = 0 ;
 	}
 
@@ -337,6 +336,7 @@
 	int types, i, id;
 	Uint32 y;
 	FONT * f;
+	PALETTE * pal = NULL;
 
 	struct
 	{
@@ -378,20 +378,20 @@
 	/* Read or ignore the palette */
 
 	if (bpp == 8)
-	{
-		if (palette_loaded)
-			file_seek (fp, 576 + 768, SEEK_CUR) ;
-		else
-			if (!gr_read_pal (fp)) return -1 ;
-	}
+	    if (!(pal = gr_read_pal_with_gamma (fp))) return -1 ;
 
 	/* Read the character data (detect old format) */
 
 	if (header[2] == 'x')
 	{
-		if (!file_readSint32(fp, &types)) return -1 ;
-		if (!file_read(fp, chardata, sizeof(chardata)))
+		if (!file_readSint32(fp, &types)) {
+		    pal_destroy(pal);
 			return -1 ;
+		}
+		if (!file_read(fp, chardata, sizeof(chardata))){
+		    pal_destroy(pal);
+		    return -1 ;
+		}
 		for (i = 0 ; i < 256 ; i++)
 		{
 			ARRANGE_DWORD (&chardata[i].width);
@@ -405,9 +405,14 @@
 	}
 	else
 	{
-		if (!file_readSint32(fp, &types)) return -1 ;
-		if (!file_read(fp, oldchardata, sizeof(oldchardata)))
+		if (!file_readSint32(fp, &types)) {
+		    pal_destroy(pal);
 			return -1 ;
+		}
+		if (!file_read(fp, oldchardata, sizeof(oldchardata))){
+		    pal_destroy(pal);
+		    return -1 ;
+		}
 		for (i = 0 ; i < 256 ; i++)
 		{
 			ARRANGE_DWORD (&oldchardata[i].width);
@@ -428,7 +433,11 @@
 	/* Create the font */
 
 	id = gr_font_new() ;
-	if (id == -1) return -1;
+	if (id == -1) {
+	    pal_destroy(pal);
+	    return -1 ;
+	}
+
 	f = fonts[id];
 	assert (f != 0) ;
 
@@ -453,31 +462,29 @@
 		f->glyph[i].xadvance = chardata[i].xadvance ;
 		f->glyph[i].yadvance = chardata[i].yadvance ;
 
-		if (chardata[i].fileoffset == 0 ||
-		    chardata[i].width      == 0 ||
-		    chardata[i].height     == 0) continue ;
+		if (chardata[i].fileoffset == 0 || chardata[i].width == 0 || chardata[i].height == 0) continue ;
 
 		f->glyph[i].xoffset = chardata[i].xoffset ;
 		f->glyph[i].yoffset = chardata[i].yoffset ;
 
 		file_seek (fp, chardata[i].fileoffset, SEEK_SET) ;
-		f->glyph[i].bitmap = gr = bitmap_new (i, chardata[i].width,
-			chardata[i].height, f->bpp, 1) ;
+		f->glyph[i].bitmap = gr = bitmap_new (i, chardata[i].width, chardata[i].height, f->bpp, 1) ;
 		assert (gr) ;
 		bitmap_add_cpoint (gr, 0, 0) ;
+		gr->palette = pal;
+		pal_use(pal);
 
 		for (y = 0, ptr = gr->data ; y < gr->height ; y++, ptr += gr->pitch)
 		{
-			if (!file_read (fp, ptr, gr->widthb))
-				break ;
-			if (gr->depth == 16)
-				gr_convert16_565ToScreen ((Uint16 *)ptr, gr->width);
+			if (!file_read (fp, ptr, gr->widthb)) break ;
+			if (gr->depth == 16) gr_convert16_565ToScreen ((Uint16 *)ptr, gr->width);
 		}
 
 		f->glyph[i].yoffset = chardata[i].yoffset ;
 	}
-	if (f->glyph[32].xadvance == 0)
-		f->glyph[32].xadvance = 4 ;
+	if (f->glyph[32].xadvance == 0) f->glyph[32].xadvance = 4 ;
+
+    pal_destroy(pal); // Elimino la instancia inicial
 
 	return id ;
 }
@@ -521,6 +528,7 @@
 		int	fileoffset ;
 	}
 	chardata[256] ;
+	int palette_saved = 0;
 
 	if (fontid < 0 || fontid > 255 || !fonts[fontid])
 	{
@@ -554,36 +562,42 @@
 	header[7] = font->bpp;
 	gzwrite (file, &header, 8);
 
+	/* Write the character information */
+
+	memset (chardata, 0, sizeof(chardata));
+	offset = 8 + 4 + ((font->bpp == 8) ? 576+768:0) + sizeof(chardata);
+
+	for (n = 0 ; n < 256 ; n++)
+	{
+		chardata[n].xadvance   = font->glyph[n].xadvance;
+		chardata[n].yadvance   = font->glyph[n].yadvance;
+
+		if (font->glyph[n].bitmap)
+		{
 	/* Write the palette */
 
-	if (font->bpp == 8)
+           	if (!palette_saved && font->bpp == 8)
 	{
 		Uint8   colors[256][3];
 		Uint8 * block = calloc(576,1) ;
+        		SDL_Color * gpal = palette ;
+        		int k;
 
-		for (n = 1 ; n < 256 ; n++)
-		{
-			colors[n][0] = palette[n].r >> 2 ;
-			colors[n][1] = palette[n].g >> 2 ;
-			colors[n][2] = palette[n].b >> 2 ;
+                if (font->glyph[n].bitmap->palette) gpal = font->glyph[n].bitmap->palette->rgb; else gpal = palette;
+
+                /* Generate palette info */
+                for (k = 0 ; k < 256 ; k++) {
+                    colors[k][0] = gpal[k].r >> 2 ;
+                    colors[k][1] = gpal[k].g >> 2 ;
+                    colors[k][2] = gpal[k].b >> 2 ;
 		}
+
 		gzwrite (file, &colors, 768) ;
 		gzwrite (file, block, 576) ;
 		free(block) ;
+        		palette_saved = 1;
 	}
 
-	/* Write the character information */
-
-	memset (chardata, 0, sizeof(chardata));
-	offset = 8 + 4 + (font->bpp == 8 ? 576+768:0) + sizeof(chardata);
-
-	for (n = 0 ; n < 256 ; n++)
-	{
-		chardata[n].xadvance   = font->glyph[n].xadvance;
-		chardata[n].yadvance   = font->glyph[n].yadvance;
-
-		if (font->glyph[n].bitmap)
-		{
 			chardata[n].width      = font->glyph[n].bitmap->width;
 			chardata[n].height     = font->glyph[n].bitmap->height;
 			chardata[n].xadvance   = font->glyph[n].xadvance;
@@ -592,8 +606,7 @@
 			chardata[n].yoffset    = font->glyph[n].yoffset;
 			chardata[n].fileoffset = offset;
 
-			offset += font->glyph[n].bitmap->widthb
-				    * chardata[n].height;
+			offset += font->glyph[n].bitmap->widthb * chardata[n].height;
 		}
 
 		ARRANGE_DWORD (&chardata[n].xadvance);
@@ -653,8 +666,7 @@
 				}
 			}
 
-			if (gr->depth == 16)
-				free(block);
+			if (gr->depth == 16) free(block);
 		}
 	}
 
@@ -701,6 +713,7 @@
 	int xadvance = 0;
 	int yadvance = 0;
 	int minyoffset = 0;
+	int len;
 
 	/* Arrays used to convert hex ASCII to binary */
 
@@ -737,8 +750,8 @@
 
 	for (line[2047] = 0 ; ; )
 	{
-		if (!file_gets (fp, line, 2047))
-			break;
+		if (!(len = file_gets (fp, line, 2047))) break;
+		if (line[len-1] == '\n') line[len-1] = '\0';
 
 		/* Handle global-level commands */
 
@@ -799,27 +812,22 @@
 				font->glyph[encoding].xoffset  = xoffset;
 				font->glyph[encoding].yoffset  = -yoffset-height;
 
-				if (minyoffset > -yoffset-height)
-					minyoffset = -yoffset-height;
+				if (minyoffset > -yoffset-height) minyoffset = -yoffset-height;
 
 				error = 1;
 				font->glyph[encoding].bitmap = bitmap_new (encoding, width, height, 1, 1);
-				if (font->glyph[encoding].bitmap == 0)
-					break;
+				if (font->glyph[encoding].bitmap == 0) break;
 				bitmap_add_cpoint (font->glyph[encoding].bitmap, 0, 0) ;
 
-				if (font->maxwidth < width)
-					font->maxwidth = width;
-				if (font->maxheight < height)
-					font->maxheight = height;
+				if (font->maxwidth < width) font->maxwidth = width;
+				if (font->maxheight < height) font->maxheight = height;
 
 				for (y = 0 ; y < height ; y++)
 				{
-					if (!file_gets (fp, line, 2047))
-						break;
+					if (!(len=file_gets (fp, line, 2047))) break;
+					if (line[len-1] == '\n') line[len-1] = '\0';
 					ptr  = line;
-					optr = (Uint8 *)font->glyph[encoding].bitmap->data +
-						   font->glyph[encoding].bitmap->pitch * y;
+					optr = (Uint8 *)font->glyph[encoding].bitmap->data + font->glyph[encoding].bitmap->pitch * y;
 
 					for (x = 0 ; x < width ; x += 8)
 					{
@@ -869,7 +877,6 @@
 
 FONT * gr_font_get (int id)
 {
-	if (id >= 0 && id <= 255)
-		return fonts[id];
+	if (id >= 0 && id <= 255) return fonts[id];
 	return NULL;
 }
Index: fxi/src/g_fpg.c
===================================================================
--- fxi/src/g_fpg.c	2007-08-28 14:39:56.000000000 +0200
+++ fxi/src/g_fpg.c	2007-08-28 14:41:13.000000000 +0200
@@ -128,8 +128,7 @@
 
 GRLIB * grlib_get (int libid)
 {
-	if (libid < 0 || libid >= lib_nextid)
-		return 0 ;
+	if (libid < 0 || libid >= lib_nextid) return 0 ;
 	return libs[libid] ;
 }
 
@@ -312,17 +311,7 @@
 	int libid ;
 	file * fp = file_open (libname, "rb") ;
 
-	if (!fp)
-	{
-#ifdef WIN32
-		char buffer[2048];
-		GetCurrentDirectory(2048, buffer);
-		gr_error (_("'%s': Library not found in %s\n"), libname, buffer) ;
-#else
-		gr_error (_("'%s': Library not found\n"), libname) ;
-#endif
-		return -1 ;
-	}
+	if (!fp) return -1 ;
 	libid = gr_read_lib (fp) ;
 	file_close (fp) ;
 	return libid ;
@@ -338,6 +327,7 @@
 	unsigned c;
 	GRLIB * lib ;
 	GRAPH * gr ;
+	PALETTE * pal = NULL ;
 
 	struct
 	{
@@ -366,13 +356,7 @@
 	else
 		return 0 ;
 
-	if (bpp == 8)
-	{
-		if (palette_loaded)
-			file_seek (fp, 576 + 768, SEEK_CUR) ;
-		else if (!gr_read_pal (fp))
-			return 0 ;
-	}
+	if (bpp == 8 && !(pal = gr_read_pal_with_gamma (fp))) return 0 ;
 
 	while (!file_eof(fp))
 	{
@@ -387,7 +371,11 @@
 		/* Cabecera del gráfico */
 
 		gr = bitmap_new (chunk.code, chunk.width, chunk.height, bpp, 1);
-		if (!gr) return 0 ;
+		if (!gr) {
+		    grlib_destroy (libid) ;
+            pal_destroy (pal) ; // Elimino la instancia inicial
+		    return 0 ;
+		}
 		memcpy (gr->name, chunk.name, 32) ;
 		gr->name[31] = 0 ;
 		gr->ncpoints = chunk.flags ;
@@ -398,7 +386,11 @@
 		if (gr->ncpoints)
 		{
 			gr->cpoints = (CPOINT *) malloc(gr->ncpoints * sizeof(CPOINT)) ;
-			if (!gr->cpoints) { free(gr) ; return 0 ; }
+			if (!gr->cpoints) {
+                bitmap_destroy (gr) ;
+                pal_destroy (pal) ;
+			    return 0 ;
+			}
 			for (c = 0 ; c < gr->ncpoints ; c++)
 			{
 				file_readSint16 (fp, &px) ;
@@ -426,20 +418,23 @@
 			Uint8 * ptr = (Uint8 *)gr->data + gr->pitch*y;
 			if (!file_read (fp, ptr, len))
 			{
-				free (gr) ;
+				bitmap_destroy (gr) ;
+    		    grlib_destroy (libid) ;
 				break ;
 			}
 			if (bpp == 16)
 			{
 				ARRANGE_WORDS (ptr, len/2);
-				if (scr_initialized)
-					gr_convert16_565ToScreen ((Uint16 *)ptr, len/2);
+				if (scr_initialized) gr_convert16_565ToScreen ((Uint16 *)ptr, len/2) ;
 			}
 		}
 
-
 		grlib_add_map (libid, gr) ;
+        pal_map_assign (libid, gr, pal) ;
 	}
+
+    pal_destroy (pal) ; // Elimino la instancia inicial
+
 	return libid ;
 }
 
@@ -458,9 +453,6 @@
 
 void grlib_init()
 {
-	if (!syslib)
-	{
-		syslib = grlib_create() ;
-	}
+	if (!syslib) syslib = grlib_create() ;
 }
 
Index: fxi/src/g_main.c
===================================================================
--- fxi/src/g_main.c	2007-08-28 14:39:56.000000000 +0200
+++ fxi/src/g_main.c	2007-08-28 14:41:13.000000000 +0200
@@ -111,7 +111,7 @@
 
 static int sdl_equiv[SDLK_LAST+1] ;
 key_equiv key_table[127] ;  /* Now we have a search table with equivs */
-unsigned char * keystate ;        /* Pointer to key states */
+unsigned char * keystate = NULL;        /* Pointer to key states */
 int keystate_size = 0 ;
 
 static int equivs[] =
@@ -302,9 +302,6 @@
 
 REGION    regions[32] ;
 
-#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
-#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
-
 /*
  *  FUNCTION : region_define
  *
@@ -599,7 +596,7 @@
     /* Reset ascii and scancode if last key was released... */
     /* must check all the linked equivs */
 
-    if (show_console == 0) memcpy (keystate, SDL_GetKeyState(NULL), keystate_size) ;
+    if (show_console == 0 && keystate) memcpy (keystate, SDL_GetKeyState(NULL), keystate_size) ;
 
     GLODWORD(MOUSEWHEELUP)   = 0 ;
     GLODWORD(MOUSEWHEELDOWN) = 0 ;
@@ -623,8 +620,13 @@
         switch (e.type)
         {
             case SDL_MOUSEMOTION:
+                if (enable_scale || scale_mode != SCALE_NONE) {
+                    GLODWORD(MOUSEX) = e.motion.x / 2 ;
+                    GLODWORD(MOUSEY) = e.motion.y / 2 ;
+                } else {
                 GLODWORD(MOUSEX) = e.motion.x ;
                 GLODWORD(MOUSEY) = e.motion.y ;
+                }
                 break ;
 /*
             case SDL_JOYAXISMOTION:
@@ -716,8 +718,7 @@
                     }
                     if (e.key.keysym.sym == SDLK_p)
                     {
-                        if (!show_console)
-                            show_profile = !show_profile;
+                        if (!show_console) show_profile = !show_profile;
                         background_dirty = 1;
                         break ;
                     }
@@ -870,8 +871,8 @@
     /* Now actualized every frame... */
     GLODWORD(SHIFTSTATUS) = ((m & KMOD_LSHIFT)                    ? 1 : 0) +
                             ((m & KMOD_RSHIFT)                    ? 2 : 0) +
-                            ((m & KMOD_RCTRL) || (m & KMOD_LCTRL) ? 4 : 0) +
-                            ((m & KMOD_LALT)  || (m & KMOD_RALT)  ? 8 : 0)  ;
+                            (((m & KMOD_RCTRL) || (m & KMOD_LCTRL)) ? 4 : 0) +
+                            (((m & KMOD_LALT)  || (m & KMOD_RALT))  ? 8 : 0) ;
 
     last_mouse_x = GLODWORD(MOUSEX) ;
     last_mouse_y = GLODWORD(MOUSEY) ;
@@ -1055,7 +1056,8 @@
     }
 
     // PATCH - XGRAPH DOES NOT ROTATE DESTINATION GRAPHIC
-    if (LOCDWORD(i,ANGLE) || scalex != 100 || scaley != 100) {
+    if ((map->current_keyframe >= 0 && map->keyframes[map->current_keyframe].angle) ||
+        LOCDWORD(i,ANGLE) || scalex != 100 || scaley != 100) {
         if (LOCDWORD(i,XGRAPH) && scalex == 100 && scaley == 100) {
             gr_blit (0, region, x, y, flags, map) ;
         } else {
@@ -1117,7 +1119,8 @@
     fclip = regions[r];
     if (clip) region_union (&fclip, clip);
 
-    if (LOCDWORD(i,ANGLE) || scalex != 100 || scaley != 100) {
+    if ((map->current_keyframe >= 0 && map->keyframes[map->current_keyframe].angle) ||
+        LOCDWORD(i,ANGLE) || scalex != 100 || scaley != 100) {
         if (LOCDWORD(i,XGRAPH) && scalex == 100 && scaley == 100) {
             gr_blit (0, &regions[r], x, y, flags, map) ;
         } else {
@@ -1198,7 +1201,8 @@
     region = regions[r];
     if (clip) region_union (&region, clip);
 
-    if (GLODWORD(MOUSEANGLE) || GLODWORD(MOUSESIZE) != 100)
+    if ((map->current_keyframe >= 0 && map->keyframes[map->current_keyframe].angle) ||
+        GLODWORD(MOUSEANGLE) || GLODWORD(MOUSESIZE) != 100)
         gr_rotated_blit (0, &region, GLODWORD(MOUSEX),
                          GLODWORD(MOUSEY), GLODWORD(MOUSEFLAGS),
                          GLODWORD(MOUSEANGLE), GLODWORD(MOUSESIZE),
@@ -1311,9 +1315,10 @@
         first_dll_object = object->next;
         if (object->x.bbox.x == -2)
             (*object->x.info)(object->x.what, &object->x.bbox);
+
         gr_mark_rect (object->x.bbox.x, object->x.bbox.y,
-                      object->x.bbox.x2 - object->x.bbox.x + 1,
-                      object->x.bbox.y2 - object->x.bbox.y + 1);
+                      object->x.bbox.x2 - object->x.bbox.x,
+                      object->x.bbox.y2 - object->x.bbox.y);
         free (object);
         dll_object_count--;
     }
@@ -1323,11 +1328,10 @@
         {
             next = object->next;
             object->next = next->next;
-            if (next->x.bbox.x == -2)
-                (*next->x.info)(next->x.what, &next->x.bbox);
+            if (next->x.bbox.x == -2) (*next->x.info)(next->x.what, &next->x.bbox);
             gr_mark_rect (next->x.bbox.x, next->x.bbox.y,
-                          next->x.bbox.x2 - next->x.bbox.x + 1,
-                          next->x.bbox.y2 - next->x.bbox.y + 1);
+                          next->x.bbox.x2 - next->x.bbox.x,
+                          next->x.bbox.y2 - next->x.bbox.y);
             free (next);
             dll_object_count--;
             break;
@@ -1338,8 +1342,7 @@
 
 int compare_actions (const OBJECT * a1, const OBJECT * a2)
 {
-    return (a1->z == a2->z ? a1->id - a2->id : a2->z - a1->z) ;
-//    return (a2->z - a1->z) ;
+    return ((a1->z == a2->z) ? a1->id - a2->id : a2->z - a1->z) ;
 }
 
 void draw_mode7 (void * ptr, REGION * clip)
@@ -1414,9 +1417,14 @@
     w = scr_width / 16;
     h = scr_height / 8;
 
-    for (cx = x/w*w ; cx < x+width ; cx += w)
+    x = MIN(x, x + width);
+    y = MIN(y, y + height);
+    width = ABS(width);
+    height = ABS(height);
+
+    for (cx = x / w * w ; cx <= x + width ; cx += w)
     {
-        for (cy = y/h*h ; cy < y+height ; cy += h)
+        for (cy = y / h * h ; cy <= y + height ; cy += h)
         {
             if (cx/w < 16 && cx/w >= 0)
                 zonearray[cx/w] |= (1 << (cy / h));
@@ -1438,19 +1446,7 @@
 
 void gr_mark_instance (INSTANCE * r)
 {
-    int x, y, w, h;
-
-    w = scr_width / 16;
-    h = scr_height / 8;
-
-    for (x = LOCDWORD(r, BOX_X0)/w*w ; x <= LOCDWORD(r, BOX_X1) ; x += w)
-    {
-        for (y = LOCDWORD(r, BOX_Y0)/h*h ; y <= LOCDWORD(r, BOX_Y1) ; y += h)
-        {
-            if (x/w < 16 && x/w >= 0)
-                zonearray[x/w] |= (1 << (y / h));
-        }
-    }
+    gr_mark_rect(LOCDWORD(r, BOX_X0), LOCDWORD(r, BOX_Y0), LOCDWORD(r, BOX_X1)-LOCDWORD(r, BOX_X0), LOCDWORD(r, BOX_Y1)-LOCDWORD(r, BOX_Y0));
 }
 
 /*
@@ -1491,44 +1487,21 @@
 
             if (onlychanged)
             {
-                if ((LOCDWORD(r,CHANGED) = instance_poschanged(r)) == 0)
-                    continue;
+                if ((LOCDWORD(r,CHANGED) = instance_poschanged(r)) == 0) continue;
 
                 /* Mark the previous position */
-
-                for (x = LOCDWORD(r, BOX_X0)/w*w ; x <= LOCDWORD(r, BOX_X1) ; x += w)
-                {
-                    for (y = LOCDWORD(r, BOX_Y0)/h*h ; y <= LOCDWORD(r, BOX_Y1) ; y += h)
-                    {
-                        if (x/w < 16 && x/w >= 0)
-                            zonearray[x/w] |= (1 << (y / h));
-                    }
-                }
+                gr_mark_rect(LOCDWORD(r, BOX_X0), LOCDWORD(r, BOX_Y0), LOCDWORD(r, BOX_X1)-LOCDWORD(r, BOX_X0), LOCDWORD(r, BOX_Y1)-LOCDWORD(r, BOX_Y0));
 
                 /* Update and mark the new position */
                 instance_posupdate(r);
                 instance_update_bbox (r);
 
-                for (x = LOCDWORD(r, BOX_X0)/w*w ; x <= LOCDWORD(r, BOX_X1) ; x += w)
-                {
-                    for (y = LOCDWORD(r, BOX_Y0)/h*h ; y <= LOCDWORD(r, BOX_Y1) ; y += h)
-                    {
-                        if (x/w < 16 && x/w >= 0)
-                            zonearray[x/w] |= (1 << (y / h));
-                    }
-                }
+                gr_mark_rect(LOCDWORD(r, BOX_X0), LOCDWORD(r, BOX_Y0), LOCDWORD(r, BOX_X1)-LOCDWORD(r, BOX_X0), LOCDWORD(r, BOX_Y1)-LOCDWORD(r, BOX_Y0));
             }
             else
             {
                 /* Mark the current position (next frame, the next will be marked */
-                for (x = LOCDWORD(r, BOX_X0)/w*w ; x <= LOCDWORD(r, BOX_X1) ; x += w)
-                {
-                    for (y = LOCDWORD(r, BOX_Y0)/h*h ; y <= LOCDWORD(r, BOX_Y1) ; y += h)
-                    {
-                        if (x/w < 16 && x/w >= 0)
-                            zonearray[x/w] |= (1 << (y / h));
-                    }
-                }
+                gr_mark_rect(LOCDWORD(r, BOX_X0), LOCDWORD(r, BOX_Y0), LOCDWORD(r, BOX_X1)-LOCDWORD(r, BOX_X0), LOCDWORD(r, BOX_Y1)-LOCDWORD(r, BOX_Y0));
 
                 /* Update the bounding box */
                 instance_update_bbox (r);
@@ -1543,24 +1516,17 @@
 
             if (!onlychanged || object_list[i].changed)
             {
-                for (x = region.x/w*w ; x <= region.x2 ; x += w)
-                    for (y = region.y/h*h ; y <= region.y2 ; y += h)
-                    {
-                        if (x/w < 16 && x/w >= 0)
-                            zonearray[x/w] |= (1 << (y / h));
-                    }
+                gr_mark_rect (region.x,region.y,region.x2-region.x,region.y2-region.y);
             }
 
             /* Mark updated object position */
 
             if (object_list[i].changed)
             {
-                for (x = object_list[i].bbox.x/w*w ; x <= object_list[i].bbox.x2 ; x += w)
-                    for (y = object_list[i].bbox.y/h*h ; y <= object_list[i].bbox.y2 ; y += h)
-                    {
-                        if (x/w < 16 && x/w >= 0)
-                            zonearray[x/w] |= (1 << (y / h));
-                    }
+                gr_mark_rect (object_list[i].bbox.x,
+                              object_list[i].bbox.y,
+                              object_list[i].bbox.x2-object_list[i].bbox.x,
+                              object_list[i].bbox.y2-object_list[i].bbox.y);
             }
         }
     }
@@ -1630,11 +1596,9 @@
                 {
                     /* Si hay algun hueco, entonces corto aca, ahora vuelve a entrar y esto entra en otra recta */
                     for (x2 = x ; x2 < x+cw ; x2++)
-                        if (!(zonearray[x2] & (1 << (y+ch))))
-                            break;
+                        if (!(zonearray[x2] & (1 << (y + ch)))) break;
 
-                    if (x2 < x+cw)
-                        break;
+                    if (x2 < x+cw) break;
 
                     for (x2 = x ; x2 < x+cw ; x2++)
                         zonearray[x2] &= ~(1 << (y+ch));
@@ -1872,19 +1836,18 @@
         gr_mark_instances (dump_type == 0);
         n = updaterects_count = gr_mark_rects (updaterects);
 
-        /* Reset the zone-to-update array for the next frame */
-        memset (zonearray, 0, 128/8);
-
-        gr_setcolor (0);
         for (a = 0 ; a < n ; a++)
         {
             if (background_is_black)
-                gr_box (dest, &updaterects[a], 0, 0, 9999, 9999) ;
+                gr_clear_region (scrbitmap, &updaterects[a]);
             else if (enable_16bits && background_8bits_used)
                 gr_blit (scrbitmap, &updaterects[a], 0, 0, B_NOCOLORKEY, background_8bits);
             else
                 gr_blit (scrbitmap, &updaterects[a], 0, 0, B_NOCOLORKEY, background);
         }
+
+        /* Reset the zone-to-update array for the next frame */
+        memset (zonearray, 0, 128/8);
     }
 
     gprof_end ("Background");
@@ -1903,18 +1866,18 @@
                 if (object_list[a].draw == draw_instance)
                 {
                     INSTANCE * i = (INSTANCE *)object_list[a].what;
-                    if (LOCDWORD(i,BOX_X1) < updaterects[n].x ||
-                        LOCDWORD(i,BOX_X0) > updaterects[n].x2 ||
-                        LOCDWORD(i,BOX_Y1) < updaterects[n].y ||
-                        LOCDWORD(i,BOX_Y0) > updaterects[n].y2)
+                    if (MAX(LOCDWORD(i,BOX_X0),LOCDWORD(i,BOX_X1)) < updaterects[n].x ||
+                        MIN(LOCDWORD(i,BOX_X0),LOCDWORD(i,BOX_X1)) > updaterects[n].x2 ||
+                        MAX(LOCDWORD(i,BOX_Y0),LOCDWORD(i,BOX_Y1)) < updaterects[n].y ||
+                        MIN(LOCDWORD(i,BOX_Y0),LOCDWORD(i,BOX_Y1)) > updaterects[n].y2)
                         continue;
                 }
                 else
                 {
-                    if (object_list[a].bbox.x2 < updaterects[n].x ||
-                        object_list[a].bbox.x  > updaterects[n].x2 ||
-                        object_list[a].bbox.y2 < updaterects[n].y ||
-                        object_list[a].bbox.y  > updaterects[n].y2)
+                    if (MAX(object_list[a].bbox.x,object_list[a].bbox.x2) < updaterects[n].x ||
+                        MIN(object_list[a].bbox.x,object_list[a].bbox.x2) > updaterects[n].x2 ||
+                        MAX(object_list[a].bbox.y,object_list[a].bbox.y2) < updaterects[n].y ||
+                        MIN(object_list[a].bbox.y,object_list[a].bbox.y2) > updaterects[n].y2)
                         continue;
                 }
                 (*object_list[a].draw) (object_list[a].what, &updaterects[n]) ;
@@ -1960,11 +1923,19 @@
 
         /* Fading */
 
-        if (fade_on != 0)
+        if (fade_on || fade_set)
         {
             gr_fade_step() ;
             background_dirty = 1;
         }
+    } else {
+        /* Muestro consola, marco toda la pantalla */
+
+        updaterects_count = 1;
+        updaterects[0].x = 0;
+        updaterects[0].y = 0;
+        updaterects[0].x2 = scr_width-1;
+        updaterects[0].y2 = scr_height-1;
     }
 
     /* Visualiza la consola */
@@ -1972,8 +1943,7 @@
     gr_con_show(show_console) ;
     gr_con_draw() ;
 
-    if (show_profile)
-        gprof_draw (scrbitmap);
+    if (show_profile) gprof_draw (scrbitmap);
 
     /* Actualiza la paleta y la pantalla */
 
@@ -1983,7 +1953,7 @@
 
 }
 
-/* FUnción de inicialización de la librería gráfica */
+/* Función de inicialización de la librería gráfica */
 
 static int screen_locked = 0 ;
 
@@ -1992,11 +1962,12 @@
     if (screen_locked) return 1 ;
     screen_locked = 1 ;
 
-    if (SDL_LockSurface (screen) < 0)
-        return -1 ;
+    if (SDL_LockSurface (screen) < 0) return -1 ;
 
     if ( (!enable_scale && scale_mode == SCALE_NONE) && !double_buffer)
     {
+        if (scrbitmap && !scrbitmap_is_fake) free (scrbitmap->data) ;
+
         if (!scrbitmap)
         {
             scrbitmap = bitmap_new (0, screen->w, screen->h, enable_16bits ? 16:8, 1) ;
@@ -2023,6 +1994,12 @@
     }
     else
     {
+        if (scrbitmap && scrbitmap_is_fake)
+        {
+            bitmap_destroy_fake (scrbitmap) ;
+            scrbitmap = NULL ;
+        }
+
         scrbitmap_is_fake = 0 ;
 
         if (!scrbitmap)
@@ -2042,6 +2019,7 @@
 {
     int     a ;
     GRAPH   * scr;
+    int     m = 1;
 
     if (!screen_locked) return ;
     screen_locked = 0 ;
@@ -2050,10 +2028,9 @@
     if (enable_scale || scale_mode != SCALE_NONE)
     {
         int aux_scale_mode;
+        m = 2;
 
-        if (enable_scale || GLODWORD(SCALE_MODE) != SCALE_NONE ) {
-            scale_mode     = GLODWORD(SCALE_MODE);
-        }
+        if (enable_scale || GLODWORD(SCALE_MODE) != SCALE_NONE ) scale_mode = GLODWORD(SCALE_MODE);
         aux_scale_mode = (scale_mode != SCALE_NONE) ? scale_mode : SCALE_SCALE2X;
 
         if (scrbitmap->depth == 8)
@@ -2062,12 +2039,11 @@
             Uint16 * extra;
             int length = scrbitmap->width * scrbitmap->height, n;
 
-            if (scrbitmap_extra == NULL
-                || scrbitmap_extra->width != scrbitmap->width
-                || scrbitmap_extra->height != scrbitmap->height)
+            if (scrbitmap_extra         == NULL             ||
+                scrbitmap_extra->width  != scrbitmap->width ||
+                scrbitmap_extra->height != scrbitmap->height)
             {
-                if (scrbitmap_extra)
-                    bitmap_destroy (scrbitmap_extra);
+                if (scrbitmap_extra) bitmap_destroy (scrbitmap_extra);
                 scrbitmap_extra = bitmap_new (0, scrbitmap->width, scrbitmap->height, 16, 1);
             }
 
@@ -2088,49 +2064,40 @@
         /* Esto podria ir en un modulo aparte */
         switch ( aux_scale_mode ) {
             case    SCALE_SCALE2X:
-                    scale2x (scr->data, scr->pitch,
-                             screen->pixels, screen->pitch,
-                             scr->width, scr->height);
+                    scale2x (scr->data, scr->pitch, screen->pixels, screen->pitch, scr->width, scr->height);
                     break;
 
             case    SCALE_HQ2X:
-                    hq2x (scr->data, scr->pitch,
-                          screen->pixels, screen->pitch,
-                          scr->width, scr->height);
+                    hq2x (scr->data, scr->pitch, screen->pixels, screen->pitch, scr->width, scr->height);
                     break;
 
             case    SCALE_SCANLINE2X:
-                    scanline2x (scr->data, scr->pitch,
-                                screen->pixels, screen->pitch,
-                                scr->width, scr->height);
+                    scanline2x (scr->data, scr->pitch, screen->pixels, screen->pitch, scr->width, scr->height);
                     break;
 
             case    SCALE_NOFILTER:
-                    scale_normal2x (scr->data, scr->pitch,
-                                    screen->pixels, screen->pitch,
-                                    scr->width, scr->height);
+                    scale_normal2x (scr->data, scr->pitch, screen->pixels, screen->pitch, scr->width, scr->height);
                     break;
 
             case    SCALE_NONE:
                     /* No usado */
                     break;
         }
+
         SDL_UnlockSurface (screen) ;
-        SDL_UpdateRect (screen, 0, 0, 0, 0) ;
+        SDL_Flip(screen) ;
+
+/*        SDL_UpdateRect (screen, 0, 0, 0, 0) ; */
     }
     else if (scrbitmap_is_fake)
     {
         SDL_UnlockSurface (screen) ;
 
-        scrbitmap->data = 0 ;
+/*        scrbitmap->data = 0 ;
         if (double_buffer)
             SDL_Flip(screen) ;
-        else
-        {
-            if (updaterects_count == 0)
-                /* Nothing to update! */ ;
-            else
-            {
+        else */
+        if (updaterects_count) {
                 SDL_Rect rects[128];
                 int i;
 
@@ -2138,14 +2105,11 @@
                 {
                     rects[i].x = updaterects[i].x;
                     rects[i].y = updaterects[i].y;
-                    rects[i].w = updaterects[i].x2 - rects[i].x + 1;
-                    rects[i].h = updaterects[i].y2 - rects[i].y + 1;
+                rects[i].w = (updaterects[i].x2 - rects[i].x + 1);
+                rects[i].h = (updaterects[i].y2 - rects[i].y + 1);
                 }
                 SDL_UpdateRects (screen, updaterects_count, rects) ;
             }
-            SDL_UnlockSurface (screen) ;
-            SDL_UpdateRect (screen, 0, 0, 0, 0) ;
-        }
     }
     else
     {
@@ -2198,7 +2162,8 @@
         }
 
         SDL_UnlockSurface (screen) ;
-        SDL_UpdateRect (screen, 0, 0, 0, 0) ;
+        SDL_Flip(screen) ;
+/*        SDL_UpdateRect (screen, 0, 0, 0, 0) ; */
     }
 }
 
@@ -2235,7 +2200,7 @@
     if (scr_initialized && scrbitmap)
     {
         if (scrbitmap_is_fake)
-            free (scrbitmap) ;
+            bitmap_destroy_fake (scrbitmap) ;
         else
             bitmap_destroy (scrbitmap) ;
 
@@ -2355,6 +2320,8 @@
     regions[0].x2 = width-1 ;
     regions[0].y2 = height-1 ;
 
+    if (enable_16bits) pal_refresh(NULL) ;
+
     /* Bitmaps de fondo */
 
     if (!background || scr_width != width || scr_height != height)
@@ -2384,10 +2351,11 @@
     scr_width = width ;
     scr_height = height ;
 
+    SDL_WarpMouse(scr_width / 2, scr_height / 2);
+
     /* Paleta de colores por defecto */
 
-    if (!palette_loaded)
-    {
+    if (!palette_loaded) {
         for (n = 0 ; n < 256 ; n++)
             gr_set_rgb (n, default_palette[n*3]/4, default_palette[n*3+1]/4, default_palette[n*3+2]/4) ;
     }
Index: fxi/src/g_maps.c
===================================================================
--- fxi/src/g_maps.c	2007-08-28 14:39:56.000000000 +0200
+++ fxi/src/g_maps.c	2007-08-28 14:41:13.000000000 +0200
@@ -128,6 +128,8 @@
 	gr->prev             = NULL;
 	gr->current_keyframe = -1;
 
+	gr->palette          = NULL ;
+
 	if (first)
 		first->prev = gr;
 	first = gr;
@@ -185,6 +187,8 @@
 	gr->offset = map->offset ;
 	gr->info_flags = map->info_flags ;
 	gr->modified = map->modified ;
+	gr->palette = map->palette ;
+	pal_use(map->palette);
 	memcpy (gr->name, map->name, sizeof(map->name)) ;
 	return gr ;
 }
@@ -256,10 +260,29 @@
 	if (map->keyframes) free(map->keyframes);
 	if (map->sequences) free(map->sequences);
 
+	pal_destroy(map->palette);
+
 	free (map->data) ;
 	free (map) ;
 }
 
+void bitmap_destroy_fake (GRAPH * map)
+{
+    if (!map) return;
+
+    if (map->prev) map->prev->next = map->next;
+    if (map->next) map->next->prev = map->prev;
+/*  if (map->next_time) map->next->prev = map->next; */
+    if (first == map) first = map->next;
+
+    if (map->cpoints) free(map->cpoints);
+    if (map->keyframes) free(map->keyframes);
+    if (map->sequences) free(map->sequences);
+
+    pal_destroy(map->palette);
+
+    free (map) ;
+}
 
 static GRAPH * gr_read_map (file * fp)
 {
@@ -269,6 +292,7 @@
 	int depth, code ;
 	GRAPH * gr ;
 	int len;
+	PALETTE * pal = NULL;
 
 	/* Carga los datos de cabecera */
 
@@ -280,25 +304,23 @@
 	else if (strcmp (header, M01_MAGIC) == 0)
 		depth = 1 ;
 	else
-		return 0 ;
+		return NULL ;
 
 	file_readUint16 (fp, &w) ;
 	file_readUint16 (fp, &h) ;
 	file_readSint32 (fp, &code) ;
 
 	gr = bitmap_new (code, w, h, depth, 1) ;
-	if (!gr) return 0 ;
+	if (!gr) return NULL ;
 	file_read (fp, gr->name, 32) ;
 	gr->name[31] = 0 ;
 
 	/* Datos de paleta */
 
 	if (gr->depth == 8)
-	{
-		if (palette_loaded)
-			file_seek (fp, 576 + 768, SEEK_CUR) ;
-		else
-			if (!gr_read_pal (fp)) return 0 ;
+		if (!(pal = gr_read_pal_with_gamma (fp))) {
+			bitmap_destroy(gr);
+			return NULL ;
 	}
 
 	/* Puntos de control */
@@ -310,8 +332,9 @@
 	{
 		gr->cpoints = (CPOINT *) malloc (c * sizeof(CPOINT)) ;
 		if (!gr->cpoints) {
-		    free(gr) ;
-		    return 0 ;
+			bitmap_destroy(gr);
+			pal_destroy(pal);
+			return NULL ;
 		}
 
 		for (c = 0 ; c < gr->ncpoints ; c++)
@@ -339,9 +362,9 @@
 		Uint8 * line = (Uint8 *)gr->data + gr->pitch*y;
 		if (!file_read (fp, line, len))
 		{
-			free (gr->data) ;
-			free (gr) ;
-			return 0 ;
+			bitmap_destroy(gr);
+			pal_destroy(pal);
+			return NULL ;
 		}
 		if (gr->depth == 16)
 		{
@@ -350,6 +373,8 @@
 		}
 	}
 
+	if (gr->depth == 8 && !gr->palette) gr->palette = pal;
+
 	gr->modified = 1 ;
 	return gr ;
 }
@@ -412,6 +437,7 @@
 	GRAPH * gr ;
 
 	gr = bitmap_new (0, w, h, depth, frames) ;
+	if (!gr) return NULL;
 	gr->code = bitmap_next_code() ;
 	assert (syslib) ;
 	grlib_add_map (0, gr) ;
Index: fxi/src/g_mode7.c
===================================================================
--- fxi/src/g_mode7.c	2007-08-28 14:38:26.000000000 +0200
+++ fxi/src/g_mode7.c	2007-08-28 14:41:14.000000000 +0200
@@ -71,8 +71,7 @@
 
 void gr_mode7_bbox (int n, REGION * r)
 {
-    if (n >= 0 && n <= 9)
-        *r = *current_mode7[n].region;
+    if (n >= 0 && n <= 9) *r = *current_mode7[n].region;
 }
 
 int gr_mode7_active (int n)
@@ -253,11 +252,8 @@
 
         //if (point_z >= camera_z) break ;
 
-        lines[y].right_bmp_x = fdiv( fmul((point_x - camera_x), -camera_z),
-                           (point_z - camera_z) ) + camera_x ;
-
-        lines[y].right_bmp_y = fdiv( fmul((point_y - camera_y), -camera_z),
-                           (point_z - camera_z) ) + camera_y ;
+        lines[y].right_bmp_x = fdiv(fmul((point_x - camera_x), -camera_z), (point_z - camera_z)) + camera_x ;
+        lines[y].right_bmp_y = fdiv(fmul((point_y - camera_y), -camera_z), (point_z - camera_z)) + camera_y ;
 
         /* Averigua el incremento necesario para cada paso de la línea */
 
@@ -275,27 +271,21 @@
     if (outdoor)
     {
         outdoor_hmask = outdoor_vmask = 0xFFFFFFFF ;
-        while (~(outdoor_hmask << 1) < (int)outdoor->width-1)
-            outdoor_hmask <<= 1 ;
-        while (~(outdoor_vmask << 1) < (int)outdoor->height-1)
-            outdoor_vmask <<= 1 ;
+        while (~(outdoor_hmask << 1) < (int)outdoor->width-1) outdoor_hmask <<= 1 ;
+        while (~(outdoor_vmask << 1) < (int)outdoor->height-1) outdoor_vmask <<= 1 ;
         outdoor_hmask = ~outdoor_hmask ;
         outdoor_vmask = ~outdoor_vmask ;
     }
 
-    jump = camera_z < 0 ? -1 : 1 ;
-    ptr += (jump > 0 ? dest->pitch : -(int)dest->pitch) ;
+    jump = (camera_z < 0) ? -1 : 1 ;
+    ptr += ((jump > 0) ? dest->pitch : -(int)dest->pitch) ;
     y   += jump ;
 
-    if (dest->depth != 8)
-        gr_error ("Profundidad de color no soportada\n(mode7, dest)") ;
-    if (outdoor && outdoor->depth != 8)
-        gr_error ("Profundidad de color no soportada\n(mode7, out)") ;
-    if (indoor && indoor->depth != 8)
-        gr_error ("Profundidad de color no soportada\n(mode7, in)") ;
+    if (dest->depth != 8) gr_error ("Profundidad de color no soportada\n(mode7, dest)") ;
+    if (outdoor && outdoor->depth != 8) gr_error ("Profundidad de color no soportada\n(mode7, out)") ;
+    if (indoor && indoor->depth != 8) gr_error ("Profundidad de color no soportada\n(mode7, in)") ;
 
-    if ((dat->flags & B_TRANSLUCENT) && !trans_table_updated)
-        gr_make_trans_table() ;
+    if ((dat->flags & B_TRANSLUCENT) && !trans_table_updated) gr_make_trans_table() ;
 
     if (!(dat->flags & B_TRANSLUCENT))
     for ( ; y < height && y >= 0 ; y += jump)
@@ -341,7 +331,7 @@
             bmp_y += vinc ;
         }
 
-        ptr = baseline + (jump > 0 ? dest->pitch : -(int)dest->pitch) ;
+            ptr = baseline + ((jump > 0) ? dest->pitch : -(int)dest->pitch) ;
     }
     else
     for ( ; y < height && y >= 0 ; y += jump)
@@ -385,7 +375,7 @@
             bmp_y += vinc ;
         }
 
-        ptr = baseline + (jump > 0 ? dest->pitch : -(int)dest->pitch) ;
+                ptr = baseline + ((jump > 0) ? dest->pitch : -(int)dest->pitch) ;
     }
 
     /* Crea una lista ordenada de instancias a dibujar */
Index: fxi/src/g_pal.c
===================================================================
--- fxi/src/g_pal.c	2007-08-28 14:39:57.000000000 +0200
+++ fxi/src/g_pal.c	2007-08-28 14:41:14.000000000 +0200
@@ -54,10 +54,15 @@
 
 extern GRAPH * gr_read_png (const char * filename) ;
 
+static unsigned char colors[256][3] ;
+
+PALETTE * first_palette = NULL ;
+
 SDL_Color  palette[256] ;
-SDL_Color vpalette[256] ;
 
+SDL_Color vpalette[256] ;
 Uint16     colorequiv[256] ;    /* Equivalencia paleta -> pantalla   */
+
 Uint16     colorghost[65536] ;  /* Deja un color a 50% de intensidad */
 
 int palette_loaded = 0 ;
@@ -65,6 +70,7 @@
 
 static int fade_inc = 0 ;
 int        fade_on = 0 ;
+int        fade_set = 0 ;
 int        fade_step = 64 ;
 SDL_Color  fade_from ;
 SDL_Color  fade_to ;
@@ -149,6 +155,161 @@
       252, 52,252, 252,108,252, 252,164,252, 252,220,252
 } ;
 
+void pal_refresh(PALETTE * pal) {
+    PALETTE * p ;
+    int n;
+
+    if (enable_16bits) {
+        if (!pal)
+            p = first_palette;
+        else
+            p = pal ;
+
+        while (p) {
+            for (n = 0 ; n < 256 ; n++)
+                p->colorequiv[n] = SDL_MapRGB (screen->format, p->rgb[n].r, p->rgb[n].g, p->rgb[n].b);
+            p = p->next;
+            if (pal) break;
+        }
+    }
+}
+
+
+void pal_use(PALETTE * pal)
+{
+    if (pal) pal->use++;
+}
+
+int pal_discard(PALETTE * pal)
+{
+    if (!pal) return 0;
+    if (pal->use) pal->use--;
+    return pal->use;
+}
+
+PALETTE * pal_new(PALETTE * basepal)
+{
+    PALETTE * pal = malloc(sizeof(PALETTE));
+
+    if (!pal) return NULL ;
+
+    if (basepal) {
+        memmove(pal->rgb, basepal->rgb, sizeof(pal->rgb)) ;
+        memmove(pal->colorequiv, basepal->colorequiv, sizeof(pal->colorequiv)) ;
+    } else {
+        /* Default */
+        memmove(pal->rgb, palette, sizeof(pal->rgb)) ;
+        if (enable_16bits) {
+            int n;
+            for (n = 0 ; n < 256 ; n++)
+                pal->colorequiv[n] = SDL_MapRGB (screen->format, pal->rgb[n].r, pal->rgb[n].g, pal->rgb[n].b) ;
+        }
+    }
+
+    pal->use        = 1 ;
+    pal->next       = first_palette ;
+    pal->prev       = NULL ;
+    first_palette   = pal ;
+
+    return pal;
+}
+
+PALETTE * pal_new2(unsigned char * datapal)
+{
+    PALETTE * pal = malloc(sizeof(PALETTE));
+    int n;
+
+    if (!pal) return NULL ;
+
+    if (datapal) {
+		for (n = 0 ; n < 256 ; n++)
+		{
+			pal->rgb[n].r = datapal[3*n    ];
+			pal->rgb[n].g = datapal[3*n + 1];
+			pal->rgb[n].b = datapal[3*n + 2];
+		}
+    } else {
+        /* Default */
+        memmove(pal->rgb, palette, sizeof(pal->rgb)) ;
+    }
+
+    if (enable_16bits) {
+        for (n = 0 ; n < 256 ; n++)
+            pal->colorequiv[n] = SDL_MapRGB (screen->format, pal->rgb[n].r, pal->rgb[n].g, pal->rgb[n].b) ;
+    }
+
+    pal->use        = 1 ;
+    pal->next       = first_palette ;
+    pal->prev       = NULL ;
+    first_palette   = pal ;
+
+    return pal;
+}
+
+void pal_destroy(PALETTE * pal)
+{
+    if (!pal) return ;
+
+    if (pal_discard(pal)) return ;
+
+    if (pal->next) pal->next->prev = pal->prev ;
+    if (pal->prev) pal->prev->next = pal->next ;
+
+    if (pal == first_palette) first_palette = pal->next ;
+
+    free (pal);
+}
+
+int pal_get (PALETTE * spal, int color, int num, Uint8 * pal)
+{
+    if (!spal || num < 1 || color < 0 || color > 255) return 0;
+    if (color+num >= 256) num = 256-color ;
+
+    while (num--)
+    {
+        *pal++ = spal->rgb[color  ].r ;
+        *pal++ = spal->rgb[color  ].g ;
+        *pal++ = spal->rgb[color++].b ;
+    }
+    return num;
+}
+
+int pal_set (PALETTE * spal, int color, int num, Uint8 * pal)
+{
+    if (!spal || num < 1 || color < 0 || color > 255) return 0;
+    if (color+num >= 256) num = 256-color ;
+
+    while (num--)
+    {
+        spal->rgb[color  ].r = *pal++ ;
+        spal->rgb[color  ].g = *pal++ ;
+        spal->rgb[color++].b = *pal++ ;
+    }
+    return num;
+}
+
+int pal_map_assign (int libid, int mapcode, PALETTE * palid)
+{
+    GRAPH * bmp = bitmap_get (libid, mapcode) ;
+    PALETTE * oldpal ;
+    if (!bmp || bmp->depth != 8 || !palid) return 0 ;
+    oldpal = bmp->palette ;
+    bmp->palette = palid ;
+    pal_use(bmp->palette) ;
+    if (oldpal) pal_destroy(oldpal) ;
+    return 1 ;
+}
+
+int pal_map_remove (int libid, int mapcode)
+{
+    GRAPH * bmp = bitmap_get (libid, mapcode) ;
+    if (!bmp || bmp->depth != 8) return 0 ;
+    if (bmp->palette) pal_destroy (bmp->palette) ;
+    bmp->palette = NULL ;
+    return 1 ;
+}
+
+/* ---------------------------- */
 
 static void activate_vpalette()
 {
@@ -216,21 +377,24 @@
 
 void gr_fade_init (int r, int g, int b, int speed)
 {
+    if (fade_pos.r == r && fade_pos.g == g && fade_pos.b == b) return;
+
     fade_inc  = speed;
     fade_step = 0;
     fade_on   = 1 ;
     fade_from = fade_pos;
-    fade_to.r = r > 200 ? 200 : r ;
-    fade_to.g = g > 200 ? 200 : g ;
-    fade_to.b = b > 200 ? 200 : b ;
+    fade_to.r = (r > 200) ? 200 : r ;
+    fade_to.g = (g > 200) ? 200 : g ;
+    fade_to.b = (b > 200) ? 200 : b ;
 
     GLODWORD(FADING) = 1 ;
 }
 
 void gr_fade_step()
 {
-    if (fade_on != 0)
+    if (fade_on)
     {
+        fade_set = 1 ;
         GLODWORD(FADING) = 1 ;
 
         fade_step += fade_inc ;
@@ -255,8 +419,16 @@
             (fade_pos.r == 100 && fade_pos.g == 100 && fade_pos.b == 100))
         {
             GLODWORD(FADING) = 0 ;
+            fade_step = 100 ;
             fade_on = 0;
         }
+    }
+
+    if (fade_set)
+    {
+        if (!fade_on && fade_to.r == 100 && fade_to.g == 100 && fade_to.b == 100) {
+            fade_set = 0;
+        }
 
         activate_vpalette() ;
 
@@ -265,15 +437,15 @@
             gr_fade16 (scrbitmap,  fade_pos.r, fade_pos.g, fade_pos.b);
         }
     }
+
 }
 
+#if 0
 int gr_read_pal (file * fp)
 {
-    unsigned char colors[256][3] ;
     int i ;
 
-    if (!file_read (fp, colors, 3 * 256))
-        return 0 ;
+    if (!file_read (fp, colors, 3 * 256)) return 0 ;
 
     /* Ignora definiciones de gama */
     file_seek (fp, 576, SEEK_CUR) ;
@@ -283,16 +455,53 @@
         palette[i].r = colors[i][0] << 2 ;
         palette[i].g = colors[i][1] << 2 ;
         palette[i].b = colors[i][2] << 2 ;
+    }
+
+    palette_loaded = 1 ;
+    palette_changed = 1 ;
+
+    return 1 ;
+    }
+#endif
 
+PALETTE * gr_read_pal (file * fp)
+{
+    int i ;
+    PALETTE * pal;
 
+    if (!file_read (fp, colors, 3 * 256)) return NULL ;
+
+    for (i = 0 ; i < 256 ; i++)
+    {
+        colors[i][0] = colors[i][0] << 2 ;
+        colors[i][1] = colors[i][1] << 2 ;
+        colors[i][2] = colors[i][2] << 2 ;
+        if (!palette_loaded) {
+            palette[i].r = colors[i][0] ;
+            palette[i].g = colors[i][1] ;
+            palette[i].b = colors[i][2] ;
+        }
     }
 
+    pal = pal_new2(colors);
+
     palette_loaded = 1 ;
     palette_changed = 1 ;
 
-    return 1 ;
+    return pal ;
+}
+
+PALETTE * gr_read_pal_with_gamma (file * fp)
+{
+    PALETTE * pal = gr_read_pal (fp);
+
+    /* Ignora definiciones de gama */
+    if (pal) file_seek (fp, 576, SEEK_CUR) ;
+
+    return pal ;
 }
 
+
 /*
  *  FUNCTION : gr_save_pal
  *
@@ -309,7 +518,6 @@
 {
     file * fp = file_open (filename, "wb");
     char header[8] = "pal\x1A\x0D\x0A";
-    unsigned char colors[256][3] ;
     int i;
 
     if (!fp)
@@ -341,18 +549,18 @@
     int r = 0 ;
     int i = 0 ;
 
-    if (!fp) return -1 ;
+    if (!fp) return 0 ;
     file_read (fp, header, 8) ;
     if (strcmp (header, "map\x1A\x0D\x0A") == 0)
     {
         file_seek (fp, 48, SEEK_SET) ;
-        r = gr_read_pal (fp) ;
+        r = gr_read_pal_with_gamma (fp) ;
     }
     else if (strcmp (header, "fpg\x1A\x0D\x0A") == 0 ||
         strcmp (header, "fnt\x1A\x0D\x0A") == 0 ||
         strcmp (header, "pal\x1A\x0D\x0A") == 0)
     {
-        r = gr_read_pal (fp) ;
+        r = gr_read_pal_with_gamma (fp) ;
     }
     else if (memcmp (header, "\x89PNG", 4) == 0)
     {
@@ -361,8 +569,11 @@
         file_close (fp);
         palette_loaded = 0;
         graph = gr_read_png(filename);
-        if (graph) bitmap_destroy(graph);
-        return 1;
+        if (graph) {
+            r = (int) graph->palette;
+            pal_use(graph->palette);
+            bitmap_destroy(graph);
+        }
     }
     else {
         // Soporte para FGC
@@ -374,7 +585,7 @@
             {
                 fgc_error = _("FGC file corrupt or truncated");
                 file_close(fp);
-                return -1;
+                return 0;
             }
             ARRANGE_DWORD(&fgcHeader.version);
             ARRANGE_DWORD(&fgcHeader.depth);
@@ -383,43 +594,42 @@
 
             if (fgcHeader.depth == 8) {
 
-                static unsigned char color_palette[256][3];
-
                 file_seek (fp, fgcHeader.palette, SEEK_SET) ;
+                r = gr_read_pal (fp);
 
 
-                if (file_read(fp, color_palette, 768) != 768) {
+/*
+                if (file_read(fp, colors, 768) != 768) {
                     fgc_error = _("PALETTE - FGC file is truncated");
                     file_close(fp);
-                    return -1;
+                    return 0;
                 }
 
                 for (i = 0 ; i < 256 ; i++) {
-                    palette[i].r = color_palette[i][0];
-                    palette[i].g = color_palette[i][1];
-                    palette[i].b = color_palette[i][2];
+                    palette[i].r = colors[i][0];
+                    palette[i].g = colors[i][1];
+                    palette[i].b = colors[i][2];
 
                 }
                 palette_loaded = 1 ;
                 palette_changed = 1 ;
                 r = 1 ;
+*/
             } else {
                 fgc_error = _("FGC file does not contain information about the colour palette");
                 file_close(fp);
-                return -1;
+                return 0;
             }
         }
         else if (strcmp (header, FBM_MAGIC) == 0) {
             // Soporte para FBM
 
-            static unsigned char color_palette[256][3];
-
             file_seek (fp, 0, SEEK_SET) ;
 
             if (file_read(fp,&fbmHeader,sizeof(FBM_FILE_HEADER)!=sizeof(FBM_FILE_HEADER))) {
                 fbm_error = _("FBM file corrupt or truncated");
                 file_close(fp);
-                return -1;
+                return 0;
             }
 
             ARRANGE_DWORD(&fbmHeader.depth);
@@ -427,27 +637,30 @@
             if (fbmHeader.depth!=8) {
                 fbm_error = _("FBM file does not contain information about the colour palette");
                 file_close(fp);
-                return -1;
+                return 0;
             }
 
             file_seek (fp, sizeof(FBM_FILE_HEADER)+sizeof(FBM_HEADER), SEEK_SET) ;
 
 
-            if (file_read(fp, color_palette, 768) != 768) {
+            r = gr_read_pal (fp);
+/*
+            if (file_read(fp, colors, 768) != 768) {
                 fbm_error = _("PALETTE - FGC file is truncated");
                 file_close(fp);
-                return -1;
+                return 0;
             }
 
             for (i = 0 ; i < 256 ; i++) {
-                palette[i].r = color_palette[i][0];
-                palette[i].g = color_palette[i][1];
-                palette[i].b = color_palette[i][2];
+                palette[i].r = colors[i][0];
+                palette[i].g = colors[i][1];
+                palette[i].b = colors[i][2];
             }
 
             palette_loaded = 1 ;
             palette_changed = 1 ;
             r = 1 ;
+*/
 
         } else if (strcmp (header, FPL_MAGIC) == 0) {
 
@@ -473,9 +686,7 @@
     g >>= screen->format->Gloss ;
     b >>= screen->format->Bloss ;
 
-    color= (r << screen->format->Rshift) |
-           (g << screen->format->Gshift) |
-           (b << screen->format->Bshift) ;
+    color= (r << screen->format->Rshift) | (g << screen->format->Gshift) | (b << screen->format->Bshift) ;
     if (!color) return 1 ;
     return color ;
 }
@@ -530,9 +741,9 @@
     for (n = first ; n <= last ; n++)
     {
         c = &palette[color_list[n]] ;
-        diff =  (key.r > c->r ? key.r-c->r : c->r-key.r)
-             +  (key.g > c->g ? key.g-c->g : c->g-key.g)
-             +  (key.b > c->b ? key.b-c->b : c->b-key.b) ;
+        diff =  ((key.r > c->r) ? key.r-c->r : c->r-key.r)
+             +  ((key.g > c->g) ? key.g-c->g : c->g-key.g)
+             +  ((key.b > c->b) ? key.b-c->b : c->b-key.b) ;
         if (diff < bestdiff) {
             bestdiff = diff ;
             best     = n ;
@@ -740,22 +951,22 @@
     /* Actualiza la paleta */
 
     palette_changed = 0 ;
-
-    if (fade_step != 100)
+/*
+    if (fade_step != 64 && fade_step != 0)
     {
         memcpy (vpalette, palette, sizeof(vpalette)) ;
         activate_vpalette() ;
         background_dirty = 1 ; // Temporal, hasta buscar una solucion mejor
     }
     else
-    {
+    { */
         if (enable_16bits) {
             for (n = 0 ; n < 256 ; n++)
                 colorequiv[n] = SDL_MapRGB (screen->format, palette[n].r, palette[n].g, palette[n].b) ;
         } else {
             SDL_SetColors (screen, palette, 0, 256) ;
         }
-    }
+//    }
 }
 
 void gr_set_rgb (int color, int r, int g, int b)
Index: fxi/src/g_scroll.c
===================================================================
--- fxi/src/g_scroll.c	2007-08-28 14:39:57.000000000 +0200
+++ fxi/src/g_scroll.c	2007-08-28 14:41:14.000000000 +0200
@@ -36,9 +36,6 @@
 
 #include "fxi.h"
 
-#define MIN(a,b) ((a)<(b)?(a):(b))
-#define MAX(a,b) ((a)>(b)?(a):(b))
-
 /* Indicadores de bloqueo */
 #define GRAPH_HWRAP 1
 #define GRAPH_VWRAP 2
Index: fxi/src/g_texts.c
===================================================================
--- fxi/src/g_texts.c	2007-08-28 14:39:57.000000000 +0200
+++ fxi/src/g_texts.c	2007-08-28 14:41:14.000000000 +0200
@@ -84,8 +84,7 @@
 {
       char *p1, *p2;
 
-      if (! str || ! *str)
-            return str;
+      if (! str || ! *str) return str;
       for (p1 = str, p2 = str + strlen(str) - 1; p2 > p1; ++p1, --p2)
       {
             *p1 ^= *p2;
@@ -185,9 +184,7 @@
     if (!str) return 1;
 
 	font = gr_font_get (text->fontid);
-	if (font == NULL) {
-		return 1;
-	}
+	if (!font) return 1;
 
 	/* Calculate the text dimensions */
 
@@ -204,8 +201,7 @@
 
 		for (c = 0 ; c < 256 ; c++)
 		{
-			if (font->glyph[c].bitmap == NULL)
-				continue;
+			if (font->glyph[c].bitmap == NULL) continue;
 			if (font->maxheight < (int)font->glyph[c].bitmap->height + font->glyph[c].yoffset)
 				font->maxheight = (int)font->glyph[c].bitmap->height + font->glyph[c].yoffset;
 		}
@@ -262,21 +258,18 @@
 		case TEXT_FLOAT:
 		case TEXT_INT:
 		case TEXT_DWORD:
-			if (text->last_value == *(int *)text->var)
-				return 0;
+			if (text->last_value == *(int *)text->var) return 0;
 			text->last_value = *(int *)text->var;
 			return 1;
 		case TEXT_BYTE:
 		case TEXT_SBYTE:
 		case TEXT_CHAR:
-			if (text->last_value == *(Uint8 *)text->var)
-				return 0;
+			if (text->last_value == *(Uint8 *)text->var) return 0;
 			text->last_value = *(Uint8 *)text->var;
 			return 1;
 		case TEXT_WORD:
 		case TEXT_SHORT:
-			if (text->last_value == *(Uint16 *)text->var)
-				return 0;
+			if (text->last_value == *(Uint16 *)text->var) return 0;
 			text->last_value = *(Uint16 *)text->var;
 			return 1;
 		case TEXT_CHARARRAY:
@@ -330,8 +323,7 @@
 
 		for (c = 0 ; c < 256 ; c++)
 		{
-			if (font->glyph[c].bitmap == NULL)
-				continue;
+			if (font->glyph[c].bitmap == NULL) continue;
 			if (font->maxheight < (int)font->glyph[c].bitmap->height + font->glyph[c].yoffset)
 				font->maxheight = (int)font->glyph[c].bitmap->height + font->glyph[c].yoffset;
 		}
@@ -374,8 +366,7 @@
 	fntcolor8 = text->color8;
 	fntcolor16 = text->color16;
 
-    if(!gr_text_put (0, clip, text->fontid, x, y, str))
-	    gr_text_destroy(text->id);
+    if(!gr_text_put (0, clip, text->fontid, x, y, str)) gr_text_destroy(text->id);
 
 	fntcolor8 = save8;
 	fntcolor16 = save16;
@@ -619,7 +610,7 @@
 
 	if (fntcolor8 == -1)
 	{
-		gr_setcolor (dest->depth == 8 ? gr_find_nearest_color(255,255,255):gr_rgb(255,255,255));
+		gr_setcolor ((dest->depth == 8) ? gr_find_nearest_color(255,255,255):gr_rgb(255,255,255));
 	}
 	else
 	{
Index: fxi/src/i_debug.c
===================================================================
--- fxi/src/i_debug.c	2007-08-28 14:39:58.000000000 +0200
+++ fxi/src/i_debug.c	2007-08-28 14:41:14.000000000 +0200
@@ -155,7 +155,7 @@
     { "STR2FLOAT", MN_STR2FLOAT, 1 },
     { "FLOAT2STR", MN_FLOAT2STR, 1 },
     { "POINTER2STR", MN_POINTER2STR, 1 },
-    { "POINTER2BOL", MN_POINTER2BOL, 1 },
+//    { "POINTER2BOL", MN_POINTER2BOL, 1 },
 
     { "A2STR", MN_A2STR, 0 },
     { "STR2A", MN_STR2A, 0 },
@@ -238,7 +238,7 @@
     if (dcb.data.NID && dcbproc->data.ID) {
         sprintf (buffer, "%s", getid(dcbproc->data.ID)) ;
     } else {
-        sprintf (buffer, "%s", proc->type == 0 ? "MAIN":"PROC") ;
+        sprintf (buffer, "%s", (proc->type == 0) ? "MAIN":"PROC") ;
     }
 
     line[0] = 0 ;
@@ -283,7 +283,7 @@
             if (dcb.data.NID && dcbproc->data.ID) {
                 sprintf (buffer, "%s", getid(dcbproc->data.ID)) ;
             } else {
-                sprintf (buffer, "%s", proc->type == 0 ? "MAIN":"PROC") ;
+                sprintf (buffer, "%s", (proc->type == 0) ? "MAIN":"PROC") ;
             }
 
             line[0] = 0 ;
Index: fxi/src/i_func.c
===================================================================
--- fxi/src/i_func.c	2007-08-28 14:41:05.000000000 +0200
+++ fxi/src/i_func.c	2007-08-28 14:41:15.000000000 +0200
@@ -173,10 +173,10 @@
 
 static int fxi_rand (INSTANCE * my, int * params)
 {
-    int num1 = params[0] ;
-    int num2 = params[1] ;
+    int num1 = MIN(params[0], params[1]) ;
+    int num2 = MAX(params[0], params[1]) ;
 
-    return num1 + (int)(((double)(num2-num1+1) * rand()) / (RAND_MAX+1.0)) ;
+    return num1 + (rand()%(num2-num1+1)) ;
 }
 
 static int fxi_rand_seed (INSTANCE * my, int * params)
@@ -188,7 +188,7 @@
 static int fxi_abs (INSTANCE * my, int * params)
 {
     float num = *(float *)&params[0] ;
-    float res = num < 0 ? -num:num ;
+    float res = (num < 0) ? -num:num ;
     return *(int *)&res ;
 }
 
@@ -204,11 +204,11 @@
     double dy = params[3] - params[1] ;
     int angle ;
 
-    if (dx == 0) return dy > 0 ? 270000 : 90000 ;
+    if (dx == 0) return (dy > 0) ? 270000L : 90000L ;
 
     angle = (int) (atan(dy / dx) * 180000.0 / M_PI) ;
 
-    return dx > 0 ? -angle:-angle+180000 ;
+    return (dx > 0) ? -angle:-angle+180000L ;
 }
 
 static int fxi_fget_dist (INSTANCE * my, int * params)
@@ -225,11 +225,11 @@
     int dest  = params[1] ;
     int incr  = params[2] ;
 
-    if (angle < dest && dest-angle > 180000)
-        angle += 360000 ;
+    if (angle < dest && dest-angle > 180000L)
+        angle += 360000L ;
 
-    if (angle > dest && angle-dest > 180000)
-        angle -= 360000 ;
+    if (angle > dest && angle-dest > 180000L)
+        angle -= 360000L ;
 
     if (angle < dest)
     {
@@ -242,8 +242,8 @@
         if (angle < dest) angle = dest ;
     }
 
-    if (angle < 0) return angle + 360000 ;
-    if (angle >= 360000) return angle - 360000 ;
+    if (angle < 0) return angle + 360000L ;
+    if (angle >= 360000L) return angle - 360000L ;
     return angle ;
 }
 
@@ -397,7 +397,7 @@
             if (instance_visible(i))
                 gr_mark_instance(i);
 
-            switch (params[1] >= 100 ? params[1]-100 : params[1])
+            switch ((params[1] >= 100) ? params[1]-100 : params[1])
             {
                 case 0:     /* S_KILL */
                     LOCDWORD(i, STATUS) = (LOCDWORD(i, STATUS) & STATUS_WAITING_MASK) | STATUS_KILLED ;
@@ -516,6 +516,7 @@
 
     if (!params[0])
     {
+        LOCDWORD(my, TYPE_SCAN) = 0 ;
         if (LOCDWORD(my, ID_SCAN))
         {
             ptr = instance_get (LOCDWORD(my,ID_SCAN)) ;
@@ -530,10 +531,10 @@
             }
             ptr = ptr->next ;
         }
-        LOCDWORD(my,ID_SCAN) = 0 ;
         return 0 ;
     }
 
+    LOCDWORD(my, ID_SCAN) = 0 ;
     if (LOCDWORD(my,TYPE_SCAN))
     {
         ptr = instance_get (LOCDWORD(my,TYPE_SCAN)) ;
@@ -554,7 +555,6 @@
         }
         ptr = ptr->next ;
     }
-    LOCDWORD(my,TYPE_SCAN) = 0 ;
     return 0 ;
 }
 
@@ -709,13 +709,14 @@
 
     scalex = LOCDWORD(i,GRAPHSIZEX);
     scaley = LOCDWORD(i,GRAPHSIZEY);
-    if (scalex == 100 && scaley == 100)
-        scalex = scaley = LOCDWORD(i,GRAPHSIZE);
+    if (scalex == 100 && scaley == 100) scalex = scaley = LOCDWORD(i,GRAPHSIZE);
 
     map = instance_graph (i) ;
     if (!map) return ;
+
     // PATCH - XGRAPH DOES NOT ROTATE DESTINATION GRAPHIC
-    if (LOCDWORD(i,ANGLE) || scaley != 100 || scalex != 100) {
+    if ((map->current_keyframe >= 0 && map->keyframes[map->current_keyframe].angle) ||
+        LOCDWORD(i,ANGLE) || scaley != 100 || scalex != 100) {
         if (LOCDWORD(i,XGRAPH) && scalex == 100 && scaley == 100) {
             gr_blit (dest, r, x, y, LOCDWORD(i,FLAGS), map) ;
         } else {
@@ -785,10 +786,8 @@
 
     /* Creates a temporary bitmap (only once) */
 
-    if (!bmp)
-        bmp = bitmap_new (0, 2, 2, enable_16bits ? 16:8, 1) ;
-    if (!bmp)
-        return 0 ;
+    if (!bmp) bmp = bitmap_new (0, 2, 2, enable_16bits ? 16:8, 1) ;
+    if (!bmp) return 0 ;
     memset (bmp->data, 0, 2) ;
 
     /* Retrieves process information */
@@ -810,11 +809,9 @@
             {
                 REGION * r = scrolls[i].region;
 
-                if (r->x > mx || r->x2 < mx || r->y > my || r->y2 < my)
-                    continue;
+                if (r->x > mx || r->x2 < mx || r->y > my || r->y2 < my) continue;
                 draw_at (bmp, x+r->x-mx-scrolls[i].posx0, y+r->y-my-scrolls[i].posy0, &bbox1, proc1);
-                if (enable_16bits ? *(Uint16 *)bmp->data : *(Uint8 *)bmp->data)
-                    return 1;
+                if (enable_16bits ? *(Uint16 *)bmp->data : *(Uint8 *)bmp->data) return 1;
             }
         }
         return 0;
@@ -856,8 +853,8 @@
         bitmap_destroy (bmp) ;
         return 0;
     }
-    memset (bmp->data, 0, w*h*(depth == 16?2:1)) ;
-    memset (bmp2->data, 0, w*h*(depth == 16?2:1)) ;
+    memset (bmp->data, 0, w*h*((depth == 16)?2:1)) ;
+    memset (bmp2->data, 0, w*h*((depth == 16)?2:1)) ;
 
     get_pos (proc1, &x, &y) ;
     x -= bbox1.x ;
@@ -919,20 +916,18 @@
 {
     INSTANCE * ptr = instance_get(params[0]) ;
 
-    if (params[0] == -1)
-        return check_collision_with_mouse(my) ? 1:0 ;
+    if (params[0] == -1) return (check_collision_with_mouse(my)) ? 1 : 0 ;
 
     /* ADDED IN 0.74 - Checks only for a single instance */
-    /*DEBUG*/
 
-    if (params[0] >= FIRST_INSTANCE_ID && ptr)
-        return check_collision(my,ptr) ;
+    if (params[0] >= FIRST_INSTANCE_ID && ptr) return check_collision(my,ptr) ;
 
     /* we must use full list of instances or get types from it */
     ptr = first_instance ;
 
     if (!params[0])
     {
+        LOCDWORD(my, TYPE_SCAN) = 0 ;
         if (LOCDWORD(my, ID_SCAN))
         {
             ptr = instance_get (LOCDWORD(my, ID_SCAN)) ;
@@ -954,17 +949,18 @@
             }
             ptr = ptr->next ;
         }
-        LOCDWORD (my, ID_SCAN) = 0 ;
         return 0 ;
     }
 
+    LOCDWORD (my, ID_SCAN) = 0 ;
     if (LOCDWORD(my,TYPE_SCAN))
     {
         ptr = instance_get (LOCDWORD(my,TYPE_SCAN)) ;
-        if (ptr && LOCDWORD(ptr,PROCESS_TYPE) != params[0]) ptr = first_instance ;
-        else if (ptr) ptr = ptr->next ;
+        if (ptr && LOCDWORD(ptr, PROCESS_TYPE) != params[0])
+            ptr = first_instance ;
+        else if (ptr)
+            ptr = ptr->next ;
     }
-
     while (ptr)
     {
         if (LOCDWORD(ptr,PROCESS_TYPE) == params[0] && ptr != my)
@@ -979,7 +975,6 @@
         }
         ptr = ptr->next ;
     }
-    LOCDWORD(my,TYPE_SCAN) = 0 ;
     return 0 ;
 }
 
@@ -1033,7 +1028,7 @@
     if (params[0]>1600 || params[1]>1400)
         gr_error (_("Unsupported graphic mode"));
 
-    GLODWORD(GRAPH_MODE) = ((GLODWORD(GRAPH_MODE) & 0xFF) | params[2]);
+    GLODWORD(GRAPH_MODE) = ((GLODWORD(GRAPH_MODE) & 0xFF00) | params[2]);
     gr_init(params[0], params[1]) ;
     return 1 ;
 }
@@ -1165,10 +1160,71 @@
 
 /* Paleta de colores */
 
+
+static int fxi_pal_create (INSTANCE * my, int * params)
+{
+    return (int) pal_new((PALETTE *)NULL) ;
+}
+
+static int fxi_pal_clone (INSTANCE * my, int * params)
+{
+    return (int) pal_new((PALETTE *)(params[0])) ;
+}
+
+static int fxi_pal_unload (INSTANCE * my, int * params)
+{
+    pal_destroy((PALETTE *)(params[0])) ;
+    return 1;
+}
+
+static int fxi_pal_refresh (INSTANCE * my, int * params)
+{
+    pal_refresh(NULL) ;
+    return 1;
+}
+
+static int fxi_pal_refresh_2 (INSTANCE * my, int * params)
+{
+    pal_refresh((PALETTE *)(params[0]));
+    return 1;
+}
+
+static int fxi_pal_map_assign (INSTANCE * my, int * params)
+{
+    return pal_map_assign (params[0], params[1], (PALETTE *)(params[2]));
+}
+
+static int fxi_pal_map_remove (INSTANCE * my, int * params)
+{
+    return pal_map_remove (params[0], params[1]);
+}
+
+static int fxi_pal_map_getid (INSTANCE * my, int * params)
+{
+    GRAPH * bmp = bitmap_get (params[0], params[1]) ;
+    if (!bmp || bmp->depth != 8) return 0 ;
+    return (int) bmp->palette ;
+}
+
+static int fxi_pal_set (INSTANCE * my, int * params)
+{
+    return (pal_set ((PALETTE *)(params[0]), params[1], params[2], (Uint8 *)params[3])) ;
+}
+
+static int fxi_pal_get (INSTANCE * my, int * params)
+{
+    return (pal_get ((PALETTE *)(params[0]), params[1], params[2], (Uint8 *)params[3])) ;
+}
+
+
 static int fxi_load_fpl (INSTANCE * my, int * params)
 {
     const char * palname = string_get (params[0]) ;
-    int r = palname ? fpl_load(palname) : 0 ;
+    int r ;
+    int old_palette_loaded = palette_loaded ;
+    palette_loaded = 0 ;
+    r = palname ? fpl_load(palname) : 0 ;
+    if (!r) palette_loaded = old_palette_loaded ;
     string_discard (params[0]) ;
     return r ;
 }
@@ -1184,7 +1240,11 @@
 static int fxi_load_pal (INSTANCE * my, int * params)
 {
     const char * palname = string_get (params[0]) ;
-    int r = palname ? gr_load_pal(palname) : 0 ;
+    int r ;
+    int old_palette_loaded = palette_loaded ;
+    palette_loaded = 0 ;
+    r = palname ? gr_load_pal(palname) : 0 ;
+    if (!r) palette_loaded = old_palette_loaded ;
     string_discard (params[0]) ;
     return r ;
 }
@@ -1663,7 +1723,7 @@
         background_8bits_used = 0;
     }
 
-    if (params[4] == 0 && params[5] == 100)
+    if (params[4] == 0 && params[5] == 100 && !(map->current_keyframe >= 0 && map->keyframes[map->current_keyframe].angle))
     {
         gr_blit (background, &regions[r], params[2], params[3], params[6], map) ;
         return 0 ;
@@ -1841,7 +1901,7 @@
     GRAPH * dest = bitmap_get (params[0], params[1]) ;
     GRAPH * orig = bitmap_get (params[0], params[2]) ;
 
-    if (params[5] == 0 && params[6] == 100)
+    if (params[5] == 0 && params[6] == 100 && !(orig->current_keyframe >= 0 && orig->keyframes[orig->current_keyframe].angle))
         gr_blit (dest, 0, params[3], params[4], params[7], orig) ;
     else
         gr_rotated_blit (dest, 0, params[3], params[4], params[7], params[5], params[6], params[6], orig) ;
@@ -1857,7 +1917,7 @@
     GRAPH * dest = bitmap_get (params[0], params[1]) ;
     GRAPH * orig = bitmap_get (params[2], params[3]) ;
 
-    if (params[6] == 0 && params[7] == 100 && params[8] == 100)
+    if (params[6] == 0 && params[7] == 100 && params[8] == 100 && !(orig->current_keyframe >= 0 && orig->keyframes[orig->current_keyframe].angle))
         gr_blit (dest, 0, params[4], params[5], params[9], orig) ;
     else
         gr_rotated_blit (dest, 0, params[4], params[5], params[9], params[6], params[7], params[8], orig) ;
@@ -2108,8 +2168,7 @@
     GRAPH * map ;
     unsigned char c = params[1];
 
-    if (font->charset == CHARSET_CP850)
-        c = win_to_dos[c];
+    if (font->charset == CHARSET_CP850) c = win_to_dos[c];
 
     if (!scr_initialized) gr_init (320, 200) ;
     if (!font) return 0;
@@ -2133,13 +2192,11 @@
     GRAPH * map  = bitmap_get(params[2], params[3]);
     unsigned char c = params[1];
 
-    if (font->charset == CHARSET_CP850)
-        c = win_to_dos[c];
+    if (font->charset == CHARSET_CP850) c = win_to_dos[c];
 
     if (font && map)
     {
-        if (font->glyph[c].bitmap)
-            bitmap_destroy (font->glyph[c].bitmap);
+        if (font->glyph[c].bitmap) bitmap_destroy (font->glyph[c].bitmap);
         font->glyph[c].bitmap = bitmap_clone(map);
         if (map->ncpoints >= 3 && map->cpoints)
         {
@@ -2401,11 +2458,49 @@
 
 static int fxi_fputs (INSTANCE * my, int * params)
 {
-    int r = file_puts ((file *)params[0], string_get(params[1])) ;
+    char *str = string_get(params[1]);
+    int r = file_puts ((file *)params[0], str) ;
+    if (str[strlen(str)-1] != '\n') file_puts ((file *)params[0], "\r\n") ;
+/*    int r = file_puts ((file *)params[0], string_get(params[1])) ; */
     string_discard(params[1]) ;
     return r ;
 }
 
+static int fxi_fgets (INSTANCE * my, int * params)
+{
+    char buffer[1024] ;
+    int str, str2 = 0, str3 ;
+    int len, sigue = 1 ;
+
+    while(sigue)
+    {
+        len = file_gets ((file *)params[0], buffer, sizeof(buffer)) ;
+        if (len < 1)
+            sigue = 0 ;
+        else {
+            if (buffer[len-1] == '\n')
+            {
+                len-- ;
+                buffer[len] = '\0' ;
+                sigue = 0 ;
+            }
+            if (buffer[len-1] == '\r') buffer[len-1] = '\0' ;
+        }
+        str = string_new (buffer) ;
+        if (str2)
+        {
+            str3 = string_add (str2, str) ;
+            string_discard (str) ;
+            string_discard (str2) ;
+            str2 = str3 ;
+        }
+        else
+            str2 = str ;
+    }
+    string_use (str2) ;
+    return str2 ;
+}
+
 static int fxi_file (INSTANCE * my, int * params)
 {
     char buffer[1024] ;
@@ -2430,39 +2525,6 @@
     return str ;
 }
 
-static int fxi_fgets (INSTANCE * my, int * params)
-{
-    char buffer[1024] ;
-    int str, str2 = 0, str3 ;
-    int len, sigue ;
-
-    for (;;)
-    {
-        file_gets ((file *)params[0], buffer, sizeof(buffer)) ;
-        len = strlen(buffer) ;
-        if (len > 1 && buffer[len-1] == '\n' && buffer[len-2] == '\\')
-        {
-            buffer[len-2] = 0 ;
-            sigue = 1 ;
-        }
-        else    sigue = 0 ;
-
-        str = string_new (buffer) ;
-        if (str2)
-        {
-            str3 = string_add (str2, str) ;
-            string_discard (str) ;
-            string_discard (str2) ;
-            str2 = str3 ;
-        }
-        else    str2 = str ;
-
-        if (!sigue) break ;
-    }
-    string_use (str2) ;
-    return str2 ;
-}
-
 static int fxi_feof (INSTANCE * my, int * params)
 {
     return file_eof ((file *)params[0]) ;
@@ -3992,9 +4054,9 @@
                 }
             }
             r1/=tabla[9];g1/=tabla[9];b1/=tabla[9];
-            r=((int)r1)>255?255:(int)r1;
-            g=((int)g1)>255?255:(int)g1;
-            b=((int)b1)>255?255:(int)b1;
+            r=(((int)r1)>255)?255:(int)r1;
+            g=(((int)g1)>255)?255:(int)g1;
+            b=(((int)b1)>255)?255:(int)b1;
 
             if(r<0)r=0;
             if(g<0)g=0;
@@ -4831,7 +4893,7 @@
     }
 
     stat (globd.gl_pathv[currentFile], &s);
-    gr_con_printf (_("%s (size %d) is %s"), globd.gl_pathv[currentFile], s.st_size, S_ISDIR(s.st_mode) ? _("a directory"):_("a file"));
+    gr_con_printf (_("%s (size %d) is %s"), globd.gl_pathv[currentFile], s.st_size, (S_ISDIR(s.st_mode)) ? _("a directory"):_("a file"));
 
     /* Store the file name and path */
     if (GLODWORD(FILE_NAME))
@@ -4862,7 +4924,7 @@
     }
 
     /* Store integer and boolean variables */
-    GLODWORD(FILE_DIRECTORY) = (S_ISDIR(s.st_mode) ? 1:0);
+    GLODWORD(FILE_DIRECTORY) = ((S_ISDIR(s.st_mode)) ? 1:0);
     GLODWORD(FILE_HIDDEN)    = (*ptr == '.');
     GLODWORD(FILE_READONLY)  = !(s.st_mode & 0444);
     GLODWORD(FILE_SIZE)      = s.st_size;
Index: fxi/src/i_main.c
===================================================================
--- fxi/src/i_main.c	2007-08-28 14:39:59.000000000 +0200
+++ fxi/src/i_main.c	2007-08-28 14:41:15.000000000 +0200
@@ -182,7 +182,7 @@
 	return result;
 }
 
-/*static */void freestrings(PROCDEF * proc, int * data)
+void freestrings(PROCDEF * proc, int * data)
 {
     // Splinter, descarto todas las strings privadas
     int i, s = 0, r;
@@ -211,54 +211,52 @@
             if (must_exit) break ;
 
         } else {
-            if (!last_instance_run) {
-                /* Ejecuta uno a uno todos los procesos */
-                i_count = 0 ;
-            }
-
-            while (1)
-            {
-                if (last_instance_run && instance_exists(last_instance_run)) {
+            if (last_instance_run) {
+                if (instance_exists(last_instance_run)) {
                     i = last_instance_run;
                 } else {
                     last_instance_run = NULL;
                     i = instance_next_by_priority();
-                    if (!i) break;
                 }
-                if (LOCDWORD(i, STATUS) == STATUS_KILLED ||
-                    LOCDWORD(i, STATUS) == STATUS_DEAD   ||
+            } else {
+                i = instance_next_by_priority();
+                i_count = 0 ;
+            }
+
+            while (i)
+            {
+                if (LOCDWORD(i, STATUS) == STATUS_KILLED || LOCDWORD(i, STATUS) == STATUS_DEAD ||
                     last_instance_run)
                 {
+                    // Run instance
+                } else if (LOCDWORD(i, STATUS) == STATUS_RUNNING && LOCDWORD(i, FRAME_PERCENT) < 100) {
+                    LOCDWORD(i, TYPE_SCAN) = 0;
+                    LOCDWORD(i, ID_SCAN) = 0;
+                } else {
+                    i = instance_next_by_priority();
                     last_instance_run = NULL;
-
-                    instance_go (i);
-
-                    if (force_debug || must_exit) break;
                     continue;
                 }
 
-                last_instance_run = NULL;
-
-                if (LOCDWORD(i, STATUS) != STATUS_RUNNING) continue;
+                i_count++;
 
-                if (LOCDWORD(i, FRAME_PERCENT) < 100) {
-                    LOCDWORD(i, TYPE_SCAN) = 0;
-                    LOCDWORD(i, ID_SCAN) = 0;
+                last_instance_run = NULL;
 
                     instance_go (i);
 
-                    if (force_debug || must_exit) break;
-                    i_count++;
-                }
+                if (force_debug) {
+                    show_console = 1;
+                    last_instance_run  = trace_instance;
+                    break;
             }
 
             if (must_exit) break ;
 
-            if (force_debug) {
-                show_console = 1;
-                last_instance_run  = trace_instance;
+                i = instance_next_by_priority();
             }
 
+            if (must_exit) break ;
+
             /* Si no se ejecutó nada: Dibujar, actualizar variables, etc. */
 
             if (!i_count && !force_debug)
@@ -290,8 +288,7 @@
                     i = next ;
                 }
 
-                if (!first_instance)
-                    break ;
+                if (!first_instance) break ;
 
                 /* Dibuja el frame */
 
@@ -326,8 +323,7 @@
 
 int instance_go (INSTANCE * r)
 {
-    if (!r)
-        return 0 ;
+    if (!r) return 0 ;
 
     register int * ptr = r->codeptr ;
     register int * stack_ptr = stack_gptr ;
@@ -335,10 +331,10 @@
     int n ;
     int return_value = LOCDWORD(r, PROCESS_ID) ;
     int was_visible;
-    SYSPROC * p ;
-    INSTANCE * i ;
-    PROCDEF * proc = r->proc, * aproc ;
-    static char buffer[16], * str ;
+    SYSPROC * p = NULL ;
+    INSTANCE * i = NULL ;
+    PROCDEF * proc = r->proc;
+    static char buffer[16], * str = NULL ;
 
     /* This variable contains a pointer to the private area at the stack.
        It is 0 if the current process uses the instance's private area instead */
@@ -353,17 +349,22 @@
 
     /* ------------------------------------------------------------------------------- */
     /* Restauro si salio por debug */
+#if 0
     if (r->inpridata) {
         private_data = r->inpridata;
         base_code = r->inproc->code;
         proc = r->inproc;
     }
+#endif
+
+    switchval = r->switchval;
+    switchval_string = r->switchval_string;
+    cased = r->cased;
 
     if (r->stack)
     {
         /* Restore a saved stack, if present */
-        if ((*r->stack) & STACK_SIZE_MASK)
-            memcpy (stack_ptr, r->stack+1, *r->stack * 4);
+        if ((*r->stack) & STACK_SIZE_MASK) memcpy (stack_ptr, r->stack+1, ((*r->stack) & STACK_SIZE_MASK) * 4);
         stack_ptr += ((*r->stack) & STACK_SIZE_MASK);
         free (r->stack);
         r->stack = NULL;
@@ -385,7 +386,11 @@
 
     trace_sentence = -1;
 
-    while(!must_exit && (LOCDWORD(r, STATUS) & STATUS_WAITING_MASK) != STATUS_KILLED)
+    while(!must_exit /*&&
+          (LOCDWORD(r, STATUS) == STATUS_RUNNING ||
+           LOCDWORD(r, STATUS) == STATUS_DEAD) &&
+          !(LOCDWORD(r, STATUS) & STATUS_WAITING_MASK)
+         */)
     {
         if (debug_next && trace_sentence != -1) {
             force_debug = 1;
@@ -393,11 +398,16 @@
             r->codeptr = ptr ;
             stack_gptr = stack_ptr ;
             return_value = LOCDWORD(r, PROCESS_ID);
-
+#if 0
             if (private_data != r->pridata) {
                 r->inpridata = private_data;
                 r->inproc = proc;
             }
+#endif
+            r->switchval = switchval;
+            r->switchval_string = switchval_string;
+            r->cased = cased;
+
             break;
         }
 
@@ -462,11 +472,12 @@
 
             case MN_CALL:
             case MN_PROC:
-                aproc = procdef_get (ptr[1]) ;
-                if (!aproc) gr_error ("Error: Procedimiento desconocido\n") ;
-                proc = aproc;
+                proc = procdef_get (ptr[1]) ;
+                if (!proc) gr_error ("Error: Procedimiento desconocido\n") ;
 
+#if 0
                 if (proc->flags & (PROC_USES_FRAME | PROC_USES_LOCALS | PROC_USES_PUBLICS))
+#endif
                 {
                     /* Process uses FRAME or locals, must create an instance */
                     i = instance_new (proc, r) ;
@@ -483,7 +494,8 @@
                     LOCDWORD(r,STATUS) |= STATUS_WAITING_MASK;
                     i->called_by   = r;
 
-                    /* Ejecuto la funcion/processo... */
+                    // Ejecuto la funcion/processo...
+
                     if (*ptr == MN_CALL) {
                         *stack_ptr++ = instance_go (i);
                     } else {
@@ -499,7 +511,12 @@
                     /* If the process is a function in a frame, save the stack and leave */
                     /* Si sigue corriendo la funcion/proceso que lance, es porque esta en un frame.
                        Si esta ejecutando codigo, es porque su STATUS es RUNNING */
-                    if (child_is_alive && LOCDWORD(r,STATUS) & STATUS_WAITING_MASK)
+                    if (child_is_alive &&
+                        ((LOCDWORD(r,STATUS) & STATUS_WAITING_MASK) ||
+                         (LOCDWORD(r,STATUS) & ~STATUS_WAITING_MASK) == STATUS_FROZEN ||
+                         (LOCDWORD(r,STATUS) & ~STATUS_WAITING_MASK) == STATUS_SLEEPING
+                        )
+                       )
                     {
                         /* En este caso me pongo a dormir y retorno */
                         i->called_by   = r;
@@ -516,7 +533,7 @@
                         /* Esta instancia no va a ejecutar otro codigo hasta que retorne el hijo */
                         r->codeptr = ptr ;
 
-                        /* Apunto global stack a stack_begin (inicio de mi stack) */
+                        /* Apunto global stack a stack_begin (inicio del stack original) */
                         stack_gptr = stack_begin;
 
                         /* Si no fue un call, seteo un flag en la len para no retornar valor */
@@ -538,6 +555,7 @@
                     }
                     proc = r->proc;
                 }
+#if 0
                 else
                 {
                     /* This process can be called locally: create a private memory area using the stack */
@@ -561,6 +579,7 @@
                     *stack_ptr++ = (Sint32) old_data;               //                    (stack_ptr[-2] in return)
                     base_code = ptr = proc->code;
                 }
+#endif
                 break ;
 
             case MN_SYSCALL:
@@ -639,7 +658,7 @@
             case MN_REMOTE | MN_STRING:
             case MN_REMOTE | MN_FLOAT:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = (int) &LOCDWORD(i, ptr[1]) ;
@@ -655,7 +674,7 @@
             case MN_REMOTE_PUBLIC | MN_STRING:
             case MN_REMOTE_PUBLIC | MN_FLOAT:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = (int) &PUBDWORD(i, ptr[1]) ;
@@ -696,7 +715,7 @@
             case MN_GET_REMOTE | MN_FLOAT:
             case MN_GET_REMOTE | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = LOCDWORD(i,ptr[1]) ;
@@ -707,7 +726,7 @@
             case MN_GET_REMOTE_PUBLIC | MN_FLOAT:
             case MN_GET_REMOTE_PUBLIC | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = PUBDWORD(i,ptr[1]) ;
@@ -755,7 +774,7 @@
 
             case MN_GET_REMOTE | MN_STRING:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = LOCDWORD(i,ptr[1]) ;
@@ -765,7 +784,7 @@
 
             case MN_GET_REMOTE_PUBLIC | MN_STRING:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = PUBDWORD(i,ptr[1]) ;
@@ -830,7 +849,7 @@
             case MN_WORD | MN_GET_REMOTE:
             case MN_WORD | MN_GET_REMOTE | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = LOCWORD(i,ptr[1]) ;
@@ -840,7 +859,7 @@
             case MN_WORD | MN_GET_REMOTE_PUBLIC:
             case MN_WORD | MN_GET_REMOTE_PUBLIC | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = PUBWORD(i,ptr[1]) ;
@@ -853,11 +872,11 @@
                 ptr++ ;
                 break ;
 
-            case MN_WORD | MN_NOT:
+/*            case MN_WORD | MN_NOT:
             case MN_WORD | MN_NOT | MN_UNSIGNED:
                 stack_ptr[-1] = !(stack_ptr[-1]) ;
                 ptr++ ;
-                break ;
+                break ; */
 
             /* Acceso a variables tipo BYTE */
 
@@ -903,7 +922,7 @@
 
             case MN_BYTE | MN_GET_REMOTE:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = (signed char) LOCBYTE(i,ptr[1]) ;
@@ -912,7 +931,7 @@
 
             case MN_BYTE | MN_GET_REMOTE | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = LOCBYTE(i,ptr[1]) ;
@@ -921,7 +940,7 @@
 
             case MN_BYTE | MN_GET_REMOTE_PUBLIC:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = (signed char) PUBBYTE(i,ptr[1]) ;
@@ -930,7 +949,7 @@
 
             case MN_BYTE | MN_GET_REMOTE_PUBLIC | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = PUBBYTE(i,ptr[1]) ;
@@ -947,11 +966,11 @@
                 ptr++ ;
                 break ;
 
-            case MN_BYTE | MN_NOT:
+/*            case MN_BYTE | MN_NOT:
             case MN_BYTE | MN_NOT | MN_UNSIGNED:
                 stack_ptr[-1] = !(stack_ptr[-1]) ;
                 ptr++ ;
-                break ;
+                break ; */
 
             /* Operaciones matemáticas  en coma floatante */
 
@@ -1098,121 +1117,101 @@
             /* Operaciones a nivel de bit */
 
             case MN_ROR:
-//                (Sint32)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Sint32)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_ROR | MN_UNSIGNED:
-//                (Uint32)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 stack_ptr[-2] = (Uint32)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_WORD | MN_ROR:
-//                (Sint16)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 stack_ptr[-2] = (Sint16)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_WORD | MN_ROR | MN_UNSIGNED:
-//                (Uint16)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 stack_ptr[-2] = (Uint16)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BYTE | MN_ROR:
-//                (Sint8)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 stack_ptr[-2] = (Sint8)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BYTE | MN_ROR | MN_UNSIGNED:
-//                (Uint8)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 stack_ptr[-2] = (Uint8)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_ROL:
-//                (Sint32)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Sint32)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
+
             /* Todos estos ROL siguientes no serian necesarios, pero bueno... */
             case MN_ROL | MN_UNSIGNED:
-//                (Uint32)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Uint32)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_WORD | MN_ROL:
-//                (Sint16)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Sint16)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_WORD | MN_ROL | MN_UNSIGNED:
-//                (Uint16)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Uint16)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BYTE | MN_ROL:
-//                (Sint8)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Sint8)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BYTE | MN_ROL | MN_UNSIGNED:
-//                (Uint8)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Uint8)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
-/*
-            case MN_ROL:
-                stack_ptr[-2] >>= stack_ptr[-1] ;
-                stack_ptr-- ;
-                ptr++ ;
-                break ;
-
-            case MN_ROL:
-                stack_ptr[-2] <<= stack_ptr[-1] ;
-                stack_ptr-- ;
-                ptr++ ;
-                break ;
-*/
             case MN_BAND:
+            case MN_BAND | MN_UNSIGNED:
                 stack_ptr[-2] &= stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BOR:
+            case MN_BOR | MN_UNSIGNED:
                 stack_ptr[-2] |= stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BXOR:
+            case MN_BXOR | MN_UNSIGNED:
                 stack_ptr[-2] ^= stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BNOT:
+            case MN_BNOT | MN_UNSIGNED:
                 stack_ptr[-1] = ~(stack_ptr[-1]) ;
                 ptr++ ;
                 break ;
@@ -1495,21 +1494,23 @@
                 string_use (stack_ptr[-ptr[1]-1]) ;
                 ptr += 2 ;
                 break ;
-
+/*
             case MN_POINTER2BOL:
-                stack_ptr[-ptr[1]-1] = stack_ptr[-ptr[1]-1] ? 1:0 ;
+                stack_ptr[-ptr[1]-1] = (stack_ptr[-ptr[1]-1]) ? 1:0 ;
                 ptr += 2 ;
                 break ;
-
+*/
             case MN_STR2FLOAT:
-                n = stack_ptr[-ptr[1]-1] ; str = (char *)string_get(n) ;
+                n = stack_ptr[-ptr[1]-1] ;
+                str = (char *)string_get(n) ;
                 *(float *)(&stack_ptr[-ptr[1]-1]) = str ? (float)atof(str) : 0.0f ;
                 string_discard (n) ;
                 ptr += 2 ;
                 break ;
 
             case MN_STR2INT:
-                n = stack_ptr[-ptr[1]-1] ; str = (char *)string_get(n) ;
+                n = stack_ptr[-ptr[1]-1] ;
+                str = (char *)string_get(n) ;
                 stack_ptr[-ptr[1]-1] = str ? atoi(str) : 0 ;
                 string_discard (n) ;
                 ptr += 2 ;
@@ -2035,8 +2036,7 @@
                 break ;
 
             case MN_SWITCH | MN_STRING:
-                if (switchval_string != 0)
-                    string_discard (switchval_string);
+                if (switchval_string != 0) string_discard (switchval_string);
                 switchval_string = *--stack_ptr;
                 cased = 0;
                 ptr++;
@@ -2099,11 +2099,9 @@
                 stack_gptr = stack_ptr ;
                 return_value = LOCDWORD(r, PROCESS_ID);
 
-                if (r->called_by &&
-                    instance_exists(r->called_by) &&
-                    (LOCDWORD(r->called_by, STATUS) & STATUS_WAITING_MASK) &&
-                    !(r->proc->flags & PROC_FUNCTION)
-                   )
+                if (!(r->proc->flags & PROC_FUNCTION) &&
+                    r->called_by && instance_exists(r->called_by) &&
+                    (LOCDWORD(r->called_by, STATUS) & STATUS_WAITING_MASK))
                 {
                     /* We're returning and the parent is waiting: wake it up */
                     if (r->called_by->stack && !(r->called_by->stack[0] & STACK_NO_RETURN_VALUE)) {
@@ -2116,28 +2114,30 @@
                 goto break_all ;
 
             case MN_END:
+#if 0
                 if (private_data == r->pridata) /* Esto es una nueva instancia */
+#endif
                 {
-                    if (LOCDWORD (r,STATUS) != STATUS_DEAD)
-                        LOCDWORD (r,STATUS) = STATUS_KILLED ;
+                    if (LOCDWORD(r,STATUS) != STATUS_DEAD) LOCDWORD(r,STATUS) = STATUS_KILLED ;
                     stack_gptr = stack_ptr ;
                     goto break_all ;
                 }
-
+#if 0
                 return_value = LOCDWORD(r, PROCESS_ID);
                 *stack_ptr++ = return_value;
-
+#endif
             case MN_RETURN:
+#if 0
                 if (private_data == r->pridata) /* Esto es una nueva instancia */
+#endif
                 {
-                    if (LOCDWORD (r,STATUS) != STATUS_DEAD)
-                        LOCDWORD (r,STATUS) = STATUS_KILLED ;
+                    if (LOCDWORD(r,STATUS) != STATUS_DEAD) LOCDWORD(r,STATUS) = STATUS_KILLED ;
                     stack_ptr-- ;
                     stack_gptr = stack_ptr ;
                     return_value = *stack_ptr ;
                     goto break_all ;
                 }
-
+#if 0
                 /* The process is inside a stack-call */
                 proc = (PROCDEF *)stack_ptr[-4]; // stack_ptr[-4] = Recupero el proc de la instancia actual
                 freestrings(proc, private_data);
@@ -2159,7 +2159,7 @@
 
                 r->inpridata = NULL;
                 r->inproc = NULL;
-
+#endif
                 break;
 
             /* Otros */
@@ -2195,7 +2195,7 @@
         }
 
         /* Si me killearon o estoy en waiting salgo */
-        if (LOCDWORD(r,STATUS) == STATUS_KILLED || LOCDWORD(r,STATUS) & STATUS_WAITING_MASK) {
+        if ((LOCDWORD(r,STATUS) & ~STATUS_WAITING_MASK) == STATUS_KILLED || (LOCDWORD(r,STATUS) & STATUS_WAITING_MASK)) {
             r->codeptr = ptr;
             stack_gptr = stack_ptr ;
             return_value = LOCDWORD(r, PROCESS_ID);
@@ -2217,40 +2217,34 @@
 
     gprof_end (proc->name);
 
+    if (!*ptr || *ptr == MN_RETURN || *ptr == MN_END || LOCDWORD(r, STATUS) == STATUS_KILLED) {
     /* Check for waiting parent */
-    if (r->called_by && instance_exists(r->called_by)         &&
-        LOCDWORD(r->called_by, STATUS) & STATUS_WAITING_MASK  &&
-        (LOCDWORD(r, STATUS) == STATUS_KILLED || !*ptr || *ptr == MN_RETURN || *ptr == MN_END)
-       )
+        if (r->called_by && instance_exists(r->called_by) && (LOCDWORD(r->called_by, STATUS) & STATUS_WAITING_MASK))
     {
         /* We're returning and the parent is waiting: wake it up */
-        if (r->called_by->stack &&
-            !((*r->called_by->stack) & STACK_NO_RETURN_VALUE)
-           )
-        {
-            r->called_by->stack[(*r->called_by->stack) & STACK_SIZE_MASK] = return_value;
+            if (r->called_by->stack && !(r->called_by->stack[0] & STACK_NO_RETURN_VALUE)) {
+                r->called_by->stack[r->called_by->stack[0] & STACK_SIZE_MASK] = return_value;
         }
+
         LOCDWORD(r->called_by, STATUS) &= ~STATUS_WAITING_MASK;
     }
+        r->called_by = NULL;
 
-    /* The process should be destroyed immediately,
-     * it is a function-type one */
-    if (!*ptr || *ptr == MN_RETURN || *ptr == MN_END || LOCDWORD(r, STATUS) == STATUS_KILLED) // Splinter
-    {
+        /* The process should be destroyed immediately, it is a function-type one */
         /* Ejecuto ONEXIT */
         if ((LOCDWORD(r,STATUS) & ~STATUS_WAITING_MASK) != STATUS_DEAD && r->exitcode) {
             LOCDWORD(r,STATUS) = STATUS_DEAD;
             r->codeptr = r->exitcode;
-            if (r->called_by && instance_exists(r->called_by)) {
-                r->called_by = NULL;
-            }
+
             instance_go(r);
         } else {
             instance_destroy(r);
         }
 
-        if (was_visible)
-            object_list_dirty = 1;
+        /* Apunto global stack a stack_begin (inicio del stack original) */
+        stack_gptr = stack_begin;
+
+        if (was_visible) object_list_dirty = 1;
     }
     else if (LOCDWORD(r, STATUS) != STATUS_KILLED && r->first_run)
     {
@@ -2266,13 +2260,15 @@
         object_list_unsorted = 1;
     }
 
-    if (switchval_string != 0)
-        string_discard(switchval_string);
+//    if (switchval_string != 0) string_discard(switchval_string);
 
     if (debug_next && trace_sentence != -1) {
         force_debug = 1;
         debug_next = 0;
     }
 
+    /* Apunto global stack a stack_begin (inicio del stack original) */
+/*    stack_gptr = stack_begin; */
+
     return return_value;
 }
Index: fxi/src/img_pcx.c
===================================================================
--- fxi/src/img_pcx.c	2007-08-28 14:39:59.000000000 +0200
+++ fxi/src/img_pcx.c	2007-08-28 14:41:16.000000000 +0200
@@ -81,6 +81,10 @@
 	Uint8	Filler[54];
 } PCXheader ;
 
+
+
+static unsigned char colors[256][3] ;
+
 /*
  *  FUNCTION : gr_read_pcx
  *
@@ -94,14 +98,15 @@
  *
  */
 
-GRAPH *
-gr_read_pcx (const char * filename)
+GRAPH * gr_read_pcx (const char * filename)
 {
 	PCXheader header ;
 	file *    file ;
 	int       width, height, x, y, p, count ;
 	GRAPH *   bitmap ;
 	Uint8 *   ptr, ch ;
+	int       i;
+
 
 	file = file_open (filename, "rb") ;
 	if (!file) gr_error (_("%s: Could not open the file\n"), filename) ;
@@ -147,6 +152,25 @@
 				}
 			}
 		}
+
+		if(file_read(file, &ch, 1)==1 && ch == 0x0c) {
+			if (file_read (file, colors, 3 * 256)) {
+				int i ;
+
+				if (!palette_loaded) {
+					for (i = 0 ; i < 256 ; i++) {
+						palette[i].r = colors[i][0] ;
+						palette[i].g = colors[i][1] ;
+						palette[i].b = colors[i][2] ;
+					}
+				}
+
+				bitmap->palette = pal_new2(colors);
+
+				palette_loaded = 1 ;
+				palette_changed = 1 ;
+			}
+		}
 	} else {
 		gr_error (_("%s: unsupported color depth\n"), filename) ;
 	}
Index: fxi/src/img_png.c
===================================================================
--- fxi/src/img_png.c	2007-08-28 14:39:59.000000000 +0200
+++ fxi/src/img_png.c	2007-08-28 14:41:16.000000000 +0200
@@ -144,35 +144,41 @@
     /* Recupera el fichero, convirtiendo a 16 bits si es preciso */
 
     rowbytes = png_get_rowbytes (png_ptr, info_ptr) ;
-    bitmap = bitmap_new (0, width, height, color == PNG_COLOR_TYPE_PALETTE ? 8 : 16, 1) ;
-    if (!bitmap) gr_error (_("Error loading PNG file")) ;
-    if (color == PNG_COLOR_TYPE_PALETTE)
-    {
+    bitmap = bitmap_new (0, width, height, (color == PNG_COLOR_TYPE_PALETTE) ? 8 : 16, 1) ;
+    if (!bitmap) {
+        file_close (png) ;
+        free ( rowpointers ) ;
+        free ( row ) ;
+        return 0 ;
+    }
+
+    if (color == PNG_COLOR_TYPE_PALETTE) {
         /* Read the color palette */
 
-        if (!palette_loaded)
-        {
             png_colorp png_palette = (png_colorp) png_malloc (png_ptr, 256*sizeof(png_color)) ;
-            if (!png_palette)
-                gr_error (_("Out of memory")) ;
-            else
-            {
+        if (!png_palette) gr_error (_("Out of memory")) ;
+
                 png_get_PLTE (png_ptr, info_ptr, &png_palette, &n) ;
 
-                for (n-- ; n <= 255 ; n--)
-                {
+        bitmap->palette = pal_new(NULL);
+
+        for (n = 0; n < 256 ; n++) {
+            bitmap->palette->rgb[n].r = png_palette[n].red;
+            bitmap->palette->rgb[n].g = png_palette[n].green;
+            bitmap->palette->rgb[n].b = png_palette[n].blue;
+            if (!palette_loaded) {
                     palette[n].r = png_palette[n].red;
                     palette[n].g = png_palette[n].green;
                     palette[n].b = png_palette[n].blue;
                 }
             }
 
+        pal_refresh(bitmap->palette);
+
             palette_loaded = 1 ;
             palette_changed = 1 ;
-        }
 
-        for (n = 0 ; n < height ; n++)
-            rowpointers[n] = ((Uint8*)bitmap->data) + n*bitmap->pitch ;
+        for (n = 0 ; n < height ; n++) rowpointers[n] = ((Uint8*)bitmap->data) + n*bitmap->pitch ;
         png_read_image (png_ptr, rowpointers) ;
 
         /* If the depth is less than 8, expand the pixel values */
@@ -260,9 +266,7 @@
             Bmask &= 0xFF0000 ;
             Gmask &= 0x00FF00 ;
             Rmask &= 0x0000FF ;
-        }
-        else
-        {
+        } else {
             Bshift = 8;
             Gshift = 5;
             Rshift = 3;
@@ -271,26 +275,21 @@
             Rmask  = 0x0000F7;
         }
 
-        for (n = 0 ; n < height ; n++)
-        {
+        for (n = 0 ; n < height ; n++) {
             rowpointers[0] = (void *)row ;
             png_read_rows (png_ptr, rowpointers, 0, 1) ;
 
             ptr = (Uint16*) bitmap->data + n*bitmap->pitch/2;
             orig = row ;
-            for (x = 0 ; x < width ; x++)
-            {
+            for (x = 0 ; x < width ; x++) {
                 ARRANGE_DWORD(orig);
 
-                if ((*orig) & 0x80000000)
-                {
-                  *ptr = ((*orig & Rmask) >> Rshift)|
-                     ((*orig & Gmask) >> Gshift)|
-                     ((*orig & Bmask) >> Bshift)  ;
-
+                if ((*orig) & 0x80000000) {
+                  *ptr = ((*orig & Rmask) >> Rshift)|((*orig & Gmask) >> Gshift)|((*orig & Bmask) >> Bshift)  ;
                   if (!*ptr) (*ptr)++ ;
                 }
-                else *ptr = 0 ;
+                else
+                    *ptr = 0 ;
                 ptr++, orig++ ;
             }
         }
@@ -298,8 +297,7 @@
 
     /* Fin */
 
-    if (!setjmp (png_ptr->jmpbuf))
-        png_read_end (png_ptr, 0) ;
+    if (!setjmp (png_ptr->jmpbuf)) png_read_end (png_ptr, 0) ;
     file_close (png) ;
     bitmap->modified = 1 ;
 
@@ -335,6 +333,7 @@
     png_colorp  pal ;
     Uint32      * data, * ptr ;
     Uint16      * orig ;
+    SDL_Color * gpal = NULL;
 
     if (!file) return(0) ;
 
@@ -347,8 +346,7 @@
     png_ptr  = png_create_write_struct (PNG_LIBPNG_VER_STRING, 0, 0, 0) ;
     info_ptr = png_create_info_struct  (png_ptr) ;
 
-    if (!png_ptr || !info_ptr)
-    {
+    if (!png_ptr || !info_ptr) {
         free ( rowpointers ) ;
         fclose(file) ;
         return(0) ;
@@ -356,8 +354,7 @@
 
     /* Error handling... */
 
-    if (setjmp(png_ptr->jmpbuf))
-    {
+    if (setjmp(png_ptr->jmpbuf)) {
         fclose (file) ;
         png_destroy_write_struct (&png_ptr, NULL) ;
         free ( rowpointers ) ;
@@ -368,8 +365,7 @@
 
     /* NOTE: NO SUPPORT FOR ANIMATIONS! */
 
-    if (gr->depth == 8)
-    {
+    if (gr->depth == 8) {
         /* 8 bits PNG file */
         png_set_IHDR (png_ptr, info_ptr, gr->width,
                       gr->height, 8, PNG_COLOR_TYPE_PALETTE,
@@ -377,20 +373,20 @@
                       PNG_FILTER_TYPE_BASE) ;
 
         pal = (png_colorp) png_malloc (png_ptr, 256*sizeof(png_color)) ;
-        if (!pal)
-        {
+        if (!pal) {
             fclose (file) ;
             png_destroy_write_struct (&png_ptr, NULL) ;
             free ( rowpointers ) ;
             return(0) ;
         }
 
+        if (gr->palette) gpal = gr->palette->rgb; else gpal = palette;
+
         /* Generate palette info */
-        for (k = 0 ; k < 256 ; k++)
-        {
-            pal[k].red   = palette[k].r ;
-            pal[k].green = palette[k].g ;
-            pal[k].blue  = palette[k].b ;
+        for (k = 0 ; k < 256 ; k++) {
+            pal[k].red   = gpal[k].r ;
+            pal[k].green = gpal[k].g ;
+            pal[k].blue  = gpal[k].b ;
         }
         png_set_PLTE (png_ptr, info_ptr, pal, 256) ;
         png_write_info (png_ptr, info_ptr) ;
@@ -403,9 +399,7 @@
         /* Free allocated palette... */
         png_free (png_ptr, (png_voidp) pal) ;
         info_ptr->palette = NULL ;
-    }
-    else
-    {
+    } else {
         png_set_IHDR (png_ptr, info_ptr, gr->width,
                       gr->height, 8, PNG_COLOR_TYPE_RGB_ALPHA,
                       PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE,
@@ -413,24 +407,20 @@
         png_write_info (png_ptr, info_ptr) ;
 
         data = malloc (gr->width * gr->height * 4) ;
-        if (!data)
-        {
+        if (!data) {
             fclose (file) ;
             png_destroy_write_struct (&png_ptr, NULL) ;
             free ( rowpointers ) ;
             return(0) ;
         }
-        for (k = 0 ; k < (unsigned)gr->height ; k++)
-        {
+        for (k = 0 ; k < (unsigned)gr->height ; k++) {
             ptr  = data + gr->width * k ; /* uses dword for each pixel! */
             orig = (Uint16 *)gr->data + gr->width * k ;
             rowpointers[k] = (Uint8 *)ptr ;
-            for (i = 0 ; i < (unsigned)gr->width ; i++)
-            {
+            for (i = 0 ; i < (unsigned)gr->width ; i++) {
                 if (*orig == 0 && !(gr->info_flags & GI_NOCOLORKEY))
                     *ptr = 0x00000000 ;
-                else
-                {
+                else {
                     *ptr = ((*orig & 0xf800) >> 8) |
                            ((*orig & 0x07e0) << 5) |
                            ((*orig & 0x001f) << 19)|
Index: fxi/src/instance.c
===================================================================
--- fxi/src/instance.c	2007-08-28 14:38:27.000000000 +0200
+++ fxi/src/instance.c	2007-08-28 14:41:16.000000000 +0200
@@ -53,12 +53,12 @@
 /* destrucción, duplicado, etc.                                           */
 /* ---------------------------------------------------------------------- */
 
-INSTANCE * first_instance = 0 ;
-INSTANCE * last_instance  = 0 ;
+INSTANCE * first_instance = NULL ;
+INSTANCE * last_instance  = NULL ;
 
 /* Priority lists */
 
-static INSTANCE * first_by_priority;
+static INSTANCE * first_by_priority     = NULL ;
 static INSTANCE * iterator_by_priority = NULL;
 static int        iterator_reset = 1;
 
@@ -128,6 +128,10 @@
 	r->inpridata    = NULL ;
 	r->inproc       = NULL ;
 
+    r->switchval        = 0;
+    r->switchval_string = 0;
+    r->cased            = 0;
+
 	r->breakpoint   = 0 ;
 
 	r->private_size = father->private_size ;
@@ -242,6 +246,10 @@
 	r->inpridata    = NULL ;
 	r->inproc       = NULL ;
 
+    r->switchval        = 0;
+    r->switchval_string = 0;
+    r->cased            = 0;
+
 	r->breakpoint   = 0 ;
 
 	r->private_size = proc->private_size ;
@@ -390,8 +398,7 @@
 	while (i)
 	{
 		next = i->next ;
-		if (i != except)
-			instance_destroy (i) ;
+		if (i != except) instance_destroy (i) ;
 		i = next ;
 	}
 }
@@ -417,13 +424,11 @@
 	INSTANCE * father, * bigbro, * smallbro, * smallson, * bigson, * smallerbro=NULL;
 	int n ;
 
-	if (LOCDWORD(r, GRAPHID) != 0)
-		object_list_dirty = 1;
+	if (LOCDWORD(r, GRAPHID) != 0) object_list_dirty = 1;
 
 	LOCDWORD(r, STATUS) = STATUS_RUNNING;
 
-	if (LOCDWORD(r, BOX_X0) != -2)
-		gr_mark_instance(r);
+	if (LOCDWORD(r, BOX_X0) != -2) gr_mark_instance(r);
 
 	/* Actualiza la cuenta de referencia de las variables tipo string */
 
@@ -440,15 +445,11 @@
 
     /* Si tengo hermano mayor */
 	bigbro = instance_get(LOCDWORD(r,BIGBRO)) ;
-	if (bigbro) {
-	    LOCDWORD(bigbro,SMALLBRO) = LOCDWORD(r,SMALLBRO) ;
-	}
+	if (bigbro) LOCDWORD(bigbro,SMALLBRO) = LOCDWORD(r,SMALLBRO) ;
 
     /* Si tengo un hermano */
 	smallbro = instance_get(LOCDWORD(r,SMALLBRO)) ;
-	if (smallbro) {
-	    LOCDWORD(smallbro,BIGBRO) = LOCDWORD(r,BIGBRO) ;
-	}
+	if (smallbro) LOCDWORD(smallbro,BIGBRO) = LOCDWORD(r,BIGBRO) ;
 
     /* Yo, ya estoy fuera */
 
@@ -508,41 +509,28 @@
 
 	/* Quita la instancia de la lista */
 
-	if (r->prev) {
-	    r->prev->next  = r->next ;
-	}
+	if (r->prev) r->prev->next  = r->next ;
 
-	if (r->next) {
-	    r->next->prev = r->prev ;
-	}
+	if (r->next) r->next->prev = r->prev ;
 
-	if (first_instance == r)
-		first_instance = r->next ;
+	if (first_instance == r) first_instance = r->next ;
 
-	if (last_instance == r)
-		last_instance = r->prev ;
+	if (last_instance == r) last_instance = r->prev ;
 
 	/* Remove the instance from the priority list */
-	if (first_by_priority == r)
-		first_by_priority = r->next_by_priority;
+	if (first_by_priority == r) first_by_priority = r->next_by_priority;
 
-	if (r->prev_by_priority)
-		r->prev_by_priority->next_by_priority = r->next_by_priority;
-
-	if (r->next_by_priority)
-		r->next_by_priority->prev_by_priority = r->prev_by_priority;
+	if (r->prev_by_priority) r->prev_by_priority->next_by_priority = r->next_by_priority;
+	if (r->next_by_priority) r->next_by_priority->prev_by_priority = r->prev_by_priority;
 
 	/* Remove the instance from the dirty list */
 
-	if (dirty_list == r)
+	if (dirty_list == r) {
 		dirty_list = r->next_dirty;
-    else if (r->is_dirty)
-	{
+    } else if (r->is_dirty) {
 		INSTANCE * i = dirty_list;
-		while (i)
-		{
-			if (i->next_dirty == r)
-			{
+		while (i) {
+			if (i->next_dirty == r) {
 				i->next_dirty = r->next_dirty;
 				break;
 			}
@@ -550,12 +538,11 @@
 		}
 	}
 
-	if (r->stack)
-		free (r->stack) ;
+	if (r->stack) free (r->stack) ;
 
-	free (r->locdata) ;
-	free (r->pubdata) ;
-	free (r->pridata) ;
+	if (r->locdata) free (r->locdata) ;
+	if (r->pubdata) free (r->pubdata) ;
+	if (r->pridata) free (r->pridata) ;
 	free (r) ;
 }
 
@@ -598,9 +585,8 @@
 	if (scalex == 100 && scaley == 100)
 		scalex = scaley = LOCDWORD(i,GRAPHSIZE);
 
-	gr_get_bbox (&dest, r, x, y,
-		LOCDWORD(i,FLAGS) ^ LOCDWORD(i,XGRAPH_FLAGS),
-		LOCDWORD(i,XGRAPH) ? 0 : LOCDWORD(i,ANGLE),
+	gr_get_bbox (&dest, r, x, y, LOCDWORD(i,FLAGS) ^ LOCDWORD(i,XGRAPH_FLAGS),
+                        		 (LOCDWORD(i,XGRAPH)) ? 0 : LOCDWORD(i,ANGLE),
 		scalex, scaley, gr) ;
 
 	if (LOCDWORD(i, CTYPE) == 1)	/* c_scroll */
@@ -641,8 +627,7 @@
 	if ((LOCDWORD(i,STATUS) & ~STATUS_WAITING_MASK) == STATUS_SLEEPING ||
 	    (LOCDWORD(i,STATUS) & ~STATUS_WAITING_MASK) == STATUS_RUNNING)
 	{
-		if (instance_graph(i))
-			return 1;
+		if (instance_graph(i)) return 1;
 	}
 
 	return 0;
@@ -696,14 +681,10 @@
 {
 	GRAPH * graph = instance_graph(i);
 
-	if (graph && (graph->modified ||
-	              (graph->frames > 0 && graph->next_time < current_time)
-	              )
-	   )
+	if (graph && (graph->modified || (graph->frames > 1 && graph->next_time < current_time)))
 	    return 1;
 
-	return
-	    LOCDWORD(i,SAVED_X)       != LOCDWORD(i,COORDX)		||
+	return  LOCDWORD(i,SAVED_X)       != LOCDWORD(i,COORDX)		||
 		LOCDWORD(i,SAVED_Y)       != LOCDWORD(i,COORDY)		||
 		LOCDWORD(i,SAVED_GRAPH)   != LOCDWORD(i,GRAPHID)	||
 		LOCDWORD(i,SAVED_ANGLE)   != LOCDWORD(i,ANGLE)		||
@@ -800,17 +781,14 @@
 
 INSTANCE * instance_next_by_priority()
 {
-	INSTANCE * i;
-	INSTANCE * j;
-	INSTANCE * best_prev;
-	INSTANCE * best_next;
-
-	if (iterator_by_priority == NULL)
-	{
+	INSTANCE * i = NULL ;
+	INSTANCE * j = NULL ;
+	INSTANCE * best_prev = NULL ;
+	INSTANCE * best_next = NULL ;
+	if (!iterator_by_priority) {
 		// NULL will be returned once and then the list will be reset
 
-		if (!iterator_reset)
-		{
+		if (!iterator_reset) {
 			iterator_reset = 1;
 			return NULL;
 		}
@@ -819,23 +797,18 @@
 		// Add all dirty instances to its place at the list
 
 		i = dirty_list;
-		while (i != NULL)
-		{
+		while (i != NULL) {
 			// Check the priority value
 
-			if (LOCDWORD(i, PRIORITY) < MIN_PRIORITY)
-				LOCDWORD(i, PRIORITY) = MIN_PRIORITY;
-			if (LOCDWORD(i, PRIORITY) > MAX_PRIORITY)
-				LOCDWORD(i, PRIORITY) = MAX_PRIORITY;
+			if (LOCDWORD(i, PRIORITY) < MIN_PRIORITY) LOCDWORD(i, PRIORITY) = MIN_PRIORITY;
+			if (LOCDWORD(i, PRIORITY) > MAX_PRIORITY) LOCDWORD(i, PRIORITY) = MAX_PRIORITY;
 
 			// Remove the instance from the list
 
-			if (i->prev_by_priority)
-				i->prev_by_priority->next_by_priority = i->next_by_priority;
-			if (i->next_by_priority)
-				i->next_by_priority->prev_by_priority = i->prev_by_priority;
-			if (first_by_priority == i)
-				first_by_priority = i->next_by_priority;
+			if (i->prev_by_priority) i->prev_by_priority->next_by_priority = i->next_by_priority;
+			if (i->next_by_priority) i->next_by_priority->prev_by_priority = i->prev_by_priority;
+
+			if (first_by_priority == i) first_by_priority = i->next_by_priority;
 
 			// Add the instance to the list. The easy case is when there is
 			// already some instance with the same priority.
@@ -846,61 +819,48 @@
             i->prev_by_priority = NULL;
 			i->next_by_priority = NULL;
 
-			while (j)
-			{
-				if (LOCDWORD(j, PRIORITY) == LOCDWORD(i, PRIORITY))
-				{
+			while (j) {
+				if (LOCDWORD(j, PRIORITY) == LOCDWORD(i, PRIORITY)) {
 					i->prev_by_priority = j;
 					i->next_by_priority = j->next_by_priority;
 					j->next_by_priority = i;
 
-					if (i->next_by_priority)
-						i->next_by_priority->prev_by_priority = i;
+					if (i->next_by_priority) i->next_by_priority->prev_by_priority = i;
 					break;
-				}
-				else if (LOCDWORD(j, PRIORITY) > LOCDWORD(i, PRIORITY))
-				{
+				} else if (LOCDWORD(j, PRIORITY) > LOCDWORD(i, PRIORITY)) {
 					best_prev = j;
-				}
-				else if (!best_next)
-				{
+				} else if (!best_next) {
 					best_next = j;
 				}
 
 				j = j->next_by_priority;
 			}
 
-			if (j == NULL)
-			{
+			if (!j) {
 				// No best case
-				if (best_prev)
-				{
+				if (best_prev) {
 					// But some instance was found with a lower priority
 
 					i->next_by_priority = best_prev->next_by_priority;
 					best_prev->next_by_priority = i;
 
-					if (i->next_by_priority)
-						i->next_by_priority->prev_by_priority = i;
+					if (i->next_by_priority) i->next_by_priority->prev_by_priority = i;
 
 				    i->prev_by_priority = best_prev; /* Splinter */
-				}
-				else if (best_next)
-				{
+				} else if (best_next) {
 					// But some instance was found with a higher priority
 
 					i->prev_by_priority = best_next->prev_by_priority;
 					best_next->prev_by_priority = i;
 
-					if (i->prev_by_priority)
+					if (i->prev_by_priority) {
 						i->prev_by_priority->next_by_priority = i;
-					else
+					} else {
 						first_by_priority = i;
+					}
 
 				    i->next_by_priority = best_next; /* Splinter */
-				}
-				else
-				{
+				} else {
 					// There are no instances in the list
 
 					first_by_priority   = i;
@@ -915,12 +875,19 @@
 
 		dirty_list = NULL;
 
+		if (first_by_priority)
 		iterator_by_priority = first_by_priority->next_by_priority;
+		else
+		    iterator_by_priority = NULL;
+
 		return first_by_priority;
 	}
 
 	i = iterator_by_priority;
+
+	if (iterator_by_priority)
 	iterator_by_priority = iterator_by_priority->next_by_priority;
+
 	return i;
 }
 
Index: include/files.h
===================================================================
--- include/files.h	2007-08-28 14:38:27.000000000 +0200
+++ include/files.h	2007-08-28 14:41:16.000000000 +0200
@@ -51,6 +51,8 @@
 extern int    file_writeUint16 (file * fp, Uint16 * buffer) ;
 extern int    file_writeSint32 (file * fp, Sint32 * buffer) ;
 extern int    file_writeUint32 (file * fp, Uint32 * buffer) ;
+extern int    file_qgets       (file * fp, char * buffer, int len) ;
+extern int    file_qputs       (file * fp, const char * buffer) ;
 extern int    file_gets        (file * fp, char * buffer, int len) ;
 extern int    file_puts        (file * fp, const char * buffer) ;
 extern int    file_size        (file * fp) ;
Index: include/fxdll.h
===================================================================
--- include/fxdll.h	2007-08-28 14:41:04.000000000 +0200
+++ include/fxdll.h	2007-08-28 14:41:17.000000000 +0200
@@ -136,6 +136,8 @@
 FXEXTERN int    (*_file_write      )(file * fp, const void * buffer, int len) ;
 FXEXTERN int    (*_file_gets       )(file * fp, char * buffer, int len) ;
 FXEXTERN int    (*_file_puts       )(file * fp, const char * buffer) ;
+FXEXTERN int    (*_file_qgets      )(file * fp, char * buffer, int len) ;
+FXEXTERN int    (*_file_qputs      )(file * fp, const char * buffer) ;
 FXEXTERN int    (*_file_size       )(file * fp) ;
 FXEXTERN int    (*_file_pos        )(file * fp) ;
 FXEXTERN int    (*_file_seek       )(file * fp, int pos, int where) ;
@@ -150,6 +152,9 @@
 #define file_read		(*_file_read)
 #define file_write		(*_file_write)
 #define file_gets		(*_file_gets)
+#define file_puts		(*_file_puts)
+#define file_qgets		(*_file_qgets)
+#define file_qputs		(*_file_qputs)
 #define file_size		(*_file_size)
 #define file_pos		(*_file_pos)
 #define file_seek		(*_file_seek)
@@ -407,7 +412,8 @@
 FXEXTERN int          * _fade_on ;               /* ¿Hay un fade activo?                  */
 FXEXTERN int          * _fade_step ;             /* Si lo hay, posición (0=off)           */
 
-FXEXTERN int   (*_gr_read_pal           )(file * file) ;
+FXEXTERN PALETTE *  (*_gr_read_pal           )(file * file) ;
+FXEXTERN PALETTE *  (*_gr_read_pal_with_gamma)(file * file) ;
 FXEXTERN void  (*_gr_refresh_palette    )() ;
 FXEXTERN void  (*_gr_fade_init          )(int r, int g, int b, int speed, int dir) ;
 FXEXTERN void  (*_gr_fade_step          )() ;
@@ -420,6 +426,7 @@
 FXEXTERN void  (*_gr_get_colors         )(int color, int num, Uint8 * pal) ;
 
 #define gr_read_pal				(*_gr_read_pal)
+#define gr_read_pal_with_gamma  (*_gr_read_pal_with_gamma)
 #define gr_refresh_palette		(*_gr_refresh_palette)
 #define gr_fade_init			(*_gr_fade_init)
 #define gr_fade_step			(*_gr_fade_step)
@@ -956,6 +963,8 @@
     _file_write                 = FENIX_import ( "file_write" ); \
     _file_gets                  = FENIX_import ( "file_gets" ); \
     _file_puts                  = FENIX_import ( "file_puts" ); \
+    _file_qgets                 = FENIX_import ( "file_qgets" ); \
+    _file_qputs                 = FENIX_import ( "file_qputs" ); \
     _file_size                  = FENIX_import ( "file_size" ); \
     _file_pos                   = FENIX_import ( "file_pos" ); \
     _file_seek                  = FENIX_import ( "file_seek" ); \
Index: include/offsets.h
===================================================================
--- include/offsets.h	2007-08-28 14:38:27.000000000 +0200
+++ include/offsets.h	2007-08-28 14:41:17.000000000 +0200
@@ -160,28 +160,30 @@
 #define COORDY       	4*24
 #define COORDZ       	4*25
 #define GRAPHID 		4*26
-#define FLAGS   		4*27
-#define GRAPHSIZE    	4*28
-#define ANGLE   		4*29
-#define REGIONID    	4*30
-#define FILEID  		4*31
-#define XGRAPH  		4*32
-#define HEIGHT  		4*33
-#define RESOLUTION		4*34
-#define ALPHA           4*35
-#define GRAPHSIZEX      4*36
-#define GRAPHSIZEY      4*37
-#define BLENDOP			4*38
-#define SAVED_X			4*39
-#define SAVED_Y			4*40
-#define SAVED_GRAPH		4*41
-#define SAVED_ANGLE		4*42
-#define SAVED_ALPHA		4*43
-#define SAVED_BLENDOP	4*44
-#define SAVED_SIZE		4*45
-#define SAVED_SIZEX		4*46
-#define SAVED_SIZEY		4*47
-#define SAVED_FLAGS		4*48
-#define SAVED_FILE		4*49
-#define SAVED_XGRAPH	4*50
-#define SAVED_PRIORITY  4*51
+#define PALETTEID 		4*27
+#define FLAGS   		4*28
+#define GRAPHSIZE    	4*29
+#define ANGLE   		4*30
+#define REGIONID    	4*31
+#define FILEID  		4*32
+#define XGRAPH  		4*33
+#define HEIGHT  		4*34
+#define RESOLUTION		4*35
+#define ALPHA           4*36
+#define GRAPHSIZEX      4*37
+#define GRAPHSIZEY      4*38
+#define BLENDOP			4*39
+#define SAVED_X			4*40
+#define SAVED_Y			4*41
+#define SAVED_GRAPH		4*42
+#define SAVED_PALETTE	4*43
+#define SAVED_ANGLE		4*44
+#define SAVED_ALPHA		4*45
+#define SAVED_BLENDOP	4*46
+#define SAVED_SIZE		4*47
+#define SAVED_SIZEX		4*48
+#define SAVED_SIZEY		4*49
+#define SAVED_FLAGS		4*50
+#define SAVED_FILE		4*51
+#define SAVED_XGRAPH	4*52
+#define SAVED_PRIORITY  4*53
Index: include/pslang.h
===================================================================
--- include/pslang.h	2007-08-28 14:38:27.000000000 +0200
+++ include/pslang.h	2007-08-28 14:41:17.000000000 +0200
@@ -236,7 +236,7 @@
 /* Funciones de cadena (2) */
 
 #define MN_POINTER2STR          (0x75| MN_1_PARAMS)
-#define MN_POINTER2BOL          (0x76| MN_1_PARAMS)
+/* #define MN_POINTER2BOL          (0x76| MN_1_PARAMS) */
 #define MN_STR2INT              (0x77| MN_1_PARAMS)
 #define MN_STR2FLOAT            (0x78| MN_1_PARAMS)
 #define MN_STR2CHR              (0x79| MN_1_PARAMS)
Index: include/sysprocs.h
===================================================================
--- include/sysprocs.h	2007-08-28 14:38:27.000000000 +0200
+++ include/sysprocs.h	2007-08-28 14:41:17.000000000 +0200
@@ -97,7 +97,6 @@
     { 0x5A, "JOY_BUTTONS"           , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_joy_buttons_specific) },
     { 0x5B, "JOY_AXES"              , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_joy_axes_specific) },
 
-
     /* Inicialización y carga */
     { 0x60, "SET_MODE"              , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_set_mode) },
     { 0x61, "SET_FPS"               , "II"    , TYPE_DWORD  , 2 , SYSMACRO(fxi_set_fps) },
@@ -107,6 +106,8 @@
     { 0x64, "UNLOAD_FBM"            , "II"    , TYPE_DWORD  , 2 , SYSMACRO(fxi_unload_map) },
     { 0x65, "UNLOAD_FPG"            , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_unload_fpg) },
     { 0x65, "UNLOAD_FGC"            , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_unload_fpg) },
+
+    /* Informacion de graficos */
     { 0x66, "GRAPHIC_SET"           , "IIII"  , TYPE_DWORD  , 4 , SYSMACRO(fxi_graphic_set) },
     { 0x67, "GRAPHIC_INFO"          , "III"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_graphic_info) },
 
@@ -141,6 +142,7 @@
     { 0x81, "MAP_SET_NAME"          , "IIS"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_map_set_name) },
     { 0x82, "MAP_EXISTS"            , "II"    , TYPE_DWORD  , 2 , SYSMACRO(fxi_map_exists) },
     { 0x83, "MAP_XPUTNP"            , "IIIIIIIIIII",TYPE_DWORD , 10 , SYSMACRO(fxi_map_xputnp) },
+
     { 0x84, "FPG_EXISTS"            , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_fpg_exists) },
 
     /* FPG */
@@ -148,9 +150,11 @@
     { 0x8B, "NEW_FPG"               , ""      , TYPE_DWORD  , 0 , SYSMACRO(fxi_fpg_new) },
     { 0x8B, "FPG_NEW"               , ""      , TYPE_DWORD  , 0 , SYSMACRO(fxi_fpg_new) },
 
-    /* Textos */
+    /* Fonts */
     { 0x90, "LOAD_FNT"              , "S"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_load_fnt) },
     { 0x91, "UNLOAD_FNT"            , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_unload_fnt) },
+
+    /* Textos */
     { 0x92, "WRITE"                 , "IIIIS" , TYPE_DWORD  , 5 , SYSMACRO(fxi_write) },
     { 0x93, "WRITE_INT"             , "IIIIP" , TYPE_DWORD  , 5 , SYSMACRO(fxi_write_int) },
     { 0x94, "MOVE_TEXT"             , "III"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_move_text) },
@@ -158,6 +162,8 @@
     { 0x96, "WRITE_IN_MAP"          , "ISI"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_write_in_map) },
     { 0x97, "TEXT_WIDTH"            , "IS"    , TYPE_DWORD  , 2 , SYSMACRO(fxi_text_width) },
     { 0x98, "TEXT_HEIGHT"           , "IS"    , TYPE_DWORD  , 2 , SYSMACRO(fxi_text_height) },
+
+    /* Fonts */
     { 0x99, "SAVE_FNT"              , "IS"    , TYPE_DWORD  , 2 , SYSMACRO(fxi_save_fnt) },
     { 0x9A, "LOAD_BDF"              , "S"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_load_bdf) },
 
@@ -209,26 +215,32 @@
     { 0xD9, "ASC"                   , "S"     , TYPE_BYTE   , 1 , SYSMACRO(fxi_asc) },
     { 0xDA, "CHR"                   , "I"     , TYPE_STRING , 1 , SYSMACRO(fxi_chr) },
 
-    /* Extensiones adicionales */
+    /* Importacion de archivos graficos */
     { 0xE0, "LOAD_PNG"              , "S"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_load_png) },
     { 0xE1, "LOAD_PCX"              , "S"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_load_pcx) },
+
+    /* Manipulacion de mapas bitmap */
     { 0xEB, "MAP_BUFFER"            , "II"    , TYPE_POINTER, 2 , SYSMACRO(fxi_map_buffer) },
+
+    /* Manipulacion de la Paleta */
     { 0xEC, "SET_COLORS"            , "IIP"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_set_colors) },
+    { 0xEC, "PAL_SET"               , "IIP"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_set_colors) },
     { 0xED, "GET_COLORS"            , "IIP"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_get_colors) },
+    { 0xED, "PAL_GET"               , "IIP"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_get_colors) },
 
     { 0xEE, "EXISTS"                , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_running) },
 
     /* Manipulacion de Memoria */
-    { 0xEF, "MEMORY_TOTAL"          , ""      , TYPE_DWORD  , 0 , SYSMACRO(fxi_memory_total) },
-    { 0xF0, "ALLOC"                 , "I"     , TYPE_POINTER, 1 , SYSMACRO(fxi_alloc) },
-    { 0xF1, "FREE"                  , "P"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_free) },
-    { 0xF2, "REALLOC"               , "PI"    , TYPE_POINTER, 2 , SYSMACRO(fxi_realloc) },
-    { 0xF3, "MEMCMP"                , "PPI"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_memcmp) },
-    { 0xF4, "MEMSET"                , "PBI"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_memset) },
-    { 0xF5, "MEMSETW"               , "PWI"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_memsetw) },
-    { 0xF6, "MEMCOPY"               , "PPI"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_memcopy) },
+    { 0xEF, "ALLOC"                 , "I"     , TYPE_POINTER, 1 , SYSMACRO(fxi_alloc) },
+    { 0xF0, "FREE"                  , "P"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_free) },
+    { 0xF1, "REALLOC"               , "PI"    , TYPE_POINTER, 2 , SYSMACRO(fxi_realloc) },
+    { 0xF2, "MEMCMP"                , "PPI"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_memcmp) },
+    { 0xF3, "MEMSET"                , "PBI"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_memset) },
+    { 0xF4, "MEMSETW"               , "PWI"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_memsetw) },
+    { 0xF5, "MEMCOPY"               , "PPI"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_memcopy) },
 
-    { 0xF7, "MEMORY_FREE"           , ""      , TYPE_DWORD  , 0 , SYSMACRO(fxi_memory_free) },
+    { 0xF6, "MEMORY_FREE"           , ""      , TYPE_DWORD  , 0 , SYSMACRO(fxi_memory_free) },
+    { 0xF7, "MEMORY_TOTAL"          , ""      , TYPE_DWORD  , 0 , SYSMACRO(fxi_memory_total) },
 
     /* Funciones de primitivas */
     { 0xF8, "DRAWING_MAP"           , "II"    , TYPE_DWORD  , 2 , SYSMACRO(fxi_drawing_map) },
@@ -294,7 +306,7 @@
 
     { 0x14C, "PLAY_WAV"             , "III"  , TYPE_DWORD   , 3 , SYSMACRO(fxi_play_wav_channel) },
 
-    /* funciones de MAQ */
+    /* Funciones de MAQ */
     { 0x150, "GRAYSCALE"            , "IIB"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_grayscale) },
     { 0x151, "RGBSCALE"             , "IIFFF" , TYPE_DWORD  , 5 , SYSMACRO(fxi_rgbscale)},
     { 0x152, "BLUR"                 , "IIB"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_blur)},
@@ -313,9 +325,11 @@
     { 0x168, "GET_RGB"              , "IPPP"  , TYPE_DWORD  , 4 , SYSMACRO(fxi_get_rgb) },
     { 0x169, "LOAD_FPL"             , "S"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_load_fpl) },
 
-    /* Nuevas funciones en la 0.83 */
+    /* Video */
     { 0x16A, "GET_SCREEN"           , ""      , TYPE_DWORD  , 0 , SYSMACRO(fxi_get_screen) },
     { 0x16B, "SET_MODE"             , "III"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_set_mode_3) },
+
+    /* String */
     { 0x16C, "SUBSTR"               , "SI"    , TYPE_STRING , 2 , SYSMACRO(fxi_substr2) },
     { 0x16D, "TRIM"                 , "S"     , TYPE_STRING , 1 , SYSMACRO(fxi_trim) },
     { 0x16E, "FORMAT"               , "I"     , TYPE_STRING , 1 , SYSMACRO(fxi_formatI) },
@@ -326,18 +340,24 @@
     { 0x173, "LPAD"                 , "SI"    , TYPE_STRING , 2 , SYSMACRO(fxi_lpad) },
     { 0x174, "RPAD"                 , "SI"    , TYPE_STRING , 2 , SYSMACRO(fxi_rpad) },
     { 0x175, "STRCASECMP"           , "SS"    , TYPE_DWORD  , 2 , SYSMACRO(fxi_strcasecmp) },
+
+    /* Exportacion de mapas Graficos */
     { 0x176, "SAVE_PNG"             , "IIS"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_save_png) },
+
+    /* Regex */
     { 0x177, "REGEX"                , "SS"    , TYPE_DWORD  , 2 , SYSMACRO(fxi_regex) },
     { 0x178, "REGEX_REPLACE"        , "SSS"   , TYPE_STRING , 3 , SYSMACRO(fxi_regex_replace) },
     { 0x179, "SPLIT"                , "SSPI"  , TYPE_DWORD  , 4 , SYSMACRO(fxi_split) },
     { 0x17A, "JOIN"                 , "SPI"   , TYPE_STRING , 3 , SYSMACRO(fxi_join) },
+
+    /* Primitivas */
     { 0x17B, "DRAW_CURVE"           , "IIIIIIIII", TYPE_DWORD,9 , SYSMACRO(fxi_bezier) },
     { 0x17C, "DRAWING_Z"            , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_drawing_at) },
     { 0x17D, "DELETE_DRAW"          , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_delete_drawing) },
     { 0x17E, "MOVE_DRAW"            , "III"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_move_drawing) },
     { 0x17F, "DRAWING_ALPHA"        , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_drawing_alpha) },
 
-    /* Nuevas funciones en la 0.84 */
+    /* Archivos y directorios */
     { 0x180, "CD"                   , ""      , TYPE_STRING , 0 , SYSMACRO(fxi_cd) } ,
     { 0x181, "CHDIR"                , "S"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_chdir) },
     { 0x182, "MKDIR"                , "S"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_mkdir) } ,
@@ -346,21 +366,31 @@
     { 0x185, "GLOB"                 , "S"     , TYPE_STRING , 1 , SYSMACRO(fxi_glob) },
     { 0x186, "CD"                   , "S"     , TYPE_STRING , 1 , SYSMACRO(fxi_chdir) } ,
     { 0x187, "RM"                   , "S"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_rm) } ,
+
+    /* Video */
     { 0x18F, "SET_MODE"             , "II"    , TYPE_DWORD  , 2 , SYSMACRO(fxi_set_mode_2) },
     { 0x190, "GET_TEXT_COLOR"       , ""      , TYPE_DWORD  , 0 , SYSMACRO(fxi_get_text_color) },
+
+    /* Fonts */
     { 0x199, "NEW_FNT"              , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_fnt_new) },
     { 0x199, "FNT_NEW"              , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_fnt_new) },
     { 0x19A, "GET_GLYPH"            , "II"    , TYPE_DWORD  , 2 , SYSMACRO(fxi_get_glyph) },
     { 0x19B, "SET_GLYPH"            , "IIII"  , TYPE_DWORD  , 4 , SYSMACRO(fxi_set_glyph) },
+
+    /* Video */
     { 0x19C, "SET_MODE"             , "IIII"  , TYPE_DWORD  , 4 , SYSMACRO(fxi_set_mode_4) },
+
+    /* Primitivas */
     { 0x19D, "DRAWING_STIPPLE"      , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_drawing_stipple) },
+
+    /* Paleta */
     { 0x19E, "SAVE_PAL"             , "S"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_save_pal) },
     { 0x19F, "SAVE_FPL"             , "S"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_save_fpl) },
 
-    /* Nuevas funciones en la 0.85 */
+    /* Uso interno */
     { 0x1A0, "#COPY#"               , "PV++I" , TYPE_POINTER, 5 , SYSMACRO(fxi_copy_struct) },
 
-    /* Carga de archivos */
+    /* Carga/Grabacion de archivos */
     { 0x1A1, "LOAD_FBM"             , "S"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_load_fbm) },
     { 0x1A2, "SAVE_FBM"             , "IIS"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_save_fbm) },
     { 0x1A3, "LOAD_FGC"             , "S"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_load_fgc) },
@@ -377,8 +407,8 @@
     { 0x1AC, "CD_PAUSE"             , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_cd_pause) },
     { 0x1AD, "CD_RESUME"            , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_cd_resume) },
     { 0x1AE, "CD_EJECT"             , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_cd_eject) },
-    { 0x1AF, "CD_NUMTRACKS"         , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_cd_numtracks) },
-    { 0x1B0, "CD_CURRTRACK"         , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_cd_getcurtrack) },
+/*    { 0x1AF, "CD_NUMTRACKS"         , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_cd_numtracks) },
+    { 0x1B0, "CD_CURRTRACK"         , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_cd_getcurtrack) },*/
 
     /* Funciones de ventana */
     { 0x1B1, "MINIMIZE"             , ""      , TYPE_DWORD  , 0 , SYSMACRO(fxi_minimize) },
@@ -394,8 +424,26 @@
     { 0x1B7, "LOAD_FPG"             , "SP"    , TYPE_DWORD  , 2 , SYSMACRO(fxi_bgload_fpg) },
     { 0x1B8, "LOAD_FGC"             , "SP"    , TYPE_DWORD  , 2 , SYSMACRO(fxi_bgload_fgc) },
 
+    /* Misc */
     { 0x1C0, "GETENV"               , "S"     , TYPE_STRING , 1 , SYSMACRO(fxi_getenv) },
 
+    /* Paleta */
+    { 0x1C1, "NEW_PAL"              , ""      , TYPE_DWORD  , 0 , SYSMACRO(fxi_pal_create) },
+    { 0x1C1, "PAL_NEW"              , ""      , TYPE_DWORD  , 0 , SYSMACRO(fxi_pal_create) },
+    { 0x1C2, "PAL_CLONE"            , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_pal_clone) },
+    { 0x1C3, "UNLOAD_PAL"           , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_pal_unload) },
+    { 0x1C4, "PAL_REFRESH"          , ""      , TYPE_DWORD  , 0 , SYSMACRO(fxi_pal_refresh) },
+    { 0x1C5, "PAL_REFRESH"          , "I"     , TYPE_DWORD  , 1 , SYSMACRO(fxi_pal_refresh_2) },
+
+    { 0x1C6, "PAL_MAP_GETID"        , "II"    , TYPE_DWORD  , 2 , SYSMACRO(fxi_pal_map_getid) },
+    { 0x1C7, "PAL_MAP_ASSIGN"       , "III"   , TYPE_DWORD  , 3 , SYSMACRO(fxi_pal_map_assign) },
+    { 0x1C8, "PAL_MAP_REMOVE"       , "II"    , TYPE_DWORD  , 2 , SYSMACRO(fxi_pal_map_remove) },
+
+    { 0x1C9, "SET_COLORS"           , "IIIP"  , TYPE_DWORD  , 4 , SYSMACRO(fxi_pal_set) },
+    { 0x1C9, "PAL_SET"              , "IIIP"  , TYPE_DWORD  , 4 , SYSMACRO(fxi_pal_set) },
+    { 0x1CA, "GET_COLORS"           , "IIIP"  , TYPE_DWORD  , 4 , SYSMACRO(fxi_pal_get) },
+    { 0x1CA, "PAL_GET"              , "IIIP"  , TYPE_DWORD  , 4 , SYSMACRO(fxi_pal_get) },
+
     { 0    , 0                      , ""      , 0           , 0 , 0  }
 } ;
 
Index: NEWS
===================================================================
--- NEWS	2007-08-28 14:38:27.000000000 +0200
+++ NEWS	2007-08-28 14:41:17.000000000 +0200
@@ -1,3 +1,85 @@
+0.93
+- Se corrige convesion a negativo de números unsigned.
+- Ahora no es necesario declarar las privadas en el declare, se pueden declarar junto a la funcion.
+- Posicionamiento del mouse en mitad de pantalla al hacer set_mode.
+- Se mejora la performance en el uso de dirty. En algunos casos hasta un 800%.
+- Se corrije soporte de VSYNC, solo si no se usa dirty, y si el hardware lo soporta.
+Se requiere para esto especificar MODE_DOUBLEBUFFER | MODE_HARDWARE, en los flags del modo de video.
+- Se optimizan funciones de draw, incluido limpieza de dirty cuando no hay grafico de fondo.
+- Correccion en calculo de coordenadas del mouse en modo escalado.
+- Soporte de operaciones bitwise sobre datos unsigned.
+- Se corrige y normaliza comportamiento e implementacion de dirtyrects.
+- Soporte completo de primitivas de dibujo con profundidad de 1bbp.
+- Se corrige comportamiento circular en funciones GET_ID y COLLISION.
+- Se reescribe RAND para mejor funcionalidad.
+- Se corrige carga de paleta en todos los graficos.
+- Se corrige liberacion de memoria ante errores en cargas de graficos.
+- Se corrige informacion del track dentro de la estructura cdinfo
+- Se eliminan las siguientes funciones, por ser imnecesarias:
+    CD_NUMTRACKS(cdnumber)
+    CD_CURRTRACK(cdnumber)
+- Se corrige FADE en 16 bits.
+- Se corrige soporte de angle en mapas animados.
+- Se corrigen problemas de liberacion de stack cuando muere un proceso.
+- Se corrige error de tipeo en comando de consola WEAKUP* por WAKEUP*.
+- Correccion de estructuras de bloque, con uso de break y continue, para los casos
+REPEAT/UNTIL, FOR/END y FROM/END (viejo, viejo, muy viejo... :D)
+- Fix en uso de scrbitmap_is_fake que provocaba cuelgues aleatoreos tras muchos set_mode.
+  (viejo bug que me estaba volviendo loco y no podia detectar)
+- Se corrige compilador en uso de sysprocs con igual nombre y distintos tipos de parametros.
+- Se corrige error "Conflicto con declaracion previa",
+  al compilar con tipos de datos numeros con posibilidad de signos.
+- Se mejora la operatoria de debug.
+- Ahora una llamada a un proceso/funcion, siempre crea una nueva instancia.
+- Se mejora la ejecucion de procesos (estabilidad)
+- Se da soporte a carga de paletas en pcx (8 bits)
+- Ahora cada grafico de 8 bits puede tener su paleta individual,
+  en modo 16 bits se visualizan perfectamente aunque tengan paletas diferentes.
+- Se agregan las siguientes funciones para el manejo de paletas (solo graficos de 8 bits):
+    int LOAD_PAL(file);
+        Carga la paleta del sistema y devuelve un id de paleta.
+        Retorna 0, ante algun error.
+        NOTA: Cuando no se utilicen mas las paletas hay que liberalas usando el comando UNLOAD_PAL.
+
+    int NEW_PAL();
+    int PAL_NEW();
+        Crea una nueva paleta. Retorna id de paleta.
+
+    int PAL_CLONE(palid);
+        Clona una paleta. Retorna id de la nueva paleta.
+
+    int UNLOAD_PAL(palid);
+        Descarga de memoria una paleta. Si esta esta siendo usada por mas de 1 grafico, se descuenta el contador de usos.
+
+    int PAL_REFRESH([palid]);
+        Refresca una paleta luego de ser seteados sus valores.
+        Esto es util para actualizar las tablas de equivalencia de colores.
+        Se debe usar si pasamos de modo de video 8 a 16 bits.
+        Si no se pasa "palid", se actualizan todas las paletas.
+
+    int PAL_MAP_GETID(file, graph);
+        Retorna el identificador de paleta asignado al grafico "file/graph".
+        En caso de no existir paleta asignada, retorna 0.
+
+    int PAL_MAP_ASSIGN(file, graph, palid);
+        Asigna una paleta a un grafico. Si el grafico ya tenia paleta, descarga previamente la anterior.
+
+    int PAL_MAP_REMOVE(file, graph);
+        Elimina la asignacion de paleta a un grafico.
+
+    int SET_COLORS(palid, color inicial, cantidad de colores, puntero a paleta[768 bytes]);
+    int PAL_SET(palid, color inicial, cantidad de colores, puntero a paleta[768 bytes]);
+        Similar a la existente SET_COLORS, salvo que ahora se le agrega identificador de paleta.
+        Esta no reemplaza a la ya existente, sino que se agrega.
+
+    int GET_COLORS(palid, color inicial, cantidad de colores, puntero a paleta[768 bytes]);
+    int PAL_GET(palid, color inicial, cantidad de colores, puntero a paleta[768 bytes]);
+        Similar a la existente GET_COLORS, salvo que ahora se le agrega identificador de paleta.
+        Esta no reemplaza a la ya existente, sino que se agrega.
+
+NOTA: Las funciones de carga de mapas(map, pcx, fbm, fgc, png, etc) crean paleta/s,
+que no son necesarias eliminar al eliminar el mapa, pero si se pueden manipular o eliminar del mapa.
+
 0.92a
 - Fix para evitar reentradas dentro de la funcion bitmap_16bits_conversion, llamada por gr_init (set_mode)
 - Correccion substr, por incorrecto calculo con negativos.
@@ -45,7 +127,7 @@
 - Se trimean lineas de debug (trace de ejecucion o debug a archivo)
 - Se corrige inicializaciones en funcion instance_new y se corrige logica de instance_duplicate,
   esto afectaba al comando CLONE, y provocaba cuelgues aleatorios
-- Se agregan a la consola de debug los comandos KILLALL, WEAKUPALL, SLEEPALL, FREEZEALL.
+- Se agregan a la consola de debug los comandos KILLALL, WAKEUPALL, SLEEPALL, FREEZEALL.
 - Se corrige creacion, borrado y movimientos de primitivas draw, causado en un mal manejo de asignacion y borrado.
   Provocaba que aparezcan draws eliminados o que se eliminen draws que no se deseaba.
 
@@ -66,7 +148,7 @@
 
     RUN proc [args]     Ejecuta un proceso
     KILL proc           Elimina un proceso
-    WEAKUP proc         Despierta un proceso
+    WAKEUP proc         Despierta un proceso
     SLEEP proc          Duerme un proceso
     FREEZE proc         Congela un proceso
 
