
Index: fxi/src/i_debug.c
===================================================================
--- fxi/src/i_debug.c	2007-08-28 14:39:58.000000000 +0200
+++ fxi/src/i_debug.c	2007-08-28 14:41:14.000000000 +0200
@@ -155,7 +155,7 @@
     { "STR2FLOAT", MN_STR2FLOAT, 1 },
     { "FLOAT2STR", MN_FLOAT2STR, 1 },
     { "POINTER2STR", MN_POINTER2STR, 1 },
-    { "POINTER2BOL", MN_POINTER2BOL, 1 },
+//    { "POINTER2BOL", MN_POINTER2BOL, 1 },
 
     { "A2STR", MN_A2STR, 0 },
     { "STR2A", MN_STR2A, 0 },
@@ -238,7 +238,7 @@
     if (dcb.data.NID && dcbproc->data.ID) {
         sprintf (buffer, "%s", getid(dcbproc->data.ID)) ;
     } else {
-        sprintf (buffer, "%s", proc->type == 0 ? "MAIN":"PROC") ;
+        sprintf (buffer, "%s", (proc->type == 0) ? "MAIN":"PROC") ;
     }
 
     line[0] = 0 ;
@@ -283,7 +283,7 @@
             if (dcb.data.NID && dcbproc->data.ID) {
                 sprintf (buffer, "%s", getid(dcbproc->data.ID)) ;
             } else {
-                sprintf (buffer, "%s", proc->type == 0 ? "MAIN":"PROC") ;
+                sprintf (buffer, "%s", (proc->type == 0) ? "MAIN":"PROC") ;
             }
 
             line[0] = 0 ;
Index: fxi/src/i_func.c
===================================================================
--- fxi/src/i_func.c	2007-08-28 14:41:05.000000000 +0200
+++ fxi/src/i_func.c	2007-08-28 14:41:15.000000000 +0200
@@ -173,10 +173,10 @@
 
 static int fxi_rand (INSTANCE * my, int * params)
 {
-    int num1 = params[0] ;
-    int num2 = params[1] ;
+    int num1 = MIN(params[0], params[1]) ;
+    int num2 = MAX(params[0], params[1]) ;
 
-    return num1 + (int)(((double)(num2-num1+1) * rand()) / (RAND_MAX+1.0)) ;
+    return num1 + (rand()%(num2-num1+1)) ;
 }
 
 static int fxi_rand_seed (INSTANCE * my, int * params)
@@ -188,7 +188,7 @@
 static int fxi_abs (INSTANCE * my, int * params)
 {
     float num = *(float *)&params[0] ;
-    float res = num < 0 ? -num:num ;
+    float res = (num < 0) ? -num:num ;
     return *(int *)&res ;
 }
 
@@ -204,11 +204,11 @@
     double dy = params[3] - params[1] ;
     int angle ;
 
-    if (dx == 0) return dy > 0 ? 270000 : 90000 ;
+    if (dx == 0) return (dy > 0) ? 270000L : 90000L ;
 
     angle = (int) (atan(dy / dx) * 180000.0 / M_PI) ;
 
-    return dx > 0 ? -angle:-angle+180000 ;
+    return (dx > 0) ? -angle:-angle+180000L ;
 }
 
 static int fxi_fget_dist (INSTANCE * my, int * params)
@@ -225,11 +225,11 @@
     int dest  = params[1] ;
     int incr  = params[2] ;
 
-    if (angle < dest && dest-angle > 180000)
-        angle += 360000 ;
+    if (angle < dest && dest-angle > 180000L)
+        angle += 360000L ;
 
-    if (angle > dest && angle-dest > 180000)
-        angle -= 360000 ;
+    if (angle > dest && angle-dest > 180000L)
+        angle -= 360000L ;
 
     if (angle < dest)
     {
@@ -242,8 +242,8 @@
         if (angle < dest) angle = dest ;
     }
 
-    if (angle < 0) return angle + 360000 ;
-    if (angle >= 360000) return angle - 360000 ;
+    if (angle < 0) return angle + 360000L ;
+    if (angle >= 360000L) return angle - 360000L ;
     return angle ;
 }
 
@@ -397,7 +397,7 @@
             if (instance_visible(i))
                 gr_mark_instance(i);
 
-            switch (params[1] >= 100 ? params[1]-100 : params[1])
+            switch ((params[1] >= 100) ? params[1]-100 : params[1])
             {
                 case 0:     /* S_KILL */
                     LOCDWORD(i, STATUS) = (LOCDWORD(i, STATUS) & STATUS_WAITING_MASK) | STATUS_KILLED ;
@@ -516,6 +516,7 @@
 
     if (!params[0])
     {
+        LOCDWORD(my, TYPE_SCAN) = 0 ;
         if (LOCDWORD(my, ID_SCAN))
         {
             ptr = instance_get (LOCDWORD(my,ID_SCAN)) ;
@@ -530,10 +531,10 @@
             }
             ptr = ptr->next ;
         }
-        LOCDWORD(my,ID_SCAN) = 0 ;
         return 0 ;
     }
 
+    LOCDWORD(my, ID_SCAN) = 0 ;
     if (LOCDWORD(my,TYPE_SCAN))
     {
         ptr = instance_get (LOCDWORD(my,TYPE_SCAN)) ;
@@ -554,7 +555,6 @@
         }
         ptr = ptr->next ;
     }
-    LOCDWORD(my,TYPE_SCAN) = 0 ;
     return 0 ;
 }
 
@@ -709,13 +709,14 @@
 
     scalex = LOCDWORD(i,GRAPHSIZEX);
     scaley = LOCDWORD(i,GRAPHSIZEY);
-    if (scalex == 100 && scaley == 100)
-        scalex = scaley = LOCDWORD(i,GRAPHSIZE);
+    if (scalex == 100 && scaley == 100) scalex = scaley = LOCDWORD(i,GRAPHSIZE);
 
     map = instance_graph (i) ;
     if (!map) return ;
+
     // PATCH - XGRAPH DOES NOT ROTATE DESTINATION GRAPHIC
-    if (LOCDWORD(i,ANGLE) || scaley != 100 || scalex != 100) {
+    if ((map->current_keyframe >= 0 && map->keyframes[map->current_keyframe].angle) ||
+        LOCDWORD(i,ANGLE) || scaley != 100 || scalex != 100) {
         if (LOCDWORD(i,XGRAPH) && scalex == 100 && scaley == 100) {
             gr_blit (dest, r, x, y, LOCDWORD(i,FLAGS), map) ;
         } else {
@@ -785,10 +786,8 @@
 
     /* Creates a temporary bitmap (only once) */
 
-    if (!bmp)
-        bmp = bitmap_new (0, 2, 2, enable_16bits ? 16:8, 1) ;
-    if (!bmp)
-        return 0 ;
+    if (!bmp) bmp = bitmap_new (0, 2, 2, enable_16bits ? 16:8, 1) ;
+    if (!bmp) return 0 ;
     memset (bmp->data, 0, 2) ;
 
     /* Retrieves process information */
@@ -810,11 +809,9 @@
             {
                 REGION * r = scrolls[i].region;
 
-                if (r->x > mx || r->x2 < mx || r->y > my || r->y2 < my)
-                    continue;
+                if (r->x > mx || r->x2 < mx || r->y > my || r->y2 < my) continue;
                 draw_at (bmp, x+r->x-mx-scrolls[i].posx0, y+r->y-my-scrolls[i].posy0, &bbox1, proc1);
-                if (enable_16bits ? *(Uint16 *)bmp->data : *(Uint8 *)bmp->data)
-                    return 1;
+                if (enable_16bits ? *(Uint16 *)bmp->data : *(Uint8 *)bmp->data) return 1;
             }
         }
         return 0;
@@ -856,8 +853,8 @@
         bitmap_destroy (bmp) ;
         return 0;
     }
-    memset (bmp->data, 0, w*h*(depth == 16?2:1)) ;
-    memset (bmp2->data, 0, w*h*(depth == 16?2:1)) ;
+    memset (bmp->data, 0, w*h*((depth == 16)?2:1)) ;
+    memset (bmp2->data, 0, w*h*((depth == 16)?2:1)) ;
 
     get_pos (proc1, &x, &y) ;
     x -= bbox1.x ;
@@ -919,20 +916,18 @@
 {
     INSTANCE * ptr = instance_get(params[0]) ;
 
-    if (params[0] == -1)
-        return check_collision_with_mouse(my) ? 1:0 ;
+    if (params[0] == -1) return (check_collision_with_mouse(my)) ? 1 : 0 ;
 
     /* ADDED IN 0.74 - Checks only for a single instance */
-    /*DEBUG*/
 
-    if (params[0] >= FIRST_INSTANCE_ID && ptr)
-        return check_collision(my,ptr) ;
+    if (params[0] >= FIRST_INSTANCE_ID && ptr) return check_collision(my,ptr) ;
 
     /* we must use full list of instances or get types from it */
     ptr = first_instance ;
 
     if (!params[0])
     {
+        LOCDWORD(my, TYPE_SCAN) = 0 ;
         if (LOCDWORD(my, ID_SCAN))
         {
             ptr = instance_get (LOCDWORD(my, ID_SCAN)) ;
@@ -954,17 +949,18 @@
             }
             ptr = ptr->next ;
         }
-        LOCDWORD (my, ID_SCAN) = 0 ;
         return 0 ;
     }
 
+    LOCDWORD (my, ID_SCAN) = 0 ;
     if (LOCDWORD(my,TYPE_SCAN))
     {
         ptr = instance_get (LOCDWORD(my,TYPE_SCAN)) ;
-        if (ptr && LOCDWORD(ptr,PROCESS_TYPE) != params[0]) ptr = first_instance ;
-        else if (ptr) ptr = ptr->next ;
+        if (ptr && LOCDWORD(ptr, PROCESS_TYPE) != params[0])
+            ptr = first_instance ;
+        else if (ptr)
+            ptr = ptr->next ;
     }
-
     while (ptr)
     {
         if (LOCDWORD(ptr,PROCESS_TYPE) == params[0] && ptr != my)
@@ -979,7 +975,6 @@
         }
         ptr = ptr->next ;
     }
-    LOCDWORD(my,TYPE_SCAN) = 0 ;
     return 0 ;
 }
 
@@ -1033,7 +1028,7 @@
     if (params[0]>1600 || params[1]>1400)
         gr_error (_("Unsupported graphic mode"));
 
-    GLODWORD(GRAPH_MODE) = ((GLODWORD(GRAPH_MODE) & 0xFF) | params[2]);
+    GLODWORD(GRAPH_MODE) = ((GLODWORD(GRAPH_MODE) & 0xFF00) | params[2]);
     gr_init(params[0], params[1]) ;
     return 1 ;
 }
@@ -1165,10 +1160,71 @@
 
 /* Paleta de colores */
 
+
+static int fxi_pal_create (INSTANCE * my, int * params)
+{
+    return (int) pal_new((PALETTE *)NULL) ;
+}
+
+static int fxi_pal_clone (INSTANCE * my, int * params)
+{
+    return (int) pal_new((PALETTE *)(params[0])) ;
+}
+
+static int fxi_pal_unload (INSTANCE * my, int * params)
+{
+    pal_destroy((PALETTE *)(params[0])) ;
+    return 1;
+}
+
+static int fxi_pal_refresh (INSTANCE * my, int * params)
+{
+    pal_refresh(NULL) ;
+    return 1;
+}
+
+static int fxi_pal_refresh_2 (INSTANCE * my, int * params)
+{
+    pal_refresh((PALETTE *)(params[0]));
+    return 1;
+}
+
+static int fxi_pal_map_assign (INSTANCE * my, int * params)
+{
+    return pal_map_assign (params[0], params[1], (PALETTE *)(params[2]));
+}
+
+static int fxi_pal_map_remove (INSTANCE * my, int * params)
+{
+    return pal_map_remove (params[0], params[1]);
+}
+
+static int fxi_pal_map_getid (INSTANCE * my, int * params)
+{
+    GRAPH * bmp = bitmap_get (params[0], params[1]) ;
+    if (!bmp || bmp->depth != 8) return 0 ;
+    return (int) bmp->palette ;
+}
+
+static int fxi_pal_set (INSTANCE * my, int * params)
+{
+    return (pal_set ((PALETTE *)(params[0]), params[1], params[2], (Uint8 *)params[3])) ;
+}
+
+static int fxi_pal_get (INSTANCE * my, int * params)
+{
+    return (pal_get ((PALETTE *)(params[0]), params[1], params[2], (Uint8 *)params[3])) ;
+}
+
+
 static int fxi_load_fpl (INSTANCE * my, int * params)
 {
     const char * palname = string_get (params[0]) ;
-    int r = palname ? fpl_load(palname) : 0 ;
+    int r ;
+    int old_palette_loaded = palette_loaded ;
+    palette_loaded = 0 ;
+    r = palname ? fpl_load(palname) : 0 ;
+    if (!r) palette_loaded = old_palette_loaded ;
     string_discard (params[0]) ;
     return r ;
 }
@@ -1184,7 +1240,11 @@
 static int fxi_load_pal (INSTANCE * my, int * params)
 {
     const char * palname = string_get (params[0]) ;
-    int r = palname ? gr_load_pal(palname) : 0 ;
+    int r ;
+    int old_palette_loaded = palette_loaded ;
+    palette_loaded = 0 ;
+    r = palname ? gr_load_pal(palname) : 0 ;
+    if (!r) palette_loaded = old_palette_loaded ;
     string_discard (params[0]) ;
     return r ;
 }
@@ -1663,7 +1723,7 @@
         background_8bits_used = 0;
     }
 
-    if (params[4] == 0 && params[5] == 100)
+    if (params[4] == 0 && params[5] == 100 && !(map->current_keyframe >= 0 && map->keyframes[map->current_keyframe].angle))
     {
         gr_blit (background, &regions[r], params[2], params[3], params[6], map) ;
         return 0 ;
@@ -1841,7 +1901,7 @@
     GRAPH * dest = bitmap_get (params[0], params[1]) ;
     GRAPH * orig = bitmap_get (params[0], params[2]) ;
 
-    if (params[5] == 0 && params[6] == 100)
+    if (params[5] == 0 && params[6] == 100 && !(orig->current_keyframe >= 0 && orig->keyframes[orig->current_keyframe].angle))
         gr_blit (dest, 0, params[3], params[4], params[7], orig) ;
     else
         gr_rotated_blit (dest, 0, params[3], params[4], params[7], params[5], params[6], params[6], orig) ;
@@ -1857,7 +1917,7 @@
     GRAPH * dest = bitmap_get (params[0], params[1]) ;
     GRAPH * orig = bitmap_get (params[2], params[3]) ;
 
-    if (params[6] == 0 && params[7] == 100 && params[8] == 100)
+    if (params[6] == 0 && params[7] == 100 && params[8] == 100 && !(orig->current_keyframe >= 0 && orig->keyframes[orig->current_keyframe].angle))
         gr_blit (dest, 0, params[4], params[5], params[9], orig) ;
     else
         gr_rotated_blit (dest, 0, params[4], params[5], params[9], params[6], params[7], params[8], orig) ;
@@ -2108,8 +2168,7 @@
     GRAPH * map ;
     unsigned char c = params[1];
 
-    if (font->charset == CHARSET_CP850)
-        c = win_to_dos[c];
+    if (font->charset == CHARSET_CP850) c = win_to_dos[c];
 
     if (!scr_initialized) gr_init (320, 200) ;
     if (!font) return 0;
@@ -2133,13 +2192,11 @@
     GRAPH * map  = bitmap_get(params[2], params[3]);
     unsigned char c = params[1];
 
-    if (font->charset == CHARSET_CP850)
-        c = win_to_dos[c];
+    if (font->charset == CHARSET_CP850) c = win_to_dos[c];
 
     if (font && map)
     {
-        if (font->glyph[c].bitmap)
-            bitmap_destroy (font->glyph[c].bitmap);
+        if (font->glyph[c].bitmap) bitmap_destroy (font->glyph[c].bitmap);
         font->glyph[c].bitmap = bitmap_clone(map);
         if (map->ncpoints >= 3 && map->cpoints)
         {
@@ -2401,11 +2458,49 @@
 
 static int fxi_fputs (INSTANCE * my, int * params)
 {
-    int r = file_puts ((file *)params[0], string_get(params[1])) ;
+    char *str = string_get(params[1]);
+    int r = file_puts ((file *)params[0], str) ;
+    if (str[strlen(str)-1] != '\n') file_puts ((file *)params[0], "\r\n") ;
+/*    int r = file_puts ((file *)params[0], string_get(params[1])) ; */
     string_discard(params[1]) ;
     return r ;
 }
 
+static int fxi_fgets (INSTANCE * my, int * params)
+{
+    char buffer[1024] ;
+    int str, str2 = 0, str3 ;
+    int len, sigue = 1 ;
+
+    while(sigue)
+    {
+        len = file_gets ((file *)params[0], buffer, sizeof(buffer)) ;
+        if (len < 1)
+            sigue = 0 ;
+        else {
+            if (buffer[len-1] == '\n')
+            {
+                len-- ;
+                buffer[len] = '\0' ;
+                sigue = 0 ;
+            }
+            if (buffer[len-1] == '\r') buffer[len-1] = '\0' ;
+        }
+        str = string_new (buffer) ;
+        if (str2)
+        {
+            str3 = string_add (str2, str) ;
+            string_discard (str) ;
+            string_discard (str2) ;
+            str2 = str3 ;
+        }
+        else
+            str2 = str ;
+    }
+    string_use (str2) ;
+    return str2 ;
+}
+
 static int fxi_file (INSTANCE * my, int * params)
 {
     char buffer[1024] ;
@@ -2430,39 +2525,6 @@
     return str ;
 }
 
-static int fxi_fgets (INSTANCE * my, int * params)
-{
-    char buffer[1024] ;
-    int str, str2 = 0, str3 ;
-    int len, sigue ;
-
-    for (;;)
-    {
-        file_gets ((file *)params[0], buffer, sizeof(buffer)) ;
-        len = strlen(buffer) ;
-        if (len > 1 && buffer[len-1] == '\n' && buffer[len-2] == '\\')
-        {
-            buffer[len-2] = 0 ;
-            sigue = 1 ;
-        }
-        else    sigue = 0 ;
-
-        str = string_new (buffer) ;
-        if (str2)
-        {
-            str3 = string_add (str2, str) ;
-            string_discard (str) ;
-            string_discard (str2) ;
-            str2 = str3 ;
-        }
-        else    str2 = str ;
-
-        if (!sigue) break ;
-    }
-    string_use (str2) ;
-    return str2 ;
-}
-
 static int fxi_feof (INSTANCE * my, int * params)
 {
     return file_eof ((file *)params[0]) ;
@@ -3992,9 +4054,9 @@
                 }
             }
             r1/=tabla[9];g1/=tabla[9];b1/=tabla[9];
-            r=((int)r1)>255?255:(int)r1;
-            g=((int)g1)>255?255:(int)g1;
-            b=((int)b1)>255?255:(int)b1;
+            r=(((int)r1)>255)?255:(int)r1;
+            g=(((int)g1)>255)?255:(int)g1;
+            b=(((int)b1)>255)?255:(int)b1;
 
             if(r<0)r=0;
             if(g<0)g=0;
@@ -4831,7 +4893,7 @@
     }
 
     stat (globd.gl_pathv[currentFile], &s);
-    gr_con_printf (_("%s (size %d) is %s"), globd.gl_pathv[currentFile], s.st_size, S_ISDIR(s.st_mode) ? _("a directory"):_("a file"));
+    gr_con_printf (_("%s (size %d) is %s"), globd.gl_pathv[currentFile], s.st_size, (S_ISDIR(s.st_mode)) ? _("a directory"):_("a file"));
 
     /* Store the file name and path */
     if (GLODWORD(FILE_NAME))
@@ -4862,7 +4924,7 @@
     }
 
     /* Store integer and boolean variables */
-    GLODWORD(FILE_DIRECTORY) = (S_ISDIR(s.st_mode) ? 1:0);
+    GLODWORD(FILE_DIRECTORY) = ((S_ISDIR(s.st_mode)) ? 1:0);
     GLODWORD(FILE_HIDDEN)    = (*ptr == '.');
     GLODWORD(FILE_READONLY)  = !(s.st_mode & 0444);
     GLODWORD(FILE_SIZE)      = s.st_size;
Index: fxi/src/i_main.c
===================================================================
--- fxi/src/i_main.c	2007-08-28 14:39:59.000000000 +0200
+++ fxi/src/i_main.c	2007-08-28 14:41:15.000000000 +0200
@@ -182,7 +182,7 @@
 	return result;
 }
 
-/*static */void freestrings(PROCDEF * proc, int * data)
+void freestrings(PROCDEF * proc, int * data)
 {
     // Splinter, descarto todas las strings privadas
     int i, s = 0, r;
@@ -211,54 +211,52 @@
             if (must_exit) break ;
 
         } else {
-            if (!last_instance_run) {
-                /* Ejecuta uno a uno todos los procesos */
-                i_count = 0 ;
-            }
-
-            while (1)
-            {
-                if (last_instance_run && instance_exists(last_instance_run)) {
+            if (last_instance_run) {
+                if (instance_exists(last_instance_run)) {
                     i = last_instance_run;
                 } else {
                     last_instance_run = NULL;
                     i = instance_next_by_priority();
-                    if (!i) break;
                 }
-                if (LOCDWORD(i, STATUS) == STATUS_KILLED ||
-                    LOCDWORD(i, STATUS) == STATUS_DEAD   ||
+            } else {
+                i = instance_next_by_priority();
+                i_count = 0 ;
+            }
+
+            while (i)
+            {
+                if (LOCDWORD(i, STATUS) == STATUS_KILLED || LOCDWORD(i, STATUS) == STATUS_DEAD ||
                     last_instance_run)
                 {
+                    // Run instance
+                } else if (LOCDWORD(i, STATUS) == STATUS_RUNNING && LOCDWORD(i, FRAME_PERCENT) < 100) {
+                    LOCDWORD(i, TYPE_SCAN) = 0;
+                    LOCDWORD(i, ID_SCAN) = 0;
+                } else {
+                    i = instance_next_by_priority();
                     last_instance_run = NULL;
-
-                    instance_go (i);
-
-                    if (force_debug || must_exit) break;
                     continue;
                 }
 
-                last_instance_run = NULL;
-
-                if (LOCDWORD(i, STATUS) != STATUS_RUNNING) continue;
+                i_count++;
 
-                if (LOCDWORD(i, FRAME_PERCENT) < 100) {
-                    LOCDWORD(i, TYPE_SCAN) = 0;
-                    LOCDWORD(i, ID_SCAN) = 0;
+                last_instance_run = NULL;
 
                     instance_go (i);
 
-                    if (force_debug || must_exit) break;
-                    i_count++;
-                }
+                if (force_debug) {
+                    show_console = 1;
+                    last_instance_run  = trace_instance;
+                    break;
             }
 
             if (must_exit) break ;
 
-            if (force_debug) {
-                show_console = 1;
-                last_instance_run  = trace_instance;
+                i = instance_next_by_priority();
             }
 
+            if (must_exit) break ;
+
             /* Si no se ejecutó nada: Dibujar, actualizar variables, etc. */
 
             if (!i_count && !force_debug)
@@ -290,8 +288,7 @@
                     i = next ;
                 }
 
-                if (!first_instance)
-                    break ;
+                if (!first_instance) break ;
 
                 /* Dibuja el frame */
 
@@ -326,8 +323,7 @@
 
 int instance_go (INSTANCE * r)
 {
-    if (!r)
-        return 0 ;
+    if (!r) return 0 ;
 
     register int * ptr = r->codeptr ;
     register int * stack_ptr = stack_gptr ;
@@ -335,10 +331,10 @@
     int n ;
     int return_value = LOCDWORD(r, PROCESS_ID) ;
     int was_visible;
-    SYSPROC * p ;
-    INSTANCE * i ;
-    PROCDEF * proc = r->proc, * aproc ;
-    static char buffer[16], * str ;
+    SYSPROC * p = NULL ;
+    INSTANCE * i = NULL ;
+    PROCDEF * proc = r->proc;
+    static char buffer[16], * str = NULL ;
 
     /* This variable contains a pointer to the private area at the stack.
        It is 0 if the current process uses the instance's private area instead */
@@ -353,17 +349,22 @@
 
     /* ------------------------------------------------------------------------------- */
     /* Restauro si salio por debug */
+#if 0
     if (r->inpridata) {
         private_data = r->inpridata;
         base_code = r->inproc->code;
         proc = r->inproc;
     }
+#endif
+
+    switchval = r->switchval;
+    switchval_string = r->switchval_string;
+    cased = r->cased;
 
     if (r->stack)
     {
         /* Restore a saved stack, if present */
-        if ((*r->stack) & STACK_SIZE_MASK)
-            memcpy (stack_ptr, r->stack+1, *r->stack * 4);
+        if ((*r->stack) & STACK_SIZE_MASK) memcpy (stack_ptr, r->stack+1, ((*r->stack) & STACK_SIZE_MASK) * 4);
         stack_ptr += ((*r->stack) & STACK_SIZE_MASK);
         free (r->stack);
         r->stack = NULL;
@@ -385,7 +386,11 @@
 
     trace_sentence = -1;
 
-    while(!must_exit && (LOCDWORD(r, STATUS) & STATUS_WAITING_MASK) != STATUS_KILLED)
+    while(!must_exit /*&&
+          (LOCDWORD(r, STATUS) == STATUS_RUNNING ||
+           LOCDWORD(r, STATUS) == STATUS_DEAD) &&
+          !(LOCDWORD(r, STATUS) & STATUS_WAITING_MASK)
+         */)
     {
         if (debug_next && trace_sentence != -1) {
             force_debug = 1;
@@ -393,11 +398,16 @@
             r->codeptr = ptr ;
             stack_gptr = stack_ptr ;
             return_value = LOCDWORD(r, PROCESS_ID);
-
+#if 0
             if (private_data != r->pridata) {
                 r->inpridata = private_data;
                 r->inproc = proc;
             }
+#endif
+            r->switchval = switchval;
+            r->switchval_string = switchval_string;
+            r->cased = cased;
+
             break;
         }
 
@@ -462,11 +472,12 @@
 
             case MN_CALL:
             case MN_PROC:
-                aproc = procdef_get (ptr[1]) ;
-                if (!aproc) gr_error ("Error: Procedimiento desconocido\n") ;
-                proc = aproc;
+                proc = procdef_get (ptr[1]) ;
+                if (!proc) gr_error ("Error: Procedimiento desconocido\n") ;
 
+#if 0
                 if (proc->flags & (PROC_USES_FRAME | PROC_USES_LOCALS | PROC_USES_PUBLICS))
+#endif
                 {
                     /* Process uses FRAME or locals, must create an instance */
                     i = instance_new (proc, r) ;
@@ -483,7 +494,8 @@
                     LOCDWORD(r,STATUS) |= STATUS_WAITING_MASK;
                     i->called_by   = r;
 
-                    /* Ejecuto la funcion/processo... */
+                    // Ejecuto la funcion/processo...
+
                     if (*ptr == MN_CALL) {
                         *stack_ptr++ = instance_go (i);
                     } else {
@@ -499,7 +511,12 @@
                     /* If the process is a function in a frame, save the stack and leave */
                     /* Si sigue corriendo la funcion/proceso que lance, es porque esta en un frame.
                        Si esta ejecutando codigo, es porque su STATUS es RUNNING */
-                    if (child_is_alive && LOCDWORD(r,STATUS) & STATUS_WAITING_MASK)
+                    if (child_is_alive &&
+                        ((LOCDWORD(r,STATUS) & STATUS_WAITING_MASK) ||
+                         (LOCDWORD(r,STATUS) & ~STATUS_WAITING_MASK) == STATUS_FROZEN ||
+                         (LOCDWORD(r,STATUS) & ~STATUS_WAITING_MASK) == STATUS_SLEEPING
+                        )
+                       )
                     {
                         /* En este caso me pongo a dormir y retorno */
                         i->called_by   = r;
@@ -516,7 +533,7 @@
                         /* Esta instancia no va a ejecutar otro codigo hasta que retorne el hijo */
                         r->codeptr = ptr ;
 
-                        /* Apunto global stack a stack_begin (inicio de mi stack) */
+                        /* Apunto global stack a stack_begin (inicio del stack original) */
                         stack_gptr = stack_begin;
 
                         /* Si no fue un call, seteo un flag en la len para no retornar valor */
@@ -538,6 +555,7 @@
                     }
                     proc = r->proc;
                 }
+#if 0
                 else
                 {
                     /* This process can be called locally: create a private memory area using the stack */
@@ -561,6 +579,7 @@
                     *stack_ptr++ = (Sint32) old_data;               //                    (stack_ptr[-2] in return)
                     base_code = ptr = proc->code;
                 }
+#endif
                 break ;
 
             case MN_SYSCALL:
@@ -639,7 +658,7 @@
             case MN_REMOTE | MN_STRING:
             case MN_REMOTE | MN_FLOAT:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = (int) &LOCDWORD(i, ptr[1]) ;
@@ -655,7 +674,7 @@
             case MN_REMOTE_PUBLIC | MN_STRING:
             case MN_REMOTE_PUBLIC | MN_FLOAT:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = (int) &PUBDWORD(i, ptr[1]) ;
@@ -696,7 +715,7 @@
             case MN_GET_REMOTE | MN_FLOAT:
             case MN_GET_REMOTE | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = LOCDWORD(i,ptr[1]) ;
@@ -707,7 +726,7 @@
             case MN_GET_REMOTE_PUBLIC | MN_FLOAT:
             case MN_GET_REMOTE_PUBLIC | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = PUBDWORD(i,ptr[1]) ;
@@ -755,7 +774,7 @@
 
             case MN_GET_REMOTE | MN_STRING:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = LOCDWORD(i,ptr[1]) ;
@@ -765,7 +784,7 @@
 
             case MN_GET_REMOTE_PUBLIC | MN_STRING:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = PUBDWORD(i,ptr[1]) ;
@@ -830,7 +849,7 @@
             case MN_WORD | MN_GET_REMOTE:
             case MN_WORD | MN_GET_REMOTE | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = LOCWORD(i,ptr[1]) ;
@@ -840,7 +859,7 @@
             case MN_WORD | MN_GET_REMOTE_PUBLIC:
             case MN_WORD | MN_GET_REMOTE_PUBLIC | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = PUBWORD(i,ptr[1]) ;
@@ -853,11 +872,11 @@
                 ptr++ ;
                 break ;
 
-            case MN_WORD | MN_NOT:
+/*            case MN_WORD | MN_NOT:
             case MN_WORD | MN_NOT | MN_UNSIGNED:
                 stack_ptr[-1] = !(stack_ptr[-1]) ;
                 ptr++ ;
-                break ;
+                break ; */
 
             /* Acceso a variables tipo BYTE */
 
@@ -903,7 +922,7 @@
 
             case MN_BYTE | MN_GET_REMOTE:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = (signed char) LOCBYTE(i,ptr[1]) ;
@@ -912,7 +931,7 @@
 
             case MN_BYTE | MN_GET_REMOTE | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = LOCBYTE(i,ptr[1]) ;
@@ -921,7 +940,7 @@
 
             case MN_BYTE | MN_GET_REMOTE_PUBLIC:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = (signed char) PUBBYTE(i,ptr[1]) ;
@@ -930,7 +949,7 @@
 
             case MN_BYTE | MN_GET_REMOTE_PUBLIC | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = PUBBYTE(i,ptr[1]) ;
@@ -947,11 +966,11 @@
                 ptr++ ;
                 break ;
 
-            case MN_BYTE | MN_NOT:
+/*            case MN_BYTE | MN_NOT:
             case MN_BYTE | MN_NOT | MN_UNSIGNED:
                 stack_ptr[-1] = !(stack_ptr[-1]) ;
                 ptr++ ;
-                break ;
+                break ; */
 
             /* Operaciones matemáticas  en coma floatante */
 
@@ -1098,121 +1117,101 @@
             /* Operaciones a nivel de bit */
 
             case MN_ROR:
-//                (Sint32)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Sint32)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_ROR | MN_UNSIGNED:
-//                (Uint32)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 stack_ptr[-2] = (Uint32)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_WORD | MN_ROR:
-//                (Sint16)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 stack_ptr[-2] = (Sint16)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_WORD | MN_ROR | MN_UNSIGNED:
-//                (Uint16)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 stack_ptr[-2] = (Uint16)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BYTE | MN_ROR:
-//                (Sint8)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 stack_ptr[-2] = (Sint8)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BYTE | MN_ROR | MN_UNSIGNED:
-//                (Uint8)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 stack_ptr[-2] = (Uint8)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_ROL:
-//                (Sint32)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Sint32)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
+
             /* Todos estos ROL siguientes no serian necesarios, pero bueno... */
             case MN_ROL | MN_UNSIGNED:
-//                (Uint32)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Uint32)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_WORD | MN_ROL:
-//                (Sint16)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Sint16)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_WORD | MN_ROL | MN_UNSIGNED:
-//                (Uint16)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Uint16)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BYTE | MN_ROL:
-//                (Sint8)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Sint8)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BYTE | MN_ROL | MN_UNSIGNED:
-//                (Uint8)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Uint8)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
-/*
-            case MN_ROL:
-                stack_ptr[-2] >>= stack_ptr[-1] ;
-                stack_ptr-- ;
-                ptr++ ;
-                break ;
-
-            case MN_ROL:
-                stack_ptr[-2] <<= stack_ptr[-1] ;
-                stack_ptr-- ;
-                ptr++ ;
-                break ;
-*/
             case MN_BAND:
+            case MN_BAND | MN_UNSIGNED:
                 stack_ptr[-2] &= stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BOR:
+            case MN_BOR | MN_UNSIGNED:
                 stack_ptr[-2] |= stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BXOR:
+            case MN_BXOR | MN_UNSIGNED:
                 stack_ptr[-2] ^= stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BNOT:
+            case MN_BNOT | MN_UNSIGNED:
                 stack_ptr[-1] = ~(stack_ptr[-1]) ;
                 ptr++ ;
                 break ;
@@ -1495,21 +1494,23 @@
                 string_use (stack_ptr[-ptr[1]-1]) ;
                 ptr += 2 ;
                 break ;
-
+/*
             case MN_POINTER2BOL:
-                stack_ptr[-ptr[1]-1] = stack_ptr[-ptr[1]-1] ? 1:0 ;
+                stack_ptr[-ptr[1]-1] = (stack_ptr[-ptr[1]-1]) ? 1:0 ;
                 ptr += 2 ;
                 break ;
-
+*/
             case MN_STR2FLOAT:
-                n = stack_ptr[-ptr[1]-1] ; str = (char *)string_get(n) ;
+                n = stack_ptr[-ptr[1]-1] ;
+                str = (char *)string_get(n) ;
                 *(float *)(&stack_ptr[-ptr[1]-1]) = str ? (float)atof(str) : 0.0f ;
                 string_discard (n) ;
                 ptr += 2 ;
                 break ;
 
             case MN_STR2INT:
-                n = stack_ptr[-ptr[1]-1] ; str = (char *)string_get(n) ;
+                n = stack_ptr[-ptr[1]-1] ;
+                str = (char *)string_get(n) ;
                 stack_ptr[-ptr[1]-1] = str ? atoi(str) : 0 ;
                 string_discard (n) ;
                 ptr += 2 ;
@@ -2035,8 +2036,7 @@
                 break ;
 
             case MN_SWITCH | MN_STRING:
-                if (switchval_string != 0)
-                    string_discard (switchval_string);
+                if (switchval_string != 0) string_discard (switchval_string);
                 switchval_string = *--stack_ptr;
                 cased = 0;
                 ptr++;
@@ -2099,11 +2099,9 @@
                 stack_gptr = stack_ptr ;
                 return_value = LOCDWORD(r, PROCESS_ID);
 
-                if (r->called_by &&
-                    instance_exists(r->called_by) &&
-                    (LOCDWORD(r->called_by, STATUS) & STATUS_WAITING_MASK) &&
-                    !(r->proc->flags & PROC_FUNCTION)
-                   )
+                if (!(r->proc->flags & PROC_FUNCTION) &&
+                    r->called_by && instance_exists(r->called_by) &&
+                    (LOCDWORD(r->called_by, STATUS) & STATUS_WAITING_MASK))
                 {
                     /* We're returning and the parent is waiting: wake it up */
                     if (r->called_by->stack && !(r->called_by->stack[0] & STACK_NO_RETURN_VALUE)) {
@@ -2116,28 +2114,30 @@
                 goto break_all ;
 
             case MN_END:
+#if 0
                 if (private_data == r->pridata) /* Esto es una nueva instancia */
+#endif
                 {
-                    if (LOCDWORD (r,STATUS) != STATUS_DEAD)
-                        LOCDWORD (r,STATUS) = STATUS_KILLED ;
+                    if (LOCDWORD(r,STATUS) != STATUS_DEAD) LOCDWORD(r,STATUS) = STATUS_KILLED ;
                     stack_gptr = stack_ptr ;
                     goto break_all ;
                 }
-
+#if 0
                 return_value = LOCDWORD(r, PROCESS_ID);
                 *stack_ptr++ = return_value;
-
+#endif
             case MN_RETURN:
+#if 0
                 if (private_data == r->pridata) /* Esto es una nueva instancia */
+#endif
                 {
-                    if (LOCDWORD (r,STATUS) != STATUS_DEAD)
-                        LOCDWORD (r,STATUS) = STATUS_KILLED ;
+                    if (LOCDWORD(r,STATUS) != STATUS_DEAD) LOCDWORD(r,STATUS) = STATUS_KILLED ;
                     stack_ptr-- ;
                     stack_gptr = stack_ptr ;
                     return_value = *stack_ptr ;
                     goto break_all ;
                 }
-
+#if 0
                 /* The process is inside a stack-call */
                 proc = (PROCDEF *)stack_ptr[-4]; // stack_ptr[-4] = Recupero el proc de la instancia actual
                 freestrings(proc, private_data);
@@ -2159,7 +2159,7 @@
 
                 r->inpridata = NULL;
                 r->inproc = NULL;
-
+#endif
                 break;
 
             /* Otros */
@@ -2195,7 +2195,7 @@
         }
 
         /* Si me killearon o estoy en waiting salgo */
-        if (LOCDWORD(r,STATUS) == STATUS_KILLED || LOCDWORD(r,STATUS) & STATUS_WAITING_MASK) {
+        if ((LOCDWORD(r,STATUS) & ~STATUS_WAITING_MASK) == STATUS_KILLED || (LOCDWORD(r,STATUS) & STATUS_WAITING_MASK)) {
             r->codeptr = ptr;
             stack_gptr = stack_ptr ;
             return_value = LOCDWORD(r, PROCESS_ID);
@@ -2217,40 +2217,34 @@
 
     gprof_end (proc->name);
 
+    if (!*ptr || *ptr == MN_RETURN || *ptr == MN_END || LOCDWORD(r, STATUS) == STATUS_KILLED) {
     /* Check for waiting parent */
-    if (r->called_by && instance_exists(r->called_by)         &&
-        LOCDWORD(r->called_by, STATUS) & STATUS_WAITING_MASK  &&
-        (LOCDWORD(r, STATUS) == STATUS_KILLED || !*ptr || *ptr == MN_RETURN || *ptr == MN_END)
-       )
+        if (r->called_by && instance_exists(r->called_by) && (LOCDWORD(r->called_by, STATUS) & STATUS_WAITING_MASK))
     {
         /* We're returning and the parent is waiting: wake it up */
-        if (r->called_by->stack &&
-            !((*r->called_by->stack) & STACK_NO_RETURN_VALUE)
-           )
-        {
-            r->called_by->stack[(*r->called_by->stack) & STACK_SIZE_MASK] = return_value;
+            if (r->called_by->stack && !(r->called_by->stack[0] & STACK_NO_RETURN_VALUE)) {
+                r->called_by->stack[r->called_by->stack[0] & STACK_SIZE_MASK] = return_value;
         }
+
         LOCDWORD(r->called_by, STATUS) &= ~STATUS_WAITING_MASK;
     }
+        r->called_by = NULL;
 
-    /* The process should be destroyed immediately,
-     * it is a function-type one */
-    if (!*ptr || *ptr == MN_RETURN || *ptr == MN_END || LOCDWORD(r, STATUS) == STATUS_KILLED) // Splinter
-    {
+        /* The process should be destroyed immediately, it is a function-type one */
         /* Ejecuto ONEXIT */
         if ((LOCDWORD(r,STATUS) & ~STATUS_WAITING_MASK) != STATUS_DEAD && r->exitcode) {
             LOCDWORD(r,STATUS) = STATUS_DEAD;
             r->codeptr = r->exitcode;
-            if (r->called_by && instance_exists(r->called_by)) {
-                r->called_by = NULL;
-            }
+
             instance_go(r);
         } else {
             instance_destroy(r);
         }
 
-        if (was_visible)
-            object_list_dirty = 1;
+        /* Apunto global stack a stack_begin (inicio del stack original) */
+        stack_gptr = stack_begin;
+
+        if (was_visible) object_list_dirty = 1;
     }
     else if (LOCDWORD(r, STATUS) != STATUS_KILLED && r->first_run)
     {
@@ -2266,13 +2260,15 @@
         object_list_unsorted = 1;
     }
 
-    if (switchval_string != 0)
-        string_discard(switchval_string);
+//    if (switchval_string != 0) string_discard(switchval_string);
 
     if (debug_next && trace_sentence != -1) {
         force_debug = 1;
         debug_next = 0;
     }
 
+    /* Apunto global stack a stack_begin (inicio del stack original) */
+/*    stack_gptr = stack_begin; */
+
     return return_value;
 }
Index: fxi/src/img_pcx.c
===================================================================
--- fxi/src/img_pcx.c	2007-08-28 14:39:59.000000000 +0200
+++ fxi/src/img_pcx.c	2007-08-28 14:41:16.000000000 +0200
@@ -81,6 +81,10 @@
 	Uint8	Filler[54];
 } PCXheader ;
 
+
+
+static unsigned char colors[256][3] ;
+
 /*
  *  FUNCTION : gr_read_pcx
  *
@@ -94,14 +98,15 @@
  *
  */
 
-GRAPH *
-gr_read_pcx (const char * filename)
+GRAPH * gr_read_pcx (const char * filename)
 {
 	PCXheader header ;
 	file *    file ;
 	int       width, height, x, y, p, count ;
 	GRAPH *   bitmap ;
 	Uint8 *   ptr, ch ;
+	int       i;
+
 
 	file = file_open (filename, "rb") ;
 	if (!file) gr_error (_("%s: Could not open the file\n"), filename) ;
@@ -147,6 +152,25 @@
 				}
 			}
 		}
+
+		if(file_read(file, &ch, 1)==1 && ch == 0x0c) {
+			if (file_read (file, colors, 3 * 256)) {
+				int i ;
+
+				if (!palette_loaded) {
+					for (i = 0 ; i < 256 ; i++) {
+						palette[i].r = colors[i][0] ;
+						palette[i].g = colors[i][1] ;
+						palette[i].b = colors[i][2] ;
+					}
+				}
+
+				bitmap->palette = pal_new2(colors);
+
+				palette_loaded = 1 ;
+				palette_changed = 1 ;
+			}
+		}
 	} else {
 		gr_error (_("%s: unsupported color depth\n"), filename) ;
 	}
Index: fxi/src/img_png.c
===================================================================
--- fxi/src/img_png.c	2007-08-28 14:39:59.000000000 +0200
+++ fxi/src/img_png.c	2007-08-28 14:41:16.000000000 +0200
@@ -144,35 +144,41 @@
     /* Recupera el fichero, convirtiendo a 16 bits si es preciso */
 
     rowbytes = png_get_rowbytes (png_ptr, info_ptr) ;
-    bitmap = bitmap_new (0, width, height, color == PNG_COLOR_TYPE_PALETTE ? 8 : 16, 1) ;
-    if (!bitmap) gr_error (_("Error loading PNG file")) ;
-    if (color == PNG_COLOR_TYPE_PALETTE)
-    {
+    bitmap = bitmap_new (0, width, height, (color == PNG_COLOR_TYPE_PALETTE) ? 8 : 16, 1) ;
+    if (!bitmap) {
+        file_close (png) ;
+        free ( rowpointers ) ;
+        free ( row ) ;
+        return 0 ;
+    }
+
+    if (color == PNG_COLOR_TYPE_PALETTE) {
         /* Read the color palette */
 
-        if (!palette_loaded)
-        {
             png_colorp png_palette = (png_colorp) png_malloc (png_ptr, 256*sizeof(png_color)) ;
-            if (!png_palette)
-                gr_error (_("Out of memory")) ;
-            else
-            {
+        if (!png_palette) gr_error (_("Out of memory")) ;
+
                 png_get_PLTE (png_ptr, info_ptr, &png_palette, &n) ;
 
-                for (n-- ; n <= 255 ; n--)
-                {
+        bitmap->palette = pal_new(NULL);
+
+        for (n = 0; n < 256 ; n++) {
+            bitmap->palette->rgb[n].r = png_palette[n].red;
+            bitmap->palette->rgb[n].g = png_palette[n].green;
+            bitmap->palette->rgb[n].b = png_palette[n].blue;
+            if (!palette_loaded) {
                     palette[n].r = png_palette[n].red;
                     palette[n].g = png_palette[n].green;
                     palette[n].b = png_palette[n].blue;
                 }
             }
 
+        pal_refresh(bitmap->palette);
+
             palette_loaded = 1 ;
             palette_changed = 1 ;
-        }
 
-        for (n = 0 ; n < height ; n++)
-            rowpointers[n] = ((Uint8*)bitmap->data) + n*bitmap->pitch ;
+        for (n = 0 ; n < height ; n++) rowpointers[n] = ((Uint8*)bitmap->data) + n*bitmap->pitch ;
         png_read_image (png_ptr, rowpointers) ;
 
         /* If the depth is less than 8, expand the pixel values */
@@ -260,9 +266,7 @@
             Bmask &= 0xFF0000 ;
             Gmask &= 0x00FF00 ;
             Rmask &= 0x0000FF ;
-        }
-        else
-        {
+        } else {
             Bshift = 8;
             Gshift = 5;
             Rshift = 3;
@@ -271,26 +275,21 @@
             Rmask  = 0x0000F7;
         }
 
-        for (n = 0 ; n < height ; n++)
-        {
+        for (n = 0 ; n < height ; n++) {
             rowpointers[0] = (void *)row ;
             png_read_rows (png_ptr, rowpointers, 0, 1) ;
 
             ptr = (Uint16*) bitmap->data + n*bitmap->pitch/2;
             orig = row ;
-            for (x = 0 ; x < width ; x++)
-            {
+            for (x = 0 ; x < width ; x++) {
                 ARRANGE_DWORD(orig);
 
-                if ((*orig) & 0x80000000)
-                {
-                  *ptr = ((*orig & Rmask) >> Rshift)|
-                     ((*orig & Gmask) >> Gshift)|
-                     ((*orig & Bmask) >> Bshift)  ;
-
+                if ((*orig) & 0x80000000) {
+                  *ptr = ((*orig & Rmask) >> Rshift)|((*orig & Gmask) >> Gshift)|((*orig & Bmask) >> Bshift)  ;
                   if (!*ptr) (*ptr)++ ;
                 }
-                else *ptr = 0 ;
+                else
+                    *ptr = 0 ;
                 ptr++, orig++ ;
             }
         }
@@ -298,8 +297,7 @@
 
     /* Fin */
 
-    if (!setjmp (png_ptr->jmpbuf))
-        png_read_end (png_ptr, 0) ;
+    if (!setjmp (png_ptr->jmpbuf)) png_read_end (png_ptr, 0) ;
     file_close (png) ;
     bitmap->modified = 1 ;
 
@@ -335,6 +333,7 @@
     png_colorp  pal ;
     Uint32      * data, * ptr ;
     Uint16      * orig ;
+    SDL_Color * gpal = NULL;
 
     if (!file) return(0) ;
 
@@ -347,8 +346,7 @@
     png_ptr  = png_create_write_struct (PNG_LIBPNG_VER_STRING, 0, 0, 0) ;
     info_ptr = png_create_info_struct  (png_ptr) ;
 
-    if (!png_ptr || !info_ptr)
-    {
+    if (!png_ptr || !info_ptr) {
         free ( rowpointers ) ;
         fclose(file) ;
         return(0) ;
@@ -356,8 +354,7 @@
 
     /* Error handling... */
 
-    if (setjmp(png_ptr->jmpbuf))
-    {
+    if (setjmp(png_ptr->jmpbuf)) {
         fclose (file) ;
         png_destroy_write_struct (&png_ptr, NULL) ;
         free ( rowpointers ) ;
@@ -368,8 +365,7 @@
 
     /* NOTE: NO SUPPORT FOR ANIMATIONS! */
 
-    if (gr->depth == 8)
-    {
+    if (gr->depth == 8) {
         /* 8 bits PNG file */
         png_set_IHDR (png_ptr, info_ptr, gr->width,
                       gr->height, 8, PNG_COLOR_TYPE_PALETTE,
@@ -377,20 +373,20 @@
                       PNG_FILTER_TYPE_BASE) ;
 
         pal = (png_colorp) png_malloc (png_ptr, 256*sizeof(png_color)) ;
-        if (!pal)
-        {
+        if (!pal) {
             fclose (file) ;
             png_destroy_write_struct (&png_ptr, NULL) ;
             free ( rowpointers ) ;
             return(0) ;
         }
 
+        if (gr->palette) gpal = gr->palette->rgb; else gpal = palette;
+
         /* Generate palette info */
-        for (k = 0 ; k < 256 ; k++)
-        {
-            pal[k].red   = palette[k].r ;
-            pal[k].green = palette[k].g ;
-            pal[k].blue  = palette[k].b ;
+        for (k = 0 ; k < 256 ; k++) {
+            pal[k].red   = gpal[k].r ;
+            pal[k].green = gpal[k].g ;
+            pal[k].blue  = gpal[k].b ;
         }
         png_set_PLTE (png_ptr, info_ptr, pal, 256) ;
         png_write_info (png_ptr, info_ptr) ;
@@ -403,9 +399,7 @@
         /* Free allocated palette... */
         png_free (png_ptr, (png_voidp) pal) ;
         info_ptr->palette = NULL ;
-    }
-    else
-    {
+    } else {
         png_set_IHDR (png_ptr, info_ptr, gr->width,
                       gr->height, 8, PNG_COLOR_TYPE_RGB_ALPHA,
                       PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE,
@@ -413,24 +407,20 @@
         png_write_info (png_ptr, info_ptr) ;
 
         data = malloc (gr->width * gr->height * 4) ;
-        if (!data)
-        {
+        if (!data) {
             fclose (file) ;
             png_destroy_write_struct (&png_ptr, NULL) ;
             free ( rowpointers ) ;
             return(0) ;
         }
-        for (k = 0 ; k < (unsigned)gr->height ; k++)
-        {
+        for (k = 0 ; k < (unsigned)gr->height ; k++) {
             ptr  = data + gr->width * k ; /* uses dword for each pixel! */
             orig = (Uint16 *)gr->data + gr->width * k ;
             rowpointers[k] = (Uint8 *)ptr ;
-            for (i = 0 ; i < (unsigned)gr->width ; i++)
-            {
+            for (i = 0 ; i < (unsigned)gr->width ; i++) {
                 if (*orig == 0 && !(gr->info_flags & GI_NOCOLORKEY))
                     *ptr = 0x00000000 ;
-                else
-                {
+                else {
                     *ptr = ((*orig & 0xf800) >> 8) |
                            ((*orig & 0x07e0) << 5) |
                            ((*orig & 0x001f) << 19)|
Index: fxi/src/instance.c
===================================================================
--- fxi/src/instance.c	2007-08-28 14:38:27.000000000 +0200
+++ fxi/src/instance.c	2007-08-28 14:41:16.000000000 +0200
@@ -53,12 +53,12 @@
 /* destrucción, duplicado, etc.                                           */
 /* ---------------------------------------------------------------------- */
 
-INSTANCE * first_instance = 0 ;
-INSTANCE * last_instance  = 0 ;
+INSTANCE * first_instance = NULL ;
+INSTANCE * last_instance  = NULL ;
 
 /* Priority lists */
 
-static INSTANCE * first_by_priority;
+static INSTANCE * first_by_priority     = NULL ;
 static INSTANCE * iterator_by_priority = NULL;
 static int        iterator_reset = 1;
 
@@ -128,6 +128,10 @@
 	r->inpridata    = NULL ;
 	r->inproc       = NULL ;
 
+    r->switchval        = 0;
+    r->switchval_string = 0;
+    r->cased            = 0;
+
 	r->breakpoint   = 0 ;
 
 	r->private_size = father->private_size ;
@@ -242,6 +246,10 @@
 	r->inpridata    = NULL ;
 	r->inproc       = NULL ;
 
+    r->switchval        = 0;
+    r->switchval_string = 0;
+    r->cased            = 0;
+
 	r->breakpoint   = 0 ;
 
 	r->private_size = proc->private_size ;
@@ -390,8 +398,7 @@
 	while (i)
 	{
 		next = i->next ;
-		if (i != except)
-			instance_destroy (i) ;
+		if (i != except) instance_destroy (i) ;
 		i = next ;
 	}
 }
@@ -417,13 +424,11 @@
 	INSTANCE * father, * bigbro, * smallbro, * smallson, * bigson, * smallerbro=NULL;
 	int n ;
 
-	if (LOCDWORD(r, GRAPHID) != 0)
-		object_list_dirty = 1;
+	if (LOCDWORD(r, GRAPHID) != 0) object_list_dirty = 1;
 
 	LOCDWORD(r, STATUS) = STATUS_RUNNING;
 
-	if (LOCDWORD(r, BOX_X0) != -2)
-		gr_mark_instance(r);
+	if (LOCDWORD(r, BOX_X0) != -2) gr_mark_instance(r);
 
 	/* Actualiza la cuenta de referencia de las variables tipo string */
 
@@ -440,15 +445,11 @@
 
     /* Si tengo hermano mayor */
 	bigbro = instance_get(LOCDWORD(r,BIGBRO)) ;
-	if (bigbro) {
-	    LOCDWORD(bigbro,SMALLBRO) = LOCDWORD(r,SMALLBRO) ;
-	}
+	if (bigbro) LOCDWORD(bigbro,SMALLBRO) = LOCDWORD(r,SMALLBRO) ;
 
     /* Si tengo un hermano */
 	smallbro = instance_get(LOCDWORD(r,SMALLBRO)) ;
-	if (smallbro) {
-	    LOCDWORD(smallbro,BIGBRO) = LOCDWORD(r,BIGBRO) ;
-	}
+	if (smallbro) LOCDWORD(smallbro,BIGBRO) = LOCDWORD(r,BIGBRO) ;
 
     /* Yo, ya estoy fuera */
 
@@ -508,41 +509,28 @@
 
 	/* Quita la instancia de la lista */
 
-	if (r->prev) {
-	    r->prev->next  = r->next ;
-	}
+	if (r->prev) r->prev->next  = r->next ;
 
-	if (r->next) {
-	    r->next->prev = r->prev ;
-	}
+	if (r->next) r->next->prev = r->prev ;
 
-	if (first_instance == r)
-		first_instance = r->next ;
+	if (first_instance == r) first_instance = r->next ;
 
-	if (last_instance == r)
-		last_instance = r->prev ;
+	if (last_instance == r) last_instance = r->prev ;
 
 	/* Remove the instance from the priority list */
-	if (first_by_priority == r)
-		first_by_priority = r->next_by_priority;
+	if (first_by_priority == r) first_by_priority = r->next_by_priority;
 
-	if (r->prev_by_priority)
-		r->prev_by_priority->next_by_priority = r->next_by_priority;
-
-	if (r->next_by_priority)
-		r->next_by_priority->prev_by_priority = r->prev_by_priority;
+	if (r->prev_by_priority) r->prev_by_priority->next_by_priority = r->next_by_priority;
+	if (r->next_by_priority) r->next_by_priority->prev_by_priority = r->prev_by_priority;
 
 	/* Remove the instance from the dirty list */
 
-	if (dirty_list == r)
+	if (dirty_list == r) {
 		dirty_list = r->next_dirty;
-    else if (r->is_dirty)
-	{
+    } else if (r->is_dirty) {
 		INSTANCE * i = dirty_list;
-		while (i)
-		{
-			if (i->next_dirty == r)
-			{
+		while (i) {
+			if (i->next_dirty == r) {
 				i->next_dirty = r->next_dirty;
 				break;
 			}
@@ -550,12 +538,11 @@
 		}
 	}
 
-	if (r->stack)
-		free (r->stack) ;
+	if (r->stack) free (r->stack) ;
 
-	free (r->locdata) ;
-	free (r->pubdata) ;
-	free (r->pridata) ;
+	if (r->locdata) free (r->locdata) ;
+	if (r->pubdata) free (r->pubdata) ;
+	if (r->pridata) free (r->pridata) ;
 	free (r) ;
 }
 
@@ -598,9 +585,8 @@
 	if (scalex == 100 && scaley == 100)
 		scalex = scaley = LOCDWORD(i,GRAPHSIZE);
 
-	gr_get_bbox (&dest, r, x, y,
-		LOCDWORD(i,FLAGS) ^ LOCDWORD(i,XGRAPH_FLAGS),
-		LOCDWORD(i,XGRAPH) ? 0 : LOCDWORD(i,ANGLE),
+	gr_get_bbox (&dest, r, x, y, LOCDWORD(i,FLAGS) ^ LOCDWORD(i,XGRAPH_FLAGS),
+                        		 (LOCDWORD(i,XGRAPH)) ? 0 : LOCDWORD(i,ANGLE),
 		scalex, scaley, gr) ;
 
 	if (LOCDWORD(i, CTYPE) == 1)	/* c_scroll */
@@ -641,8 +627,7 @@
 	if ((LOCDWORD(i,STATUS) & ~STATUS_WAITING_MASK) == STATUS_SLEEPING ||
 	    (LOCDWORD(i,STATUS) & ~STATUS_WAITING_MASK) == STATUS_RUNNING)
 	{
-		if (instance_graph(i))
-			return 1;
+		if (instance_graph(i)) return 1;
 	}
 
 	return 0;
@@ -696,14 +681,10 @@
 {
 	GRAPH * graph = instance_graph(i);
 
-	if (graph && (graph->modified ||
-	              (graph->frames > 0 && graph->next_time < current_time)
-	              )
-	   )
+	if (graph && (graph->modified || (graph->frames > 1 && graph->next_time < current_time)))
 	    return 1;
 
-	return
-	    LOCDWORD(i,SAVED_X)       != LOCDWORD(i,COORDX)		||
+	return  LOCDWORD(i,SAVED_X)       != LOCDWORD(i,COORDX)		||
 		LOCDWORD(i,SAVED_Y)       != LOCDWORD(i,COORDY)		||
 		LOCDWORD(i,SAVED_GRAPH)   != LOCDWORD(i,GRAPHID)	||
 		LOCDWORD(i,SAVED_ANGLE)   != LOCDWORD(i,ANGLE)		||
@@ -800,17 +781,14 @@
 
 INSTANCE * instance_next_by_priority()
 {
-	INSTANCE * i;
-	INSTANCE * j;
-	INSTANCE * best_prev;
-	INSTANCE * best_next;
-
-	if (iterator_by_priority == NULL)
-	{
+	INSTANCE * i = NULL ;
+	INSTANCE * j = NULL ;
+	INSTANCE * best_prev = NULL ;
+	INSTANCE * best_next = NULL ;
+	if (!iterator_by_priority) {
 		// NULL will be returned once and then the list will be reset
 
-		if (!iterator_reset)
-		{
+		if (!iterator_reset) {
 			iterator_reset = 1;
 			return NULL;
 		}
@@ -819,23 +797,18 @@
 		// Add all dirty instances to its place at the list
 
 		i = dirty_list;
-		while (i != NULL)
-		{
+		while (i != NULL) {
 			// Check the priority value
 
-			if (LOCDWORD(i, PRIORITY) < MIN_PRIORITY)
-				LOCDWORD(i, PRIORITY) = MIN_PRIORITY;
-			if (LOCDWORD(i, PRIORITY) > MAX_PRIORITY)
-				LOCDWORD(i, PRIORITY) = MAX_PRIORITY;
+			if (LOCDWORD(i, PRIORITY) < MIN_PRIORITY) LOCDWORD(i, PRIORITY) = MIN_PRIORITY;
+			if (LOCDWORD(i, PRIORITY) > MAX_PRIORITY) LOCDWORD(i, PRIORITY) = MAX_PRIORITY;
 
 			// Remove the instance from the list
 
-			if (i->prev_by_priority)
-				i->prev_by_priority->next_by_priority = i->next_by_priority;
-			if (i->next_by_priority)
-				i->next_by_priority->prev_by_priority = i->prev_by_priority;
-			if (first_by_priority == i)
-				first_by_priority = i->next_by_priority;
+			if (i->prev_by_priority) i->prev_by_priority->next_by_priority = i->next_by_priority;
+			if (i->next_by_priority) i->next_by_priority->prev_by_priority = i->prev_by_priority;
+
+			if (first_by_priority == i) first_by_priority = i->next_by_priority;
 
 			// Add the instance to the list. The easy case is when there is
 			// already some instance with the same priority.
@@ -846,61 +819,48 @@
             i->prev_by_priority = NULL;
 			i->next_by_priority = NULL;
 
-			while (j)
-			{
-				if (LOCDWORD(j, PRIORITY) == LOCDWORD(i, PRIORITY))
-				{
+			while (j) {
+				if (LOCDWORD(j, PRIORITY) == LOCDWORD(i, PRIORITY)) {
 					i->prev_by_priority = j;
 					i->next_by_priority = j->next_by_priority;
 					j->next_by_priority = i;
 
-					if (i->next_by_priority)
-						i->next_by_priority->prev_by_priority = i;
+					if (i->next_by_priority) i->next_by_priority->prev_by_priority = i;
 					break;
-				}
-				else if (LOCDWORD(j, PRIORITY) > LOCDWORD(i, PRIORITY))
-				{
+				} else if (LOCDWORD(j, PRIORITY) > LOCDWORD(i, PRIORITY)) {
 					best_prev = j;
-				}
-				else if (!best_next)
-				{
+				} else if (!best_next) {
 					best_next = j;
 				}
 
 				j = j->next_by_priority;
 			}
 
-			if (j == NULL)
-			{
+			if (!j) {
 				// No best case
-				if (best_prev)
-				{
+				if (best_prev) {
 					// But some instance was found with a lower priority
 
 					i->next_by_priority = best_prev->next_by_priority;
 					best_prev->next_by_priority = i;
 
-					if (i->next_by_priority)
-						i->next_by_priority->prev_by_priority = i;
+					if (i->next_by_priority) i->next_by_priority->prev_by_priority = i;
 
 				    i->prev_by_priority = best_prev; /* Splinter */
-				}
-				else if (best_next)
-				{
+				} else if (best_next) {
 					// But some instance was found with a higher priority
 
 					i->prev_by_priority = best_next->prev_by_priority;
 					best_next->prev_by_priority = i;
 
-					if (i->prev_by_priority)
+					if (i->prev_by_priority) {
 						i->prev_by_priority->next_by_priority = i;
-					else
+					} else {
 						first_by_priority = i;
+					}
 
 				    i->next_by_priority = best_next; /* Splinter */
-				}
-				else
-				{
+				} else {
 					// There are no instances in the list
 
 					first_by_priority   = i;
@@ -915,12 +875,19 @@
 
 		dirty_list = NULL;
 
+		if (first_by_priority)
 		iterator_by_priority = first_by_priority->next_by_priority;
+		else
+		    iterator_by_priority = NULL;
+
 		return first_by_priority;
 	}
 
 	i = iterator_by_priority;
+
+	if (iterator_by_priority)
 	iterator_by_priority = iterator_by_priority->next_by_priority;
+
 	return i;
 }
 
