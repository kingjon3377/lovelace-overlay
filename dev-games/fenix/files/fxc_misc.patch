Index: fxc/src/c_code.c
===================================================================
--- a/fxc/src/c_code.c	2007-08-28 14:38:23.000000000 +0200
+++ b/fxc/src/c_code.c	2007-08-28 14:41:09.000000000 +0200
@@ -58,7 +58,7 @@
 {
     if (typedef_is_pointer(exp->type))
     {
-        codeblock_add (code, MN_POINTER2BOL, 0) ;
+//        codeblock_add (code, MN_POINTER2BOL, 0) ;
         exp->type = typedef_new(TYPE_DWORD) ;
     }
 
@@ -79,13 +79,13 @@
 {
     if (typedef_is_pointer(left->type))
     {
-        codeblock_add (code, MN_POINTER2BOL, 1) ;
+//        codeblock_add (code, MN_POINTER2BOL, 1) ;
         left->type = typedef_new(TYPE_DWORD) ;
     }
 
     if (typedef_is_pointer(right->type))
     {
-        codeblock_add (code, MN_POINTER2BOL, 0) ;
+//        codeblock_add (code, MN_POINTER2BOL, 0) ;
         right->type = typedef_new(TYPE_DWORD) ;
     }
 
@@ -402,8 +402,8 @@
 {
     VARIABLE           * var = NULL ;
     VARSPACE           * here = from ;
-    VARSPACE           * privars = proc ? proc->privars : 0 ;
-    VARSPACE           * pubvars = proc ? proc->pubvars : 0 ;
+    VARSPACE           * privars = (proc ? proc->privars : NULL) ;
+    VARSPACE           * pubvars = (proc ? proc->pubvars : NULL) ;
     expresion_result    res, ind ;
 
     if (here) token_next() ;
@@ -710,12 +710,14 @@
                     else
                         strdelchars (validtypes, "P") ;
                     break ;
+                case TYPE_POINTER:
+                    strdelchars (validtypes, "SFIWB") ;
+                    break ;
                 default:
                     break ;
             }
 
-            if (strlen(validtypes) != 1)
-                compile_error (MSG_INVALID_PARAMT) ;
+            if (strlen(validtypes) != 1) compile_error (MSG_INVALID_PARAMT) ;
 
             /* Eliminate all functions that are not selected */
 
@@ -764,11 +766,10 @@
         }
     }
 
-    if (proc_count > 1)
-        compile_error (MSG_MULTIPLE_PROCS_FOUND, proc_name);
-    if (proc_count == 0)
-        compile_error (MSG_INCORRECT_PARAMC, proc_name, min_params) ;
+    if (proc_count > 1) compile_error (MSG_MULTIPLE_PROCS_FOUND, proc_name);
+    if (proc_count == 0) compile_error (MSG_INCORRECT_PARAMC, proc_name, min_params) ;
     codeblock_add (code, MN_SYSCALL, procs[0]->code) ;
+
     return procs[0] ;
 }
 
@@ -1433,7 +1434,7 @@
     {
         part = compile_factor() ;
         if (part.lvalue) codeblock_add (code, mntype(part.type, 0) | MN_PTR, 0) ;
-        codeblock_add (code, mntype(part.type, 0) | MN_NEG, 0) ;
+        codeblock_add (code, (mntype(part.type, 0) == MN_FLOAT ? MN_FLOAT : 0) | MN_NEG, 0) ;
         res.type = part.type ;
         if (typedef_is_integer(part.type) ||
             typedef_base(part.type) == TYPE_FLOAT)
@@ -1448,13 +1449,13 @@
     else if (token.type == IDENTIFIER && token.code == identifier_not) /* "NOT" or "!" */
     {
         part = compile_factor() ;
-        if (part.lvalue) codeblock_add (code, mntype(part.type, 0) | MN_PTR, 0) ;
+        if (part.lvalue) codeblock_add (code, (mntype(part.type, 0) == MN_FLOAT ? MN_FLOAT : 0) | MN_PTR, 0) ;
         if (typedef_is_pointer(part.type))
         {
-            codeblock_add (code, mntype(part.type, 0) | MN_POINTER2BOL, 0) ;
+//            codeblock_add (code, mntype(part.type, 0) | MN_POINTER2BOL, 0) ;
             part.type = typedef_new(TYPE_DWORD) ;
         }
-        codeblock_add (code, mntype(part.type, 0) | MN_NOT, 0) ;
+        codeblock_add (code, (mntype(part.type, 0) == MN_FLOAT ? MN_FLOAT : 0) | MN_NOT, 0) ;
         if (typedef_is_integer(part.type) ||
             typedef_is_pointer(part.type) ||
             typedef_base(part.type) == TYPE_FLOAT)
@@ -1471,13 +1472,13 @@
     else if (token.type == IDENTIFIER && token.code == identifier_bnot) /* "BNOT" or "~" */
     {
         part = compile_factor() ;
-        if (part.lvalue) codeblock_add (code, mntype(part.type, 0) | MN_PTR, 0) ;
+        if (part.lvalue) codeblock_add (code, (mntype(part.type, 0) == MN_FLOAT ? MN_FLOAT : 0) | MN_PTR, 0) ;
         if (typedef_is_pointer(part.type))
         {
-            codeblock_add (code, mntype(part.type, 0) | MN_POINTER2BOL, 0) ;
+//            codeblock_add (code, mntype(part.type, 0) | MN_POINTER2BOL, 0) ;
             part.type = typedef_new(TYPE_DWORD) ;
         }
-        codeblock_add (code, mntype(part.type, 0) | MN_BNOT, 0) ;
+        codeblock_add (code, (mntype(part.type, 0) == MN_FLOAT ? MN_FLOAT : 0) | MN_BNOT, 0) ;
         if (typedef_is_integer(part.type))
         {
             res.constant = part.constant ;
@@ -1997,6 +1998,7 @@
 {
     expresion_result left = compile_comparison (), right, res ;
     int et1;
+    int et2;
 
     token_next() ;
     if (token.type == IDENTIFIER && token.code == identifier_and) /* "AND" or "&&" */
@@ -2031,17 +2033,24 @@
     if (token.type == IDENTIFIER && token.code == identifier_or) /* "OR" or "||" */
     {
         et1 = codeblock_label_add(code);
+        et2 = codeblock_label_add(code);
 
         if (left.lvalue) codeblock_add (code, MN_PTR, 0) ;
         check_integer_type (&left) ;
-        codeblock_add (code, MN_JTTRUE, et1) ;
+        codeblock_add (code, MN_JTFALSE, et1) ;
+
+        codeblock_add (code, MN_POP, 0);
+        codeblock_add (code, MN_PUSH, 1);
+        codeblock_add (code, MN_JUMP, et2);
+
+        codeblock_label_set (code, et1, code->current) ;
         right = compile_compseq() ;
         if (right.lvalue) codeblock_add (code, MN_PTR, 0) ;
         check_integer_type (&right) ;
 
         codeblock_add (code, MN_OR, 0) ;
 
-        codeblock_label_set (code, et1, code->current) ;
+        codeblock_label_set (code, et2, code->current) ;
 /*
         if (left.lvalue) codeblock_add (code, MN_PTR, 0) ;
         right = compile_compseq() ;
@@ -2568,7 +2577,7 @@
     }
     if (typedef_base(res.type) == TYPE_POINTER && t < 8)
     {
-        codeblock_add (code, MN_POINTER2BOL, 0) ;
+/*        codeblock_add (code, MN_POINTER2BOL, 0) ; */
         res.type = typedef_new(t) ; /* Pointer 2 Int */
     }
     if (typedef_base(res.type) == TYPE_FLOAT && t < 8)
@@ -3045,7 +3054,8 @@
                 }
                 if (token.type != IDENTIFIER || token.code != identifier_semicolon) /* ";" */
                     compile_error (MSG_EXPECTED, ";") ;
-                codeblock_loop_start (code, loop, code->current) ;
+
+                codeblock_label_set (code, et1, code->current) ;
 
                 if (dcb_options & DCB_DEBUG) {
                     codeblock_add (code, MN_SENTENCE, forline) ;
@@ -3069,7 +3079,7 @@
                 codeblock_add (code, MN_JUMP, et2) ;
 
                 /* Incrementos */
-                codeblock_label_set (code, et1, code->current) ;
+                codeblock_loop_start (code, loop, code->current) ;
 
                 if (dcb_options & DCB_DEBUG) {
                     codeblock_add (code, MN_SENTENCE, forline) ;
@@ -3089,7 +3099,8 @@
                 }
                 if (token.type != IDENTIFIER || token.code != identifier_rightp)    /* ")" */
                     compile_error (MSG_EXPECTED, ")") ;
-                codeblock_add (code, MN_REPEAT, loop) ;
+
+                codeblock_add (code, MN_JUMP, et1) ;
 
                 /* Bloque */
                 codeblock_label_set (code, et2, code->current) ;
@@ -3099,7 +3110,7 @@
                 compile_block(p) ;
                 code->loop_active = last_loop ;
 
-                codeblock_add (code, MN_JUMP, et1) ;
+                codeblock_add (code, MN_REPEAT, loop) ;
                 codeblock_loop_end (code, loop, code->current) ;
                 continue ;
             }
@@ -3240,6 +3251,8 @@
                 CODEBLOCK_POS var_pos;
                 CODEBLOCK_POS var_end;
 
+                et1 = codeblock_label_add (code) ;
+
                 // Compile the variable access
 
                 loop = codeblock_loop_add(code) ;
@@ -3249,10 +3262,8 @@
                 var_pos = codeblock_pos(code);
                 res = compile_value () ;
                 var_end = codeblock_pos(code);
-                if (!res.lvalue)
-                    compile_error (MSG_VARIABLE_REQUIRED) ;
-                if (!typedef_is_integer(res.type))
-                    compile_error (MSG_INTEGER_REQUIRED);
+                if (!res.lvalue) compile_error (MSG_VARIABLE_REQUIRED) ;
+                if (!typedef_is_integer(res.type)) compile_error (MSG_INTEGER_REQUIRED);
 
                 // Compile the assignation of first value
 
@@ -3264,7 +3275,8 @@
 
                 // Compile the loop termination check
 
-                codeblock_loop_start (code, loop, code->current) ;
+                codeblock_label_set (code, et1, code->current) ;
+
                 codeblock_add_block (code, var_pos, var_end);
                 codeblock_add (code, MN_PTR | mntype(res.type, 0), 0);
                 token_next() ;
@@ -3277,10 +3289,8 @@
                 {
                     CODEBLOCK_POS p = codeblock_pos(code);
                     expresion_result r = compile_expresion(1, 0, typedef_base(res.type)) ;
-                    if (!r.constant)
-                        compile_error (MSG_CONSTANT_EXP);
-                    if (!typedef_is_integer(r.type))
-                        compile_error (MSG_INTEGER_REQUIRED);
+                    if (!r.constant) compile_error (MSG_CONSTANT_EXP);
+                    if (!typedef_is_integer(r.type)) compile_error (MSG_INTEGER_REQUIRED);
                     inc = r.value;
 
                     codeblock_setpos(code, p);
@@ -3288,8 +3298,7 @@
                         codeblock_add (code, MN_LTE, 0) ;
                     else
                     {
-                        if (inc == 0)
-                            compile_error (MSG_INVALID_STEP) ;
+                        if (inc == 0) compile_error (MSG_INVALID_STEP) ;
                         codeblock_add (code, MN_GTE, 0) ;
                     }
                 }
@@ -3318,6 +3327,8 @@
 
                 // Compile the increment and looping code
 
+                codeblock_loop_start (code, loop, code->current) ;
+
                 codeblock_add_block (code, var_pos, var_end);
                 if (inc == 1)
                     codeblock_add (code, MN_INC | mntype(res.type, 0), 1) ;
@@ -3329,7 +3340,8 @@
                     codeblock_add (code, MN_VARADD | mntype(res.type, 0), 0) ;
                 }
                 codeblock_add (code, MN_POP, 0) ;
-                codeblock_add (code, MN_REPEAT, loop) ;
+                codeblock_add (code, MN_JUMP, et1) ;
+
                 codeblock_loop_end (code, loop, code->current) ;
                 continue ;
             }
@@ -3338,8 +3350,18 @@
 
             if (token.code == identifier_repeat) /* "REPEAT" */
             {
+                et1 = codeblock_label_add (code) ;
+                et2 = codeblock_label_add (code) ;
+
                 loop = codeblock_loop_add (code) ;
+
+                codeblock_add (code, MN_JUMP, et1) ;
+
                 codeblock_loop_start (code, loop, code->current) ;
+
+                codeblock_add (code, MN_JUMP, et2) ;
+                codeblock_label_set (code, et1, code->current) ;
+
                 if (dcb_options & DCB_DEBUG) {
                     codeblock_add (code, MN_SENTENCE, line_count + (current_file << 24)) ;
                 }
@@ -3348,6 +3370,9 @@
                 code->loop_active = loop ;
                 compile_block(p) ;
                 code->loop_active = last_loop ;
+
+                codeblock_label_set (code, et2, code->current) ;
+
                 if (dcb_options & DCB_DEBUG) {
                     codeblock_add (code, MN_SENTENCE, line_count + (current_file << 24)) ;
                 }
@@ -3370,7 +3395,7 @@
                     if (token.type != IDENTIFIER || token.code != identifier_semicolon) /* ";" */
                         compile_error (MSG_EXPECTED, ";") ;
                 }
-                codeblock_add (code, MN_REFALSE, loop) ;
+                codeblock_add (code, MN_JFALSE, et1) ;
                 codeblock_loop_end (code, loop, code->current) ;
                 continue ;
             }
Index: fxc/src/c_debug.c
===================================================================
--- a/fxc/src/c_debug.c	2007-08-28 14:38:23.000000000 +0200
+++ b/fxc/src/c_debug.c	2007-08-28 14:41:09.000000000 +0200
@@ -144,7 +144,7 @@
 	{ "STR2FLOAT", MN_STR2FLOAT, 1 },
 	{ "FLOAT2STR", MN_FLOAT2STR, 1 },
 	{ "POINTER2STR", MN_POINTER2STR, 1 },
-	{ "POINTER2BOL", MN_POINTER2BOL, 1 },
+//	{ "POINTER2BOL", MN_POINTER2BOL, 1 },
 
 	{ "A2STR", MN_A2STR, 0 },
 	{ "STR2A", MN_STR2A, 0 },
Index: fxc/src/c_main.c
===================================================================
--- a/fxc/src/c_main.c	2007-08-28 14:41:03.000000000 +0200
+++ b/fxc/src/c_main.c	2007-08-28 14:41:09.000000000 +0200
@@ -621,35 +621,35 @@
     }
 
     if (tcode == identifier_word){
-        if (is_declare && proc->declared && proc->type != signed_prefix ? TYPE_SHORT : TYPE_WORD)
+        if (is_declare && proc->declared && proc->type != (signed_prefix ? TYPE_SHORT : TYPE_WORD))
             compile_error (MSG_PROTO_ERROR) ;
         proc->type = signed_prefix ? TYPE_SHORT : TYPE_WORD;
         signed_prefix = unsigned_prefix = 0;
     }
 
     if (tcode == identifier_dword){
-        if (is_declare && proc->declared && proc->type != signed_prefix ? TYPE_INT : TYPE_DWORD)
+        if (is_declare && proc->declared && proc->type != (signed_prefix ? TYPE_INT : TYPE_DWORD))
             compile_error (MSG_PROTO_ERROR) ;
         proc->type = signed_prefix ? TYPE_INT : TYPE_DWORD;
         signed_prefix = unsigned_prefix = 0;
     }
 
     if (tcode == identifier_byte){
-        if (is_declare && proc->declared && proc->type != signed_prefix ? TYPE_SBYTE : TYPE_BYTE)
+        if (is_declare && proc->declared && proc->type != (signed_prefix ? TYPE_SBYTE : TYPE_BYTE))
             compile_error (MSG_PROTO_ERROR) ;
         proc->type = signed_prefix ? TYPE_SBYTE : TYPE_BYTE;
         signed_prefix = unsigned_prefix = 0;
     }
 
     if (tcode == identifier_int){
-        if (is_declare && proc->declared && proc->type != unsigned_prefix ? TYPE_DWORD : TYPE_INT)
+        if (is_declare && proc->declared && proc->type != (unsigned_prefix ? TYPE_DWORD : TYPE_INT))
             compile_error (MSG_PROTO_ERROR) ;
         proc->type = unsigned_prefix ? TYPE_DWORD : TYPE_INT;
         signed_prefix = unsigned_prefix = 0;
     }
 
     if (tcode == identifier_short){
-        if (is_declare && proc->declared && proc->type != unsigned_prefix ? TYPE_WORD : TYPE_SHORT)
+        if (is_declare && proc->declared && proc->type != (unsigned_prefix ? TYPE_WORD : TYPE_SHORT))
             compile_error (MSG_PROTO_ERROR) ;
         proc->type = unsigned_prefix ? TYPE_WORD : TYPE_SHORT;
         signed_prefix = unsigned_prefix = 0;
@@ -920,11 +920,10 @@
        los datos declarados aquí tienen el mismo efecto que si son
        declarados externamente y afectarán a todos los procesos (Ya no va mas esto, ahora los datos locales son locales, Splinter) */
 
-    if (!proc->declared) {
         while ( token.type == IDENTIFIER && ( token.code == identifier_local  ||
                                               token.code == identifier_public ||
                                               token.code == identifier_private ) ) {
-            if ( token.code == identifier_local || token.code == identifier_public )
+        if ((!proc->declared) && (token.code == identifier_local || token.code == identifier_public))
             {
                 /* (2006/11/19 19:34 GMT-03:00, Splinter - jj_arg@yahoo.com) */
                 /* Ahora las declaraciones locales, son solo locales al proceso, pero visibles desde todo proceso */
@@ -940,7 +939,6 @@
 
             token_next () ;
         }
-    }
 
     /* Gestiona procesos cuyos parámetros son variables locales */
 
Index: fxc/src/dcbw.c
===================================================================
--- a/fxc/src/dcbw.c	2007-08-28 14:39:51.000000000 +0200
+++ b/fxc/src/dcbw.c	2007-08-28 14:41:09.000000000 +0200
@@ -74,11 +74,9 @@
         if (!fp) return ;
         while (!file_eof(fp))
         {
-            file_gets (fp, buffer, sizeof(buffer)) ;
-            if (strchr(buffer, '\n'))
-                *strchr(buffer,'\n') = 0 ;
-            if (buffer[0] == '#' || !buffer[0])
-                continue ;
+            file_qgets (fp, buffer, sizeof(buffer)) ;
+            if (strchr(buffer, '\n')) *strchr(buffer,'\n') = 0 ;
+            if (buffer[0] == '#' || !buffer[0]) continue ;
             dcb_add_file(buffer) ;
         }
         file_close(fp) ;
Index: fxc/src/error.c
===================================================================
--- a/fxc/src/error.c	2007-08-28 14:38:23.000000000 +0200
+++ b/fxc/src/error.c	2007-08-28 14:41:09.000000000 +0200
@@ -54,6 +54,7 @@
 	int	   size ;
 	char * msg = NULL ;
 	struct _errmsg * err = NULL ;
+	int len;
 
 	/* open the desired localized error file, check for existence if not open EN default */
 	strcpy(fname,"msg/") ;
@@ -65,7 +66,7 @@
 	fp = file_open(fname,"r") ;
 
 	if (fp) {
-		while (file_gets (fp,line,1024)) {
+		while (len = file_qgets (fp,line,1024)) {
 			// Check for multiline...
 			if (line[0]=='_') {
 				// must resize the string and concatenate
Index: fxc/src/main_div.c
===================================================================
--- a/fxc/src/main_div.c	2007-08-28 14:38:23.000000000 +0200
+++ b/fxc/src/main_div.c	2007-08-28 14:41:10.000000000 +0200
@@ -183,6 +183,7 @@
 "   y ; \n"
 "   z ; \n"
 "   graph ; \n"
+"   palette = -1 ; \n"
 "   flags ; \n"
 "   size = 100 ; \n"
 "   angle ; \n"
@@ -194,11 +195,12 @@
 "   alpha = 255 ; \n"
 "   size_x = 100 ; \n"
 "   size_y = 100 ; \n"
-"   blendop ; \n"
+"   blendop = 0; \n"
 "   STRUCT _saved_ \n"
 "       x ; \n"
 "       y ; \n"
 "       graph ; \n"
+"       palette ; \n"
 "       angle ; \n"
 "       alpha ; \n"
 "       blendop ; \n"
Index: fxc/src/sysstub.c
===================================================================
--- a/fxc/src/sysstub.c	2007-08-28 14:38:24.000000000 +0200
+++ b/fxc/src/sysstub.c	2007-08-28 14:41:10.000000000 +0200
@@ -76,8 +76,7 @@
 	last[1].next = NULL ;
 	last++ ;
 	sysproc_count++ ;
-	if (sysproc_count == MAX_SYSPROCS)
-		compile_error (MSG_TOO_MANY_SYSPROCS) ;
+	if (sysproc_count == MAX_SYSPROCS) compile_error (MSG_TOO_MANY_SYSPROCS) ;
 
 	/* If the fast-access list is already filled, free it to fill it again
 	 * in sysproc_get. We should add the new process to the list, but this
@@ -123,10 +122,8 @@
 
 		for (s = sysprocs ; s->name ; s++)
 		{
-			if (s->id == 0) 
-				s->id = identifier_search_or_add(s->name) ;
-			if (s->id > sysproc_maxid)
-				sysproc_maxid = s->id;
+			if (s->id == 0) s->id = identifier_search_or_add(s->name) ;
+			if (s->id > sysproc_maxid) sysproc_maxid = s->id;
 
 			s->next = NULL;
 		}
@@ -135,8 +132,7 @@
 
 		sysproc_maxid = ((sysproc_maxid+1) & ~31) + 32;
 		sysproc_list  = (SYSPROC * *) calloc (sysproc_maxid, sizeof(SYSPROC*));
-		if (sysproc_list == NULL)
-			abort();
+		if (sysproc_list == NULL) abort();
 
 		/* Fill it */
 
@@ -176,8 +172,7 @@
 	SYSPROC * * table;
 	int found = 0 ;
 
-	if (s == NULL)
-		return NULL;
+	if (s == NULL) return NULL;
 
 	table = malloc(sizeof(SYSPROC *) * 32) ;
 	do
