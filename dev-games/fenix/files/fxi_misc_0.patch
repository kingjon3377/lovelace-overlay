Index: fxi/inc/fmath.h
===================================================================
--- a/fxi/inc/fmath.h	2007-08-28 14:38:24.000000000 +0200
+++ b/fxi/inc/fmath.h	2007-08-28 14:41:10.000000000 +0200
@@ -24,15 +24,23 @@
  *
  */
 
+#ifndef _FMATH_H
+    #define _FMATH_H
+
 /* Rutinas matemáticas de punto fijo, basadas en Allegro */
 
 #ifndef M_PI
 #define M_PI           3.14159265358979323846  /* pi */
 #endif
 
+    #ifndef ABS
+    #define ABS(x) (((x) < 0) ? -(x):(x))
+    #endif
 #ifndef MAX
-#define MAX(a,b)        ((a)>(b) ? (a):(b))
-#define MIN(a,b)        ((a)<(b) ? (a):(b))
+    #define MAX(a, b)  (((a) > (b)) ? (a) : (b))
+    #endif
+    #ifndef MIN
+    #define MIN(a, b)  (((a) < (b)) ? (a) : (b))
 #endif
 
 typedef long int fixed ;
@@ -122,3 +130,5 @@
 {
 	return ftofix (fixtof(x) / fixtof(y)) ;
 }
+
+#endif
Index: fxi/inc/fxi.h
===================================================================
--- a/fxi/inc/fxi.h	2007-08-28 14:38:24.000000000 +0200
+++ b/fxi/inc/fxi.h	2007-08-28 14:41:10.000000000 +0200
@@ -55,6 +55,8 @@
 #include "files.h"
 #include "xctype.h"
 
+#include "fmath.h"
+
 /*
  *  CONSTANTS
  */
Index: fxi/inc/grlib.h
===================================================================
--- a/fxi/inc/grlib.h	2007-08-28 14:38:24.000000000 +0200
+++ b/fxi/inc/grlib.h	2007-08-28 14:41:10.000000000 +0200
@@ -42,6 +42,8 @@
 extern int				enable_16bits ;      /* 1 = 16bpp MODE on                */
 extern int				enable_filtering ;   /* 1 = 16bpp filter MODE on         */
 
+extern DRAWING_OBJECT * drawing_objects ;
+
 extern Uint16			syscolor16 ;
 extern int				syscolor8 ;			 /* Color for drawing primitives	 */
 extern Uint16           fntcolor16 ;
@@ -132,9 +134,19 @@
 extern int          palette_loaded ;        /* ¿Se ha cargado ya la paleta inicial ? */
 extern int          palette_changed ;       /* Poner a 1 cuando se cambien colores   */
 extern int          fade_on ;               /* ¿Hay un fade activo?                  */
+extern int          fade_set ;              /* ¿Hay un fade seteado pero inactivo?   */
 extern int          fade_step ;             /* Si lo hay, posición (0=off)           */
 
-extern int          gr_read_pal           (file * file) ;
+
+extern PALETTE * pal_new(PALETTE * basepal);
+extern PALETTE * pal_new2(unsigned char * datapal);
+
+extern void pal_destroy(PALETTE * pal);
+extern void pal_refresh(PALETTE * pal);
+
+extern PALETTE    * gr_read_pal             (file * fp) ;
+extern PALETTE    * gr_read_pal_with_gamma  (file * fp);
+
 extern void         gr_refresh_palette    () ;
 extern void         gr_fade_init          (int pr, int pg, int pb, int speed) ;
 extern void         gr_fade_step          () ;
@@ -204,6 +216,7 @@
 extern GRAPH * bitmap_new_syslib (int w, int h, int depth, int frames) ;
 extern GRAPH * bitmap_get        (int libid, int mapcode) ;
 extern void    bitmap_destroy    (GRAPH * map) ;
+extern void    bitmap_destroy_fake (GRAPH * map) ;
 extern void    bitmap_add_cpoint (GRAPH *map, int x, int y) ;
 extern void    bitmap_set_cpoint (GRAPH * map, Uint32 point, int x, int y);
 extern void    bitmap_analize    (GRAPH * bitmap) ;
@@ -310,6 +323,9 @@
 extern void gr_drawing_destroy (int id) ;
 extern void gr_drawing_move    (int id, int x, int y) ;
 
+extern void draw_object (DRAWING_OBJECT * dr, REGION * clip) ;
+extern int info_object (DRAWING_OBJECT * dr, REGION * clip) ;
+
 /* Bitmaps */
 
 extern void gr_blit          (GRAPH * dest, REGION * clip, int x, int y, int flags, GRAPH * gr) ;
Index: fxi/inc/grlib_st.h
===================================================================
--- a/fxi/inc/grlib_st.h	2007-08-28 14:38:24.000000000 +0200
+++ b/fxi/inc/grlib_st.h	2007-08-28 14:41:11.000000000 +0200
@@ -95,6 +95,16 @@
 }
 CPOINT ;
 
+typedef struct _palette
+{
+    SDL_Color       rgb[256] ;
+    Uint16          colorequiv[256] ;
+    int             use;
+    struct _palette * next ;
+    struct _palette * prev ;
+}
+PALETTE ;
+
 typedef struct _bitmap
 {
     void      * data ;				/* Pointer to the bitmap data at current frame */
@@ -112,6 +122,8 @@
     Uint32      ncpoints;			/* Number of control points */
     Uint32      offset ;			/* Offset of the graphic (in the FPG file) */
 
+    PALETTE   * palette ;           /* Palette for 8 bits graphics */
+
     Sint16    * blend_table ;		/* Pointer to 16 bits blend table if any */
 
     int         modified ;			/* 1 if bitmap needs analysis */
Index: fxi/inc/instance_st.h
===================================================================
--- a/fxi/inc/instance_st.h	2007-08-28 14:38:24.000000000 +0200
+++ b/fxi/inc/instance_st.h	2007-08-28 14:41:11.000000000 +0200
@@ -27,6 +27,10 @@
 #ifndef __INSTANCE_ST_H
 #define __INSTANCE_ST_H
 
+//#ifndef __I_PROCDEF_H
+//#include "i_procdef.h"
+//#endif
+
 #define STACK_NO_RETURN_VALUE	0x8000
 #define STACK_SIZE_MASK			0x7FFF
 
@@ -67,7 +71,6 @@
 
 	/* Function support */
 
-/*	struct _instance * waiting_for ; */
 	struct _instance * called_by ;
 
 	/* The first integer at the stack is the stack size,
@@ -80,15 +83,15 @@
 	struct _procdef  * inproc ;
 	void             * inpridata ;
 
+    int switchval;
+    int switchval_string;
+    int cased;
+
 	int               breakpoint;
 
 }
 INSTANCE ;
 
-//#ifndef __I_PROCDEF_H
-//#include "i_procdef.h"
-//#endif
-
 /* Macros para acceder a datos locales o privados de una instancia */
 #define LOCDWORD(a,b) ( *(Sint32 *) ((Uint8 *)(a->locdata)+b) )
 #define LOCWORD(a,b)  ( *(Uint16 *) ((Uint8 *)(a->locdata)+b) )
Index: fxi/src/Be_compat/be_compat.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ b/fxi/src/Be_compat/be_compat.cpp	2007-08-28 14:41:11.000000000 +0200
@@ -0,0 +1,29 @@
+/*-------------------------------------------------------------------------------------------------------
+Copyright (c) 2003 Joseba GarcÃ­a Etxebarria, under the GPL, as described
+on copying in the (Fenix)/COPYING file.
+This file provides a thin BeOS->C compatibility layer, as the BeOS kits are
+designed for C++.
+Now alert dialogs are created using the system call, but this may change as to
+be able to use it in fullscreen modes (writting my own implementation of the
+dialog using BDirectWindow)
+We don't need to create a BApplication objet, SDL does that for us.
+-------------------------------------------------------------------------------------------------------*/
+#include <sys/types.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <be/interface/Alert.h>
+
+extern "C" __declspec(dllexport) void be_alert(const char *error) {
+	char *error_msg;
+	int len;
+	error_msg = strdup(error);
+
+	for (len = strlen(error_msg); len && (error_msg[len-1] == '\n'); --len)
+		error_msg[len-1] = 0;
+
+	BAlert * alert_p = new BAlert("FXI Error", error_msg, "OK", NULL, NULL, B_WIDTH_AS_USUAL, B_STOP_ALERT);
+	alert_p -> Go();
+	free (error_msg);
+}
Index: fxi/src/Be_compat/be_compat.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ b/fxi/src/Be_compat/be_compat.h	2007-08-28 14:41:11.000000000 +0200
@@ -0,0 +1,5 @@
+#ifndef _BE_COMPAT_H
+#define _BE_COMPAT_H
+
+void be_alert (const char *error);
+#endif
Index: fxi/src/Be_compat/libbe_compat.proj
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ b/fxi/src/Be_compat/libbe_compat.proj	2007-08-28 14:41:11.000000000 +0200
@@ -0,0 +1 @@
+MIDE
\ No newline at end of file
Index: fxi/src/dcbr.c
===================================================================
--- a/fxi/src/dcbr.c	2007-08-28 14:40:57.000000000 +0200
+++ b/fxi/src/dcbr.c	2007-08-28 14:41:11.000000000 +0200
@@ -124,7 +124,7 @@
 
     while (!file_eof(fp))
     {
-        file_gets (fp, line, 2048) ;
+        file_qgets (fp, line, 2048) ;
         trim(line);
         if (allocated == count)
         {
Index: fxi/src/fbm.c
===================================================================
--- a/fxi/src/fbm.c	2007-08-28 14:39:54.000000000 +0200
+++ b/fxi/src/fbm.c	2007-08-28 14:41:11.000000000 +0200
@@ -87,6 +87,46 @@
 	}
 }
 
+
+
+
+
+
+
+
+int fbm_insert_frame(gr, frame, where)
+{
+}
+
+int fbm_remove_frame(gr, frame)
+{
+}
+
+int fbm_insert_keyframe(gr, keyframe, where)
+{
+}
+
+int fbm_remove_keyframe(gr, keyframe)
+{
+}
+
+int fbm_insert_sequence(gr, seq, where)
+{
+}
+
+int fbm_remove_sequence(gr, seq)
+{
+}
+
+
+
+
+
+
+
+
+
+
 /*
  *  FUNCTION : fbm_load_from
  *
@@ -173,11 +213,13 @@
 		fbm_error = _("FBM file is corrupt");
 		return NULL;
 	}
+/*
 	if (header.width > FBM_MAX_WIDTH || header.height > FBM_MAX_HEIGHT)
 	{
 		fbm_error = "FBM file is corrupt";
 		return NULL;
 	}
+*/
 
 	// Allocate space in memory for the data
 
@@ -229,9 +271,8 @@
 					{
 						fbm_error = _("FBM file is truncated");
 						error = 1;
+						break;
 					}
-					else
-					{
 						if (!palette_loaded) {
 							for (n = 0 ; n < 256 ; n++)
 							{
@@ -239,16 +280,13 @@
 								palette[n].g = color_palette[3*n + 1];
 								palette[n].b = color_palette[3*n + 2];
 							}
+                    }
 
-
-							// bug 62 : initialization of palette vars
+                    graph->palette = pal_new2(color_palette);
 
 							palette_loaded = 1 ;
 							palette_changed = 1 ;
 						}
-
-					}
-				}
 				break;
 
 			case 1:				// Read the sequences
@@ -302,9 +340,9 @@
 			case 4:				// Read the graphic data
 
             	if (graph->depth == 1)
-            		size = (graph->width + 7)/8 /* * graph->height*/;
+            		size = (graph->width + 7)/8 ;
             	else
-            		size = graph->width /* * map->height */ * graph->depth / 8;
+            		size = graph->width * graph->depth / 8;
 
                 h = graph->height * graph->frames;
 
@@ -328,8 +366,9 @@
 
 	if (error)
 	{
-		if (graph != NULL)
+		if (graph) {
 			bitmap_destroy(graph);
+		}
 		else
 		{
 			if (sequences) free(sequences);
@@ -396,6 +435,7 @@
 	static char			color_palette[768];
     char                * data_copy = NULL;
     char                * data = NULL;
+    SDL_Color           * gpal = NULL;
 
 	// Prepare the header
 
@@ -446,11 +486,13 @@
 
 	if (map->depth == 8 && with_palette)
 	{
+        if (map->palette) gpal = map->palette->rgb; else gpal = palette;
+
 		for (n = 0 ; n < 256 ; n++)
 		{
-			color_palette[3*n + 0] = palette[n].r;
-			color_palette[3*n + 1] = palette[n].g;
-			color_palette[3*n + 2] = palette[n].b;
+			color_palette[3*n    ] = gpal[n].r;
+			color_palette[3*n + 1] = gpal[n].g;
+			color_palette[3*n + 2] = gpal[n].b;
 		}
 
 		if (file_write (fp, &color_palette, 768) != 768)
@@ -512,9 +554,9 @@
 	// Write the graphic data
 
 	if (map->depth == 1)
-		size = (map->width + 7)/8 /* * map->height*/;
+		size = (map->width + 7)/8 ;
 	else
-		size = map->width /* * map->height */ * map->depth / 8;
+		size = map->width * map->depth / 8;
 
 	if (map->depth == 16)
 	{
Index: fxi/src/f_cd.c
===================================================================
--- a/fxi/src/f_cd.c	2007-08-28 14:38:24.000000000 +0200
+++ b/fxi/src/f_cd.c	2007-08-28 14:41:11.000000000 +0200
@@ -105,11 +105,11 @@
 	GLODWORD(CD_TRACK)  = sdl_cd->cur_track;
 	FRAMES_TO_MSF (sdl_cd->cur_frame, &GLODWORD(CD_MINUTE), &GLODWORD(CD_SECOND), &GLODWORD(CD_SUBFRAME));
 
-	for (i = 0, pos = CD_TRACKINFO ; i < sdl_cd->numtracks ; i++, pos += 4)
+	for (i = 0, pos = CD_TRACKINFO ; i < sdl_cd->numtracks ; i++, pos += 16)
 	{
 		total += sdl_cd->track[i].length;
 		GLODWORD(pos) = (sdl_cd->track[i].type == SDL_AUDIO_TRACK);
-		FRAMES_TO_MSF (sdl_cd->track[i].length, &GLODWORD(pos+1), &GLODWORD(pos+2), &GLODWORD(pos+3));
+		FRAMES_TO_MSF (sdl_cd->track[i].length, &GLODWORD(pos+4), &GLODWORD(pos+8), &GLODWORD(pos+12));
 	}
 	FRAMES_TO_MSF (total, &GLODWORD(CD_MINUTES), &GLODWORD(CD_SECONDS), &GLODWORD(CD_FRAMES));
 	return 1;
@@ -239,7 +239,7 @@
 	return !SDL_CDStop(sdl_cd);
 }
 
-
+/*
 int fxi_cd_numtracks(INSTANCE * my, int * params)
 {
 	if (params[0] < 0 || params[0] >= SDL_CDNumDrives()) return 0;
@@ -270,4 +270,5 @@
 
 	return sdl_cd->cur_track;
 }
+*/
 
Index: fxi/src/fgc.c
===================================================================
--- a/fxi/src/fgc.c	2007-08-28 14:39:54.000000000 +0200
+++ b/fxi/src/fgc.c	2007-08-28 14:41:11.000000000 +0200
@@ -75,6 +75,7 @@
 	FGC_HEADER	header;
 	Uint32 *	offsets;
 	Uint32		i;
+	PALETTE *   pal = NULL;
 
 	// Open the file and check the header and version
 
@@ -145,6 +146,8 @@
 			return -1;
 		}
 
+        pal = pal_new2(color_palette);
+
 		if (!palette_loaded)
 		{
 			for (i = 0 ; i < 256 ; i++)
@@ -171,10 +174,14 @@
 			break;
 		}
 		grlib_add_map (id, graph);
+		if (graph->depth == 8 && !graph->palette) pal_map_assign(id, graph, pal);
 	}
 
 	free(offsets);
 	file_close(fp);
+
+    pal_destroy(pal); // Elimino la instancia inicial
+
 	return (i == header.count ? id : -1);
 }
 
@@ -199,6 +206,7 @@
 	file *		fp;
 	int			i, n;
 	Uint32 *    offsets;
+	int         palette_saved = 0;
 
 	// Check the parameters 
 	
@@ -219,12 +227,10 @@
 
 	for (i = 0 ; i < lib->map_reserved ; i++)
 	{
-		if (lib->maps[i] == NULL)
-			continue;
+		if (lib->maps[i] == NULL) continue;
 
 		// Maps with code > 999 are not inside a collection
-		if (lib->maps[i]->code > 999)
-			continue;
+		if (lib->maps[i]->code > 999) continue;
 
 		header.count++;
 		if (header.depth == 0)
@@ -264,17 +270,14 @@
 
 	for (i = n = 0 ; i < lib->map_reserved ; i++)
 	{
-		if (lib->maps[i] == NULL)
-			continue;
+		if (lib->maps[i] == NULL) continue;
 		// Maps with code > 999 are not inside a collection
-		if (lib->maps[i]->code > 999)
-			continue;
+		if (lib->maps[i]->code > 999) continue;
 
 		if (n == 0)
 		{
 			offsets[n] = sizeof(FGC_HEADER) + 4*header.count;
-			if (header.depth == 8)
-				offsets[n] += 768;
+			if (header.depth == 8) offsets[n] += 768;
 		}
 		
 		offsets[n+1] = offsets[n] + fbm_size(lib->maps[i], 0, 0);
@@ -307,37 +310,41 @@
 		return 0;
 	} 
 	
+	// Write each graphic
+
+	for (i = n = 0 ; i < lib->map_reserved ; i++)
+	{
+		if (lib->maps[i] == NULL)
+			continue;
+		// Maps with code > 999 are not inside a collection
+		if (lib->maps[i]->code > 999)
+			continue;
+
 	// Write the graphic palette
 
-	if (header.depth == 8)
+		if (!palette_saved && header.depth == 8)
 	{
 		static char color_palette[768];
+			SDL_Color * gpal = palette ;
+
+			if (lib->maps[i]->palette) gpal = lib->maps[i]->palette->rgb; else gpal = palette;
 
 		for (i = 0 ; i < 256 ; i++)
 		{
-			color_palette[3*i + 0] = palette[i].r;
-			color_palette[3*i + 1] = palette[i].g;
-			color_palette[3*i + 2] = palette[i].b;
+				color_palette[3*i    ] = gpal[i].r;
+				color_palette[3*i + 1] = gpal[i].g;
+				color_palette[3*i + 2] = gpal[i].b;
 		}
 		if (file_write(fp, color_palette, 768) != 768)
 		{
-			fgc_error = _("Write error, FGC file is truncated");
+				fgc_error = "Error al escribir, FGC truncado";
 			free(offsets);
 			file_close(fp);
 			return -1;
 		} 
+			palette_saved = 1;
 	}
 
-	// Write each graphic
-
-	for (i = n = 0 ; i < lib->map_reserved ; i++)
-	{
-		if (lib->maps[i] == NULL)
-			continue;
-		// Maps with code > 999 are not inside a collection
-		if (lib->maps[i]->code > 999)
-			continue;
-
 		assert (file_pos(fp) == (int)offsets[n]);
 
 		if (!fbm_save_to (lib->maps[i], fp, 0))
Index: fxi/src/fnc_exports.c
===================================================================
--- a/fxi/src/fnc_exports.c	2007-08-28 14:39:54.000000000 +0200
+++ b/fxi/src/fnc_exports.c	2007-08-28 14:41:12.000000000 +0200
@@ -72,6 +72,8 @@
     { "file_write"                      , file_write                  },
     { "file_gets"                       , file_gets                   },
     { "file_puts"                       , file_puts                   },
+    { "file_qgets"                      , file_qgets                  },
+    { "file_qputs"                      , file_qputs                  },
     { "file_size"                       , file_size                   },
     { "file_pos"                        , file_pos                    },
     { "file_seek"                       , file_seek                   },
Index: fxi/src/fpl.c
===================================================================
--- a/fxi/src/fpl.c	2007-08-28 14:39:55.000000000 +0200
+++ b/fxi/src/fpl.c	2007-08-28 14:44:03.000000000 +0200
@@ -100,7 +100,7 @@
 	}
 
 	for (n = 0 ; n < 256 ; n++) {
-		palette[n].r = color_palette[3*n + 0];
+		palette[n].r = color_palette[3*n    ];
 		palette[n].g = color_palette[3*n + 1];
 		palette[n].b = color_palette[3*n + 2];
 	}
@@ -135,7 +135,7 @@
 
 	for (n = 0 ; n < 256 ; n++)
 	{
-		color_palette[3*n + 0] = palette[n].r;
+		color_palette[3*n    ] = palette[n].r;
 		color_palette[3*n + 1] = palette[n].g;
 		color_palette[3*n + 2] = palette[n].b;
 	}
Index: fxi/src/g_blendop.c
===================================================================
--- a/fxi/src/g_blendop.c	2007-08-28 14:38:25.000000000 +0200
+++ b/fxi/src/g_blendop.c	2007-08-28 14:41:12.000000000 +0200
@@ -323,8 +323,8 @@
 			r = GETR(i);
 			g = GETG(i);
 			b = GETB(i);
-			max = r > g ? r > b ? r : g : g > b ? g : b ;
-			min = r < g ? r < b ? r : g : g < b ? g : b ;
+			max = (r > g) ? (r > b) ? r : g : (g > b) ? g : b ;
+			min = (r < g) ? (r < b) ? r : g : (g < b) ? g : b ;
 			r = (max+min)/2;
 			blend[i] = MAKERGB(r, r, r) ;
 		}
@@ -336,7 +336,7 @@
 			r = GETR(i);
 			g = GETG(i);
 			b = GETB(i);
-			max = r > g ? r > b ? r : g : g > b ? g : b ;
+			max = (r > g) ? (r > b) ? r : g : (g > b) ? g : b ;
 			blend[i] = MAKERGB(max, max, max) ;
 		}
 	}
Index: fxi/src/g_blit.c
===================================================================
--- a/fxi/src/g_blit.c	2007-08-28 14:39:55.000000000 +0200
+++ b/fxi/src/g_blit.c	2007-08-28 14:41:12.000000000 +0200
@@ -96,6 +96,8 @@
 Sint16  * ghost2;
 Uint8   * ghost8;
 
+Uint16 * pcolorequiv = NULL ;
+
 /*
     Calculates additive blend value
 */
@@ -243,9 +245,6 @@
  *
  */
 
-extern Sint16 * ghost1;
-extern Sint16 * ghost2;
-extern Uint8  * ghost8;
 /*
 void draw_span_1to1(GRAPH * dest, GRAPH * orig, int x, int y, int pixels,
                     int s, int t, int incs, int inct)
@@ -287,8 +286,7 @@
 }
 */
 
-void draw_span_1to8(GRAPH * dest, GRAPH * orig, int x, int y, int pixels,
-                    int s, int t, int incs, int inct)
+void draw_span_1to8(GRAPH * dest, GRAPH * orig, int x, int y, int pixels, int s, int t, int incs, int inct)
 {
     Uint8 * ptr = (Uint8 *)dest->data + dest->pitch*y + x ;
     int cs = s, ct = t, i;
@@ -302,8 +300,7 @@
     }
 }
 
-void draw_span_8to8_nocolorkey(GRAPH * dest, GRAPH * orig, int x, int y, int pixels,
-                                int s, int t, int incs, int inct)
+void draw_span_8to8_nocolorkey(GRAPH * dest, GRAPH * orig, int x, int y, int pixels, int s, int t, int incs, int inct)
 {
     Uint8 * ptr = (Uint8 *)dest->data + dest->pitch*y + x;
     int cs = s, ct = t, i;
@@ -401,7 +398,7 @@
     for (i = 0 ; i < pixels ; i++)
     {
         Uint8 * tex = (Uint8 *)orig->data + orig->pitch*(ct >> 16) + (cs >> 16);
-        if (*tex != 0) *ptr = colorequiv[*tex];
+        if (*tex != 0) *ptr = pcolorequiv[*tex];
         ptr++;
         cs += incs, ct += inct;
     }
@@ -417,7 +414,7 @@
     for (i = 0 ; i < pixels ; i++)
     {
         Uint8 * tex = (Uint8 *)orig->data + orig->pitch*(ct >> 16) + (cs >> 16);
-        if (*tex != 0) *ptr = ablend(colorequiv[*tex],*ptr);
+        if (*tex != 0) *ptr = ablend(pcolorequiv[*tex],*ptr);
         ptr++;
         cs += incs, ct += inct;
     }
@@ -432,7 +429,7 @@
     for (i = 0 ; i < pixels ; i++)
     {
         Uint8 * tex = (Uint8 *)orig->data + orig->pitch*(ct >> 16) + (cs >> 16);
-        if (*tex != 0) *ptr = ablend((Uint16)(ghost1[colorequiv[*tex]] + ghost2[*ptr]),*ptr);
+        if (*tex != 0) *ptr = ablend((Uint16)(ghost1[pcolorequiv[*tex]] + ghost2[*ptr]),*ptr);
         ptr++;
         cs += incs, ct += inct;
     }
@@ -447,7 +444,7 @@
     for (i = 0 ; i < pixels ; i++)
     {
         Uint8 * tex = (Uint8 *)orig->data + orig->pitch*(ct >> 16) + (cs >> 16);
-        if (*tex != 0) *ptr = ghost1[colorequiv[*tex]] + ghost2[*ptr];
+        if (*tex != 0) *ptr = ghost1[pcolorequiv[*tex]] + ghost2[*ptr];
         ptr++;
         cs += incs, ct += inct;
     }
@@ -462,7 +459,7 @@
     for (i = 0 ; i < pixels ; i++)
     {
         Uint8 * tex = (Uint8 *)orig->data + orig->pitch*(ct >> 16) + (cs >> 16);
-        *ptr++ = colorequiv[*tex];
+        *ptr++ = pcolorequiv[*tex];
         cs += incs, ct += inct;
     }
 }
@@ -659,7 +656,7 @@
 
     for (i = 0 ; i < pixels ; i++)
     {
-        if (*tex != 0) *scr = colorequiv[*tex];
+        if (*tex != 0) *scr = pcolorequiv[*tex];
         scr++;
         tex += incs;
     }
@@ -671,7 +668,7 @@
 
     for (i = 0 ; i < pixels ; i++)
     {
-        if (*tex != 0) *scr = ablend(colorequiv[*tex], *scr);
+        if (*tex != 0) *scr = ablend(pcolorequiv[*tex], *scr);
         scr++;
         tex += incs;
     }
@@ -683,7 +680,7 @@
 
     for (i = 0 ; i < pixels ; i++)
     {
-        if (*tex != 0) *scr = ablend((Uint16)(ghost1[colorequiv[*tex]] + ghost2[*scr]),*scr);
+        if (*tex != 0) *scr = ablend((Uint16)(ghost1[pcolorequiv[*tex]] + ghost2[*scr]),*scr);
         scr++;
         tex += incs;
     }
@@ -695,7 +692,7 @@
 
     for (i = 0 ; i < pixels ; i++)
     {
-        if (*tex != 0) *scr = ghost1[colorequiv[*tex]] + ghost2[*scr];
+        if (*tex != 0) *scr = ghost1[pcolorequiv[*tex]] + ghost2[*scr];
         scr++;
         tex += incs;
     }
@@ -707,7 +704,7 @@
 
     for (i = 0 ; i < pixels ; i++)
     {
-        *scr++ = colorequiv[*tex];
+        *scr++ = pcolorequiv[*tex];
         tex += incs;
     }
 }
@@ -1025,12 +1022,9 @@
 
     /* Analize the bitmap if needed (find if no color key used */
 
-    if (gr->modified)
-        bitmap_analize (gr) ;
+    if (gr->modified) bitmap_analize (gr) ;
 
-    if (gr->info_flags & GI_NOCOLORKEY) {
-        flags |= B_NOCOLORKEY ;
-    }
+    if (gr->info_flags & GI_NOCOLORKEY) flags |= B_NOCOLORKEY ;
 
     /* Setup the 16 bits translucency tables if necessay */
 
@@ -1059,8 +1053,7 @@
         ghost8 = (Uint8 *)trans_table ;
     }
 /*
-    if ((flags & B_TRANSLUCENT) && !trans_table_updated)
-        gr_make_trans_table() ;
+    if ((flags & B_TRANSLUCENT) && !trans_table_updated) gr_make_trans_table() ;
 */
     #ifdef MMX_FUNCTIONS
     if (MMX_available) {
@@ -1100,6 +1093,8 @@
     }
     else if (dest->depth == 16 && gr->depth == 8)
     {
+        pcolorequiv = gr->palette ? gr->palette->colorequiv : colorequiv ;
+
         if (flags & B_TRANSLUCENT){
             if(flags & B_ABLEND){
                 bt=0;
@@ -1347,11 +1342,9 @@
 
     /* Analize the bitmap if needed (find if no color key used */
 
-    if (gr->modified)
-        bitmap_analize (gr) ;
+    if (gr->modified) bitmap_analize (gr) ;
 
-    if (gr->info_flags & GI_NOCOLORKEY)
-        flags |= B_NOCOLORKEY ;
+    if (gr->info_flags & GI_NOCOLORKEY) flags |= B_NOCOLORKEY ;
 
     /* Setup the 16 bits translucency tables if necessay */
 
@@ -1379,9 +1372,9 @@
         ghost1 = ghost2 = colorghost ;
         ghost8 = (Uint8 *)trans_table ;
     }
+
 /*
-    if ((flags & B_TRANSLUCENT) && !trans_table_updated)
-        gr_make_trans_table() ;
+    if ((flags & B_TRANSLUCENT) && !trans_table_updated) gr_make_trans_table() ;
 */
     #ifdef MMX_FUNCTIONS
     if (MMX_available) {
@@ -1448,6 +1441,8 @@
     }
     else if (dest->depth == 16 && gr->depth == 8)
     {
+        pcolorequiv = gr->palette ? gr->palette->colorequiv : colorequiv ;
+
         if (flags & B_TRANSLUCENT){
             if(flags & B_ABLEND){
                 bt=0;
@@ -1479,9 +1474,10 @@
             }else if(flags & B_SBLEND){
                 bt=1;
                 draw_hspan = draw_hspan_16to16_tablend;
-            }else
+            }else{
                 draw_hspan = draw_hspan_16to16_translucent;
         }
+        }
         else if(flags & B_ABLEND){
             bt=0;
             draw_hspan = draw_hspan_16to16_ablend;
@@ -1569,10 +1565,8 @@
 
     /* Mirror the texture coordinates if needed */
 
-    if (flags & B_HMIRROR)
-        s = gr->width - 1 - s;
-    if (flags & B_VMIRROR)
-        t = gr->height - 1 - t;
+    if (flags & B_HMIRROR) s = gr->width - 1 - s;
+    if (flags & B_VMIRROR) t = gr->height - 1 - t;
 
     /* Calculate the initial pointers and advances */
 
@@ -1583,10 +1577,8 @@
     tex_inc   = gr->pitch ;
     direction = 1;
 
-    if (flags & B_VMIRROR)
-        tex_inc = -tex_inc;
-    if (flags & B_HMIRROR)
-        direction = -1;
+    if (flags & B_VMIRROR) tex_inc = -tex_inc;
+    if (flags & B_HMIRROR) direction = -1;
 
     if (p > 0)
     {
@@ -1597,6 +1589,7 @@
             tex = (Uint8 *)tex + tex_inc;
         }
     }
+
     dest->modified = 1 ;
 }
 
Index: fxi/src/g_console.c
===================================================================
--- a/fxi/src/g_console.c	2007-08-28 14:39:56.000000000 +0200
+++ b/fxi/src/g_console.c	2007-08-28 14:41:12.000000000 +0200
@@ -53,9 +53,9 @@
 #define CHARHEIGHT 8
 
 #define CONSOLE_HISTORY 512
-#define CONSOLE_LINES   16
-#define CONSOLE_COLUMNS 52
-#define COMMAND_HISTORY 64
+#define CONSOLE_LINES   25
+#define CONSOLE_COLUMNS 80
+#define COMMAND_HISTORY 128
 
 #define HELPTXT _( \
             "¬02Process Info¬07\n"                                          \
@@ -82,11 +82,11 @@
             "¬02Process Interaction¬07\n"                                   \
             "¬04RUN proc [args]¬07  Run a process\n"                        \
             "¬04KILL proc      ¬07  Kill a process\n"                       \
-            "¬04WEAKUP proc    ¬07  Weakup a process\n"                     \
+            "¬04WAKEUP proc    ¬07  Wakeup a process\n"                     \
             "¬04SLEEP proc     ¬07  Sleep a process\n"                      \
             "¬04FREEZE proc    ¬07  Freeze a process\n"                     \
             "¬04KILLALL proc   ¬07  Kill all process with criteria\n"       \
-            "¬04WEAKUPALL proc ¬07  Weakup all process with criteria\n"     \
+            "¬04WAKEUPALL proc ¬07  Wakeup all process with criteria\n"     \
             "¬04SLEEPALL proc  ¬07  Sleep all process with criteria\n"      \
             "¬04FREEZEALL proc ¬07  Freeze all process with criteria\n"     \
             "\n"                                                            \
@@ -367,6 +367,7 @@
     }
 }
 
+extern int * stack_gptr;
 
 void gr_con_draw()
 {
@@ -377,6 +378,14 @@
     if (!console_initialized)
         return ;
 
+    if (console_columns > scrbitmap->width / CHARWIDTH) {
+        console_columns = scrbitmap->width / CHARWIDTH ;
+    }
+
+    if (console_lines > ( scrbitmap->height - CHARHEIGHT * 2 ) / CHARHEIGHT) {
+        console_lines = ( scrbitmap->height - CHARHEIGHT * 2 ) / CHARHEIGHT ;
+    }
+
     if (console_showing)
     {
         if (con_y < console_lines*CHARHEIGHT)
@@ -396,14 +405,6 @@
         if (con_y < 0) { con_y = 0 ; vy = CHARHEIGHT ; return ; }
     }
 
-    if ( scrbitmap->width < console_columns * CHARWIDTH ) {
-        console_columns = scrbitmap->width / CHARWIDTH ;
-    }
-
-    if ( scrbitmap->height < console_lines * CHARHEIGHT ) {
-        console_lines = ( scrbitmap->height - CHARHEIGHT * 2 ) / CHARHEIGHT ;
-    }
-
     x = (scrbitmap->width - console_columns*CHARWIDTH)/2 ;
     y = -console_lines*CHARHEIGHT + con_y ;
 
@@ -421,8 +422,8 @@
             gr_sys_color (console_showcolor, 0) ;
             gr_sys_puts (scrbitmap,
                          (scrbitmap->width - strlen(result)*CHARWIDTH)/2,
-                         con_y <= 0 ? 2:con_y+CHARHEIGHT, result, strlen(result));
-            gr_mark_rect (0, con_y <= 0 ? 2:con_y+CHARHEIGHT, scr_width, CHARHEIGHT);
+                         (con_y <= 0) ? 2:con_y+CHARHEIGHT, result, strlen(result));
+            gr_mark_rect (0, (con_y <= 0) ? 2:con_y+CHARHEIGHT, scr_width, CHARHEIGHT);
         }
     }
 
@@ -1228,7 +1229,7 @@
             _snprintf (result.name, sizeof(result.name), "%g", base) ;
             return ;
         }
-        op = token.name[0] == '*' ? 1: token.name[0] == '/' ? 2:3 ;
+        op = (token.name[0] == '*') ? 1: (token.name[0] == '/') ? 2:3 ;
         get_token() ;
     }
 }
@@ -1259,7 +1260,7 @@
             _snprintf (result.name, sizeof(result.name), "%g", base) ;
             return ;
         }
-        op = token.name[0] == '+' ? 1:-1 ;
+        op = (token.name[0] == '+') ? 1:-1 ;
         get_token() ;
     }
 }
@@ -1286,7 +1287,7 @@
     }
 
     memset (part, 0, sizeof(buffer));
-    strncpy (part, here, token_ptr - here - (token.type != NOTOKEN ? 1:0));
+    strncpy (part, here, token_ptr - here - ((token.type != NOTOKEN) ? 1:0));
 
     if (result.type == T_CONSTANT)
     {
@@ -1485,7 +1486,7 @@
         return ;
     }
 
-    if (strncmp (action, "BREAK", 5) == 0)
+    if (strcmp (action, "BREAK") == 0)
     {
         if (*ptr) {
             if (*ptr >= '0' && *ptr <= '9')
@@ -1549,7 +1550,7 @@
         return ;
     }
 
-    if (strncmp (action, "DELETE", 6) == 0)
+    if (strcmp (action, "DELETE") == 0)
     {
         if (*ptr) {
             if (*ptr >= '0' && *ptr <= '9')
@@ -1607,9 +1608,9 @@
         return ;
     }
 
-    if (strncmp (action, "LOCAL", 5) == 0 ||
-        strncmp (action, "PRIVATE", 7) == 0 ||
-        strncmp (action, "PUBLIC", 6) == 0)
+    if (strcmp (action, "LOCALS") == 0 ||
+        strcmp (action, "PRIVATES") == 0 ||
+        strcmp (action, "PUBLICS") == 0)
     {
         int show_locals = action[0] == 'L';
         int show_public = action[0] == 'P' && action[1] == 'U' ;
@@ -1682,7 +1683,7 @@
         return ;
     }
 
-    if (strncmp (action, "RUN", 3) == 0)
+    if (strcmp (action, "RUN") == 0)
     {
         if (*ptr) {
             aptr = action;
@@ -1758,10 +1759,10 @@
         }
     }
 
-    if (strncmp (action, "KILLALL", 7) == 0 ||
-        strncmp (action, "SLEEPALL", 8) == 0 ||
-        strncmp (action, "WEAKUPALL", 9) == 0 ||
-        strncmp (action, "FREEZEALL", 9) == 0 )
+    if (strcmp (action, "KILLALL") == 0 ||
+        strcmp (action, "SLEEPALL") == 0 ||
+        strcmp (action, "WAKEUPALL") == 0 ||
+        strcmp (action, "FREEZEALL") == 0 )
     {
         char    act = *action;
         int     found = 0;
@@ -1797,10 +1798,10 @@
         return ;
     }
 
-    if (strncmp (action, "KILL", 4) == 0 ||
-        strncmp (action, "SLEEP", 5) == 0 ||
-        strncmp (action, "WEAKUP", 6) == 0 ||
-        strncmp (action, "FREEZE", 6) == 0 )
+    if (strcmp (action, "KILL") == 0 ||
+        strcmp (action, "SLEEP") == 0 ||
+        strcmp (action, "WAKEUP") == 0 ||
+        strcmp (action, "FREEZE") == 0 )
     {
         char act=*action;
         i = findproc(NULL, action, ptr);
Index: fxi/src/g_conversion.c
===================================================================
--- a/fxi/src/g_conversion.c	2007-08-28 14:39:56.000000000 +0200
+++ b/fxi/src/g_conversion.c	2007-08-28 14:41:13.000000000 +0200
@@ -76,10 +76,8 @@
 	int      i, color, inc, next = 0, factor;
 	Uint16 * table16 = NULL;
 
-	if (alpha16_tables_ok == count)
-		return;
-	if (count <= 0 || count > 128)
-		return;
+	if (alpha16_tables_ok == count) return;
+	if (count <= 0 || count > 128) return;
 
 	inc = 256/count;
 
@@ -394,10 +392,9 @@
 
 		for (x = 0 ; x < graph->width ; x++, ptr++)
 		{
-			*ptr = (
-				  Rtable[((*ptr & Rmask) >> Rshift)]
-				| Gtable[((*ptr & Gmask) >> Gshift)]
-				| Btable[((*ptr & Bmask) >> Bshift)] );
+			*ptr = (Rtable[((*ptr & Rmask) >> Rshift)] |
+			        Gtable[((*ptr & Gmask) >> Gshift)] |
+			        Btable[((*ptr & Bmask) >> Bshift)] );
 		}
 	}
 }
@@ -418,8 +415,7 @@
 
 Uint16 * gr_alpha16 (int alpha)
 {
-	if (alpha16_tables_ok == 0)
-		init_alpha16_tables(GLODWORD(ALPHA_STEPS));
+	if (alpha16_tables_ok == 0) init_alpha16_tables(GLODWORD(ALPHA_STEPS));
 	return alpha16[alpha];
 }
 
Index: fxi/src/g_draw.c
===================================================================
--- a/fxi/src/g_draw.c	2007-08-28 14:39:56.000000000 +0200
+++ b/fxi/src/g_draw.c	2007-08-28 14:41:13.000000000 +0200
@@ -46,17 +46,15 @@
 #include "files.h"
 #include "grlib.h"
 
-#define ABS(x) ((x) < 0 ? -(x):(x))
-
 int      syscolor8 = 15 ;
 Uint16   syscolor16 = 0xFFFF ;
-Uint16   syscolor16_alpha;
+Uint16   syscolor16_alpha = 0xFFFF ;
 int      drawing_alpha = 255;
-Uint16 * drawing_alpha16;
-Uint8  * drawing_alpha8;
+Uint16 * drawing_alpha16 = NULL ;
+Uint8  * drawing_alpha8 = NULL ;
 Uint32   drawing_stipple = 0xFFFFFFFF;
 
-static DRAWING_OBJECT * drawing_objects = NULL;
+DRAWING_OBJECT * drawing_objects = NULL;
 
 #ifdef __GNUC__
 #define _inline inline
@@ -72,8 +70,7 @@
     {
         register int n;
 
-        for (n = length ; n ; n--, ptr++)
-            *ptr = drawing_alpha8[(syscolor8 << 8) + *ptr];
+        for (n = length; n; n--, ptr++) *ptr = drawing_alpha8[(syscolor8 << 8) + *ptr];
     }
 }
 
@@ -85,18 +82,16 @@
     {
         for (n = length ; n ; n--, ptr++)
         {
-            if (drawing_stipple & 1)
-                *ptr = syscolor8;
-            drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+            if (drawing_stipple & 1) *ptr = syscolor8;
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
         }
     }
     else
     {
         for (n = length ; n ; n--, ptr++)
         {
-            if (drawing_stipple & 1)
-                *ptr = drawing_alpha8[(syscolor8 << 8) + *ptr];
-            drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+            if (drawing_stipple & 1) *ptr = drawing_alpha8[(syscolor8 << 8) + *ptr];
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
         }
     }
 }
@@ -107,13 +102,11 @@
 
     if (drawing_alpha == 255)
     {
-        for (n = length ; n ; n--)
-            *ptr++ = syscolor16 ;
+        for (n = length; n; n--) *ptr++ = syscolor16 ;
     }
     else
     {
-        for (n = length ; n ; n--, ptr++)
-            *ptr = drawing_alpha16[*ptr] + syscolor16_alpha ;
+        for (n = length; n; n--, ptr++) *ptr = drawing_alpha16[*ptr] + syscolor16_alpha ;
     }
 }
 
@@ -125,18 +118,16 @@
     {
         for (n = length ; n ; n--, ptr++)
         {
-            if (drawing_stipple & 1)
-                *ptr = syscolor16 ;
-            drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+            if (drawing_stipple & 1) *ptr = syscolor16 ;
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
         }
     }
     else
     {
         for (n = length ; n ; n--, ptr++)
         {
-            if (drawing_stipple & 1)
-                *ptr = drawing_alpha16[*ptr] + syscolor16_alpha ;
-            drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+            if (drawing_stipple & 1) *ptr = drawing_alpha16[*ptr] + syscolor16_alpha ;
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
         }
     }
 }
@@ -173,8 +164,7 @@
 
 int gr_get_pixel (GRAPH * dest, int x, int y)
 {
-    if (x < 0 || y < 0 || x >= (int)dest->width || y >= (int)dest->height)
-        return -1 ;
+    if (x < 0 || y < 0 || x >= (int)dest->width || y >= (int)dest->height) return -1 ;
 
     switch (dest->depth)
     {
@@ -208,8 +198,7 @@
 
 void gr_put_pixel (GRAPH * dest, int x, int y, int color)
 {
-    if (x < 0 || y < 0 || x >= (int)dest->width || y >= (int)dest->height)
-        return ;
+    if (x < 0 || y < 0 || x >= (int)dest->width || y >= (int)dest->height) return ;
 
     dest->modified = 1 ;
 
@@ -221,12 +210,14 @@
         case 16:
             _Pixel16(((Uint16 *)dest->data) + x + dest->pitch*y/2, color, gr_alpha16(drawing_alpha)[color]) ;
             break;
+
         case 1:
             if (color)
-                ((Uint8 *)dest->data)[x/8 + dest->pitch*y] |= (0x80 >> (x & 7)) ;
+                (((Uint8 *)dest->data)[x / 8 + dest->pitch * y]) |= (0x80 >> (x & 7)) ;
             else
-                ((Uint8 *)dest->data)[x/8 + dest->pitch*y] &= ~(0x80 >> (x & 7)) ;
+                (((Uint8 *)dest->data)[x / 8 + dest->pitch * y]) &= ~(0x80 >> (x & 7)) ;
             break;
+
         default:
             gr_error (_("gr_put_pixel: Unsupported colour depth"));
     }
@@ -252,6 +243,8 @@
 {
     if (clip && x >= clip->x && x <= clip->x2 && y >= clip->y && y <= clip->y2)
         gr_put_pixel (dest, x, y, color);
+
+    dest->modified = 1;
 }
 
 /*
@@ -273,8 +266,7 @@
 
     memset (dest->data, 0, dest->pitch * dest->height) ;
 
-    if (dest == background)
-        background_is_black = 1;
+    if (dest == background) background_is_black = 1;
 }
 
 /*
@@ -300,21 +292,46 @@
     switch (dest->depth)
     {
         case 8:
-            for (y = 0 ; y < dest->height ; y++)
-                memset ((Uint8 *)dest->data + dest->pitch * y, color, dest->width) ;
+        {
+            memset (dest->data, color, dest->pitch * dest->height) ;
+/*
+            Uint8 * data = dest->data ;
+            for (y = 0; y < dest->height; y++) {
+                memset (data, color, dest->pitch) ;
+                data += dest->pitch ;
+            }
+*/
             break;
+        }
+
         case 16:
+        {
+            Uint8 * data = dest->data ;
             for (y = 0 ; y < dest->height ; y++)
             {
-                Uint16 * ptr = (Uint16 *)dest->data + dest->pitch*y/2;
-                int n, m = dest->width ;
-                for (n = 0 ; n < m ; n++) *ptr++ = color ;
+                Uint16 * ptr = (Uint16 *)data ;
+                int n ;
+                for (n = 0; n < dest->width; n++) *ptr++ = color ;
+                data += dest->pitch ;
             }
             break;
+        }
+
         case 1:
-            for (y = 0 ; y < dest->height ; y++)
-                memset ((Uint8 *)dest->data + dest->pitch * y, color ? 0xFF:0, dest->width/8) ;
+        {
+            int c = color ? 0xFF : 0 ;
+            memset (dest->data, c, dest->pitch * dest->height) ;
+/*
+            Uint8 * data = dest->data ;
+            int c = color ? 0xFF : 0 ;
+            for (y = 0; y < dest->height; y++) {
+                memset (data, c, dest->pitch) ;
+                data += dest->pitch ;
+            }
+*/
             break;
+        }
+
         default:
             gr_error (_("gr_clear_as: Unsupported colour depth"));
     }
@@ -324,6 +341,87 @@
 }
 
 /*
+ *  FUNCTION : gr_clear_region
+ *
+ *  Clear a region bitmap (paint all pixels as 0 [transparent])
+ *
+ *  PARAMS :
+ *      dest            Bitmap to clear
+ *      region          Region to clear or NULL for the whole screen
+ *
+ *  RETURN VALUE :
+ *      None
+ *
+ */
+
+void gr_clear_region (GRAPH * dest, REGION * region)
+{
+    REGION base_region ;
+    int y, n, l ;
+
+    if (!dest) dest = scrbitmap ;
+    dest->modified = 1 ;
+
+    if (!region)
+    {
+        region = &base_region ;
+        region->x = 0 ;
+        region->y = 0 ;
+        region->x2 = dest->width - 1 ;
+        region->y2 = dest->height - 1 ;
+    }
+    else
+    {
+        base_region = *region ;
+        region = &base_region ;
+        region->x = MAX(MIN(region->x, region->x2), 0) ;
+        region->y = MAX(MIN(region->y, region->y2), 0) ;
+        region->x2 = MIN(MAX(region->x, region->x2), dest->width - 1) ;
+        region->y2 = MIN(MAX(region->y, region->y2), dest->height - 1) ;
+    }
+
+    switch (dest->depth)
+    {
+        case 8:
+        {
+            Uint8 * data = ((Uint8 *)dest->data) + dest->pitch * region->y + region->x ;
+            l = region->x2 - region->x + 1;
+            for (y = region->y; y <= region->y2; y++) {
+                memset (data, 0, l) ;
+                data += dest->pitch ;
+            }
+
+            break ;
+        }
+
+        case 16:
+        {
+            Uint8 * data = ((Uint8 *)dest->data) + dest->pitch * region->y + region->x * 2;
+            l = region->x2 - region->x + 1;
+            for (y = region->y; y <= region->y2; y++) {
+                Uint16 * ptr = (Uint16 *)data ;
+                for (n = 0; n < l; n++) *ptr++ = 0 ;
+                data += dest->pitch ;
+            }
+            break ;
+        }
+
+        case 1:
+        {
+            Uint8 * data = ((Uint8 *)dest->data) + region->x / 8 ;
+            l = (region->x2 - region->x - 1) / 8 + 1 ;
+            for (y = region->y; y <= region->y2; y++) {
+                /* Esta debe ser cambiada, por bits */
+                memset (data, 0, l) ;
+                data += dest->pitch ;
+            }
+            break ;
+        }
+    }
+
+}
+
+/*
  *  FUNCTION : gr_vline
  *
  *  Draw a vertical rectangle
@@ -342,8 +440,11 @@
 void gr_vline (GRAPH * dest, REGION * clip, int x, int y, int h)
 {
     REGION base_clip ;
+    int old_stipple = drawing_stipple;
 
     if (!dest) dest = scrbitmap ;
+    dest->modified = 1 ;
+
     if (!clip)
     {
         clip = &base_clip ;
@@ -353,15 +454,13 @@
         clip->y2 = dest->height-1 ;
     }
 
-    dest->modified = 1 ;
-
-    if (h < 0) h = -h, y -= h-1 ;
+    if (h < 0) h = -h, y -= (h - 1) ;
     if (x < clip->x || x > clip->x2) return ;
 
     if (y < clip->y) h += y-clip->y, y = clip->y ;
-    if (y+h > clip->y2) h = clip->y2+1-y ;
+    if (y + h > clip->y2) h = clip->y2 - y + 1 ;
 
-    if (h < 1) return ;
+    if (h < 0) return ;
 
     if (dest->depth == 8)
     {
@@ -371,9 +470,8 @@
         {
             while (h--)
             {
-                if (drawing_stipple & 1)
-                    _Pixel8 (ptr, syscolor8) ;
-                drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+                if (drawing_stipple & 1) _Pixel8 (ptr, syscolor8) ;
+                drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
                 ptr += dest->pitch ;
             }
         }
@@ -389,15 +487,15 @@
     else if (dest->depth == 16)
     {
         Uint16 * ptr = dest->data ;
-        ptr += dest->pitch * y / 2 + x ;
+        int inc = dest->pitch / 2 ;
+        ptr += inc * y + x ;
         if (drawing_stipple != 0xFFFFFFFF)
         {
             while (h--)
             {
-                if (drawing_stipple & 1)
-                    _Pixel16 (ptr, syscolor16, syscolor16_alpha) ;
-                drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
-                ptr += dest->pitch / 2 ;
+                if (drawing_stipple & 1) _Pixel16 (ptr, syscolor16, syscolor16_alpha) ;
+                drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
+                ptr += inc ;
             }
         }
         else
@@ -405,10 +503,43 @@
             while (h--)
             {
                 _Pixel16 (ptr, syscolor16, syscolor16_alpha) ;
-                ptr += dest->pitch / 2 ;
+                ptr += inc ;
+            }
+        }
+    }
+    else if (dest->depth == 1)
+    {
+        Uint8 * ptr = dest->data;
+        int mask ;
+        ptr += dest->pitch * y + x / 8;
+        mask = (1 << (7-(x & 7)));
+        if (drawing_stipple != 0xFFFFFFFF)
+        {
+            while (h--)
+            {
+                if (drawing_stipple & 1) {
+                    if (!syscolor8)
+                        *ptr &= ~mask;
+                    else
+                        *ptr |= mask;
+                }
+                drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
+                ptr += dest->pitch ;
+            }
+        } else {
+            while (h--)
+            {
+                if (!syscolor8)
+                    *ptr &= ~mask;
+                else
+                    *ptr |= mask;
+                ptr += dest->pitch ;
             }
         }
     }
+
+    drawing_stipple = old_stipple;
+
 }
 
 /*
@@ -430,6 +561,7 @@
 void gr_hline (GRAPH * dest, REGION * clip, int x, int y, int w)
 {
     REGION base_clip ;
+    int old_stipple = drawing_stipple;
 
     if (!dest) dest = scrbitmap ;
     if (!clip)
@@ -443,13 +575,13 @@
 
     dest->modified = 1 ;
 
-    if (w < 0) w = -w, x -= w-1 ;
+    if (w < 0) w = -w, x -= (w - 1) ;
     if (y < clip->y || y > clip->y2) return ;
 
     if (x < clip->x) w += x-clip->x, x = clip->x ;
-    if (x+w > clip->x2) w = clip->x2+1-x ;
+    if (x + w > clip->x2) w = clip->x2 - x + 1 ;
 
-    if (w < 1) return ;
+    if (w < 0) return ;
 
     if (dest->depth == 8)
     {
@@ -475,6 +607,26 @@
         int mask ;
         ptr += dest->pitch * y + x/8;
         mask = (1 << (7-(x & 7)));
+
+        if (drawing_stipple != 0xFFFFFFFF)
+        {
+            while (w--)
+            {
+                if (drawing_stipple & 1) {
+                    if (!syscolor8)
+                        *ptr &= ~mask;
+                    else
+                        *ptr |= mask;
+                }
+                mask >>= 1;
+                if (!mask)
+                {
+                    mask = 0x80;
+                    ptr++;
+                }
+                drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
+            }
+        } else {
         while (w--)
         {
             if (!syscolor8)
@@ -491,6 +643,9 @@
     }
 }
 
+    drawing_stipple = old_stipple;
+}
+
 /*
  *  FUNCTION : gr_box
  *
@@ -513,6 +668,8 @@
     REGION base_clip ;
 
     if (!dest) dest = scrbitmap ;
+    dest->modified = 1 ;
+
     if (!clip)
     {
         clip = &base_clip ;
@@ -521,18 +678,29 @@
         clip->x2 = dest->width-1 ;
         clip->y2 = dest->height-1 ;
     }
+    else
+    {
+        base_clip = *clip ;
+        clip = &base_clip ;
+        clip->x = MAX(MIN(clip->x, clip->x2), 0) ;
+        clip->y = MAX(MIN(clip->y, clip->y2), 0) ;
+        clip->x2 = MIN(MAX(clip->x, clip->x2), dest->width - 1) ;
+        clip->y2 = MIN(MAX(clip->y, clip->y2), dest->height - 1) ;
+    }
 
-    dest->modified = 1 ;
-
-    if (w < 0) w = -w, x -= w ;
-    if (h < 0) h = -h, y -= h ;
+    if (w < 0) w = -w, x -= (w - 1) ;
+    if (h < 0) h = -h, y -= (h - 1) ;
 
     if (x < clip->x) w += x-clip->x, x = clip->x ;
     if (y < clip->y) h += y-clip->y, y = clip->y ;
-    if (x+w > clip->x2) w = clip->x2+1-x ;
-    if (y+h > clip->y2) h = clip->y2+1-y ;
 
-    if (w < 1 || h < 1) return ;
+    if (x + w > clip->x2) w = clip->x2 - x + 1 ;
+    if (y + h > clip->y2) h = clip->y2 - y + 1 ;
+
+    if (w < 0 || h < 0) return ;
+
+    if (!w) w++;
+    if (!h) h++;
 
     if (dest->depth == 8)
     {
@@ -547,17 +715,23 @@
     else if (dest->depth == 16)
     {
         Uint16 * ptr = dest->data ;
-        ptr += dest->pitch * y / 2 + x ;
+        int inc = dest->pitch / 2 ;
+        ptr += dest->pitch / 2 * y + x ;
         while (h--)
         {
             _HLine16_nostipple (ptr, w) ;
-            ptr += dest->pitch/2 ;
+            ptr += inc ;
         }
     }
     else if (dest->depth == 1)
     {
+        int old_stipple = drawing_stipple;
+        drawing_stipple = 0xFFFFFFFF;
+
         while (h--)
             gr_hline (dest, clip, x, y+h, w);
+
+        drawing_stipple = old_stipple;
     }
 }
 
@@ -582,18 +756,17 @@
 {
     int stipple = drawing_stipple;
 
-    if (w < 0) w = -w, x -= w ;
-    if (h < 0) h = -h, y -= h ;
+    dest->modified = 1;
+
+    if (w < 0) w = -w, x -= (w - 1);
+    if (h < 0) h = -h, y -= (h - 1);
+
+    if (w)                 gr_hline (dest, clip, x        , y        , w     ) ;
+    if ((w - 1) && h && w) gr_vline (dest, clip, x + w - 1, y        , h     ) ;
+    if ((h - 1) && w && h) gr_hline (dest, clip, x + w - 1, y + h - 1, -w    ) ;
+    if (h)                 gr_vline (dest, clip, x        , y + h - 1, -h    ) ;
 
-    gr_hline (dest, clip, x, y, w) ;
-    if (h > 1)
-        gr_vline (dest, clip, x+w-1, y, h) ;
     drawing_stipple = stipple;
-    if (w > 1 && h > 1)
-    {
-        gr_vline (dest, clip, x, y, h) ;
-        gr_hline (dest, clip, x, y+h-1, w) ;
-    }
 }
 
 /*
@@ -615,8 +788,9 @@
 void gr_circle (GRAPH * dest, REGION * clip, int x, int y, int r)
 {
     int cx = 0, cy = r ;
-    int lcx = -1, lcy = -1;
+    int lcy = -1;
     int df = 1-r, de = 3, dse = -2*r + 5 ;
+    int old_stipple = drawing_stipple;
     REGION base_clip ;
     int color = 0;
 
@@ -631,7 +805,8 @@
     }
 
     dest->modified = 1 ;
-    if (dest->depth == 8) {
+
+    if (dest->depth == 8 || dest->depth == 1) {
         color = syscolor8;
     } else if (dest->depth == 16) {
         color = syscolor16;
@@ -639,36 +814,34 @@
 
     do {
         if (drawing_stipple & 1) {
-
-            if (lcx != cx) {
                 gr_put_pixelc (dest, clip, x-cx, y-cy, color) ;
-                if (x-cx!=x+cx)
-                    gr_put_pixelc (dest, clip, x+cx, y-cy, color) ;
-                if (y-cy != y+cy) {
+            if (cx) gr_put_pixelc (dest, clip, x+cx, y-cy, color) ;
+
+            if (cy) {
                     gr_put_pixelc (dest, clip, x-cx, y+cy, color) ;
-                    if (x-cx!=x+cx)
-                        gr_put_pixelc (dest, clip, x+cx, y+cy, color) ;
+                if (cx) gr_put_pixelc (dest, clip, x+cx, y+cy, color) ;
                 }
-                if (y-cx != y-cy) {
+
+            if (cx != cy) {
                     gr_put_pixelc (dest, clip, x-cy, y-cx, color) ;
-                    if (x-cy!=x+cy)
-                        gr_put_pixelc (dest, clip, x+cy, y-cx, color) ;
+                if (cy) gr_put_pixelc (dest, clip, x+cy, y-cx, color) ;
                 }
-                if (y-cx != y+cx && y+cy != y+cx) {
+
+            if (cx && cy != cx) {
                     gr_put_pixelc (dest, clip, x-cy, y+cx, color) ;
-                    if (x-cy!=x+cy)
-                        gr_put_pixelc (dest, clip, x+cy, y+cx, color) ;
-                }
+                if (cy) gr_put_pixelc (dest, clip, x+cy, y+cx, color) ;
             }
         }
-        drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+        drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
 
-        lcx = cx; lcy = cy;
+        lcy = cy;
         cx++ ;
         if (df < 0) df += de,  de += 2, dse += 2 ;
         else        df += dse, de += 2, dse += 4, cy-- ;
     } while (cx <= cy) ;
 
+    drawing_stipple = old_stipple;
+
 }
 
 
@@ -691,31 +864,29 @@
 void gr_fcircle (GRAPH * dest, REGION * clip, int x, int y, int r)
 {
     int cx = 0, cy = r ;
-    int lcx = -1, lcy = -1;
     int df = 1-r, de = 3, dse = -2*r + 5 ;
     int old_stipple = drawing_stipple;
     drawing_stipple = 0xFFFFFFFF;
 
+    dest->modified = 1;
     do
     {
-        if (lcy != cy) {
-            gr_hline (dest, clip, x-cx, y-cy, 2*cx) ;
-            if (y-cy != y+cy)
-                gr_hline (dest, clip, x-cx, y+cy, 2*cx) ;
-        }
-        if (lcx != cx) {
-            if (y-cx != y-cy)
-                gr_hline (dest, clip, x-cy, y-cx, 2*cy) ;
-            if (y-cx != y+cx && y+cy != y+cx)
-                gr_hline (dest, clip, x-cy, y+cx, 2*cy) ;
+        if (cx != cy) {
+            gr_hline (dest, clip, x-cy, y-cx, 2*cy+1) ;
+            if (cx) gr_hline (dest, clip, x-cy, y+cx, 2*cy+1) ;
+        }
+        if (df < 0) {
+            df += de,  de += 2, dse += 2 ;
+        } else {
+            df += dse, de += 2, dse += 4;
+            gr_hline (dest, clip, x-cx, y-cy, 2*cx+1) ;
+            if (cy) gr_hline (dest, clip, x-cx, y+cy, 2*cx+1) ;
+            cy-- ;
         }
-
-        lcx = cx; lcy = cy;
         cx++ ;
-        if (df < 0) df += de,  de += 2, dse += 2 ;
-        else        df += dse, de += 2, dse += 4, cy-- ;
     }
     while (cx <= cy) ;
+
     drawing_stipple = old_stipple;
 }
 
@@ -740,6 +911,7 @@
     int n, m, hinc, vinc ;
     int i1, i2, dd ;
     REGION base_clip ;
+    int old_stipple = drawing_stipple;
 
     if (!w) {
         gr_vline (dest, clip, x, y, h) ;
@@ -764,42 +936,47 @@
 
     /* Clipping de la línea - INCORRECTO pero funcional */
 
+/* TODO: SE NECESITA CORREGIR CLIPPING EN LINE */
+#if 0
     if (x < clip->x) /* izquierda */
     {
-        if (x+w < clip->x) return;
+        if ((x + w) < clip->x) return ;
         n = clip->x - x ;
         m = w ? n*h/ABS(w) : 0;
         x += n, w -= n, y += m, h -= m ;
         if (w == 0) return;
     }
-    if (x+w < clip->x) /* w < 0 */
+    if ((x + w) < clip->x) /* w < 0 */
     {
-        n = clip->x - (x+w) ; m = w ? n*h/ABS(w) : 0 ;
+        n = clip->x - (x + w) ;
+        m = w ? n * h / ABS(w) : 0 ;
         w += n, h -= m ;
         if (w == 0) return;
     }
     if (y < clip->y) /* arriba */
     {
-        if (y+h < clip->y) return;
-        m = clip->y - y ; n = h ? m*w/ABS(h) : 0 ;
+        if ((y + h) < clip->y) return ;
+        m = clip->y - y ;
+        n = h ? m * w / ABS(h) : 0 ;
         x += n, w -= n, y += m, h -= m ;
         if (h == 0) return;
     }
-    if (y+h < clip->y) /* h < 0 */
+    if ((y + h) < clip->y) /* h < 0 */
     {
-        m = clip->y - (y+h) ; n = h ? m*w/ABS(h) : 0;
+        m = clip->y - (y + h) ;
+        n = h ? m * w / ABS(h) : 0 ;
         w -= n, h += m ;
         if (h == 0) return;
     }
     if (x > clip->x2) /* derecha */
     {
-        if (x+w > clip->x2) return;
+        if ((x + w) > clip->x2) return ;
         n = x - clip->x2 ;
         m = w ? n*h/ABS(w) : 0;
         x -= n, w += n, y += m, h -= m ;
         if (w == 0) return;
     }
-    if (x+w > clip->x2) /* w > 0 */
+    if ((x + w) > clip->x2) /* w > 0 */
     {
         n = (x+w) - clip->x2 ;
         m = w ? n*h/ABS(w) : 0;
@@ -808,22 +985,23 @@
     }
     if (y > clip->y2) /* abajo */
     {
-        if (y+h > clip->y2) return;
+        if ((y + h) > clip->y2) return ;
         m = y - clip->y2 ;
         n = m*w/ABS(h);
         x += n, w -= n, y -= m, h += m ;
         if (h == 0) return;
     }
-    if (y+h > clip->y2) /* h > 0 */
+
+    if ((y + h) > clip->y2) /* h > 0 */
     {
         m = (y+h) - clip->y2 ;
         n = h ? m*w/ABS(h) : 0;
         w -= n, h -= m ;
         if (h == 0) return;
     }
-
-    hinc = w > 0 ? 1:-1 ;
-    vinc = h > 0 ? dest->pitch:-(int)dest->pitch ;
+#endif
+    hinc = (w > 0) ? 1 : -1 ;
+    vinc = (h > 0) ? dest->pitch : -(int)dest->pitch ;
     if (dest->depth == 16) vinc /= 2;
 
     /* Aquí va una implementación deprisa y corriendo de Bresenham */
@@ -831,17 +1009,10 @@
     w = ABS(w) ;
     h = ABS(h) ;
 
-    if (w > h)
-    {
-        i1 = 2 * h ;
-        dd = i1 - w ;
-        i2 = dd - w ;
-    }
-    else
-    {
-        i1 = 2 * w ;
-        dd = i1 - h ;
-        i2 = dd - h ;
+    if (w > h) {
+        i1 = 2 * h ; dd = i1 - w ; i2 = dd - w ;
+    } else {
+        i1 = 2 * w ; dd = i1 - h ; i2 = dd - h ;
     }
 
     if (dest->depth == 8)
@@ -850,17 +1021,15 @@
 
         if (w > h) while (w--)
         {
-            if (drawing_stipple & 1)
-                _Pixel8(ptr, syscolor8) ;
-            drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+            if (drawing_stipple & 1) _Pixel8(ptr, syscolor8) ;
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
             if (dd >= 0) ptr += hinc+vinc, dd += i2 ;
             else         ptr += hinc,      dd += i1 ;
         }
         else while (h--)
         {
-            if (drawing_stipple & 1)
-                _Pixel8(ptr, syscolor8 ) ;
-            drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+            if (drawing_stipple & 1) _Pixel8(ptr, syscolor8) ;
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
             if (dd >= 0) ptr += vinc+hinc, dd += i2 ;
             else         ptr += vinc,      dd += i1 ;
         }
@@ -872,18 +1041,45 @@
         if (w > h) while (w--)
         {
             if (drawing_stipple & 1) _Pixel16(ptr, syscolor16, syscolor16_alpha) ;
-            drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
             if (dd >= 0) ptr += hinc+vinc, dd += i2 ;
             else         ptr += hinc,      dd += i1 ;
         }
         else while (h--)
         {
             if (drawing_stipple & 1) _Pixel16(ptr, syscolor16, syscolor16_alpha) ;
-            drawing_stipple = ((drawing_stipple << 1) | (drawing_stipple & 0x80000000 ? 1:0));
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
             if (dd >= 0) ptr += vinc+hinc, dd += i2 ;
             else         ptr += vinc,      dd += i1 ;
         }
     }
+    else if(dest->depth == 1)
+    {
+        Uint8 * ptr = dest->data + dest->pitch * y + x / 8;
+        Uint8 mask, rmask ;
+        mask = (1 << (7-(x & 7)));
+
+        if (hinc < 0) rmask = 0x01 ; else rmask = 0x80 ;
+
+        if (w > h) while (w--)
+        {
+            if (drawing_stipple & 1) if (!syscolor8) *ptr &= ~mask; else *ptr |= mask;
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
+            if (dd >= 0) ptr += vinc, dd += i2 ;
+            else                      dd += i1 ;
+            if (hinc < 0) mask <<= 1; else mask >>= 1; if (!mask) mask = rmask, ptr += hinc ;
+        }
+        else while (h--)
+        {
+            if (drawing_stipple & 1) if (!syscolor8) *ptr &= ~mask ; else *ptr |= mask;
+            drawing_stipple = ((drawing_stipple << 1) | ((drawing_stipple & 0x80000000) ? 1:0));
+            if (dd >= 0) { ptr += vinc, dd += i2 ; if (hinc < 0) mask <<= 1; else mask >>= 1; if (!mask) mask = rmask, ptr += hinc ; }
+            else           ptr += vinc, dd += i1 ;
+        }
+    }
+
+    drawing_stipple = old_stipple;
+
 }
 
 /*
@@ -929,14 +1125,13 @@
     int i;
     int n = 1;
 
+    dest->modified = 1;
+
     /* Compute number of iterations */
 
-    if(level < 1)
-        level=1;
-    if(level >= 15)
-        level=15;
-    while (level-- > 0)
-        n*= 2;
+    if(level < 1) level=1;
+    if(level >= 15) level=15;
+    while (level-- > 0) n*= 2;
     delta = 1.0f / (float)n;
 
     /* Compute finite differences */
@@ -993,6 +1188,7 @@
     switch (dr->type)
     {
         case DRAWOBJ_CIRCLE:
+        case DRAWOBJ_FCIRCLE:
             newclip.x  = dr->x1-dr->x2;
             newclip.y  = dr->y1-dr->x2;
             newclip.x2 = dr->x1+dr->x2;
@@ -1034,7 +1230,7 @@
  *
  */
 
-static void draw_object (DRAWING_OBJECT * dr, REGION * clip)
+void draw_object (DRAWING_OBJECT * dr, REGION * clip)
 {
     int b8 = syscolor8;
     int b16 = syscolor16;
@@ -1042,6 +1238,8 @@
     syscolor8 = dr->color8;
     syscolor16 = dr->color16;
 
+    if (drawing_alpha!=255) gr_setalpha(drawing_alpha);
+
     switch (dr->type)
     {
         case DRAWOBJ_LINE:
@@ -1165,8 +1363,7 @@
 
             dr->x1 += incx;
             dr->y1 += incy;
-            if (dr->type == DRAWOBJ_CIRCLE || dr->type == DRAWOBJ_FCIRCLE)
-                return;
+            if (dr->type == DRAWOBJ_CIRCLE || dr->type == DRAWOBJ_FCIRCLE) return;
             dr->x2 += incx;
             dr->y2 += incy;
             dr->x3 += incx;
@@ -1250,7 +1447,6 @@
         syscolor16 = c ;
     }
 
-    if (drawing_alpha != 255)
-        syscolor16_alpha = gr_alpha16(drawing_alpha)[syscolor16];
+    if (drawing_alpha != 255) syscolor16_alpha = gr_alpha16(drawing_alpha)[syscolor16];
 }
 
