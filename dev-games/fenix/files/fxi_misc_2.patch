Index: fxi/src/g_mode7.c
===================================================================
--- a/fxi/src/g_mode7.c	2007-08-28 14:38:26.000000000 +0200
+++ b/fxi/src/g_mode7.c	2007-08-28 14:41:14.000000000 +0200
@@ -71,8 +71,7 @@
 
 void gr_mode7_bbox (int n, REGION * r)
 {
-    if (n >= 0 && n <= 9)
-        *r = *current_mode7[n].region;
+    if (n >= 0 && n <= 9) *r = *current_mode7[n].region;
 }
 
 int gr_mode7_active (int n)
@@ -253,11 +252,8 @@
 
         //if (point_z >= camera_z) break ;
 
-        lines[y].right_bmp_x = fdiv( fmul((point_x - camera_x), -camera_z),
-                           (point_z - camera_z) ) + camera_x ;
-
-        lines[y].right_bmp_y = fdiv( fmul((point_y - camera_y), -camera_z),
-                           (point_z - camera_z) ) + camera_y ;
+        lines[y].right_bmp_x = fdiv(fmul((point_x - camera_x), -camera_z), (point_z - camera_z)) + camera_x ;
+        lines[y].right_bmp_y = fdiv(fmul((point_y - camera_y), -camera_z), (point_z - camera_z)) + camera_y ;
 
         /* Averigua el incremento necesario para cada paso de la línea */
 
@@ -275,27 +271,21 @@
     if (outdoor)
     {
         outdoor_hmask = outdoor_vmask = 0xFFFFFFFF ;
-        while (~(outdoor_hmask << 1) < (int)outdoor->width-1)
-            outdoor_hmask <<= 1 ;
-        while (~(outdoor_vmask << 1) < (int)outdoor->height-1)
-            outdoor_vmask <<= 1 ;
+        while (~(outdoor_hmask << 1) < (int)outdoor->width-1) outdoor_hmask <<= 1 ;
+        while (~(outdoor_vmask << 1) < (int)outdoor->height-1) outdoor_vmask <<= 1 ;
         outdoor_hmask = ~outdoor_hmask ;
         outdoor_vmask = ~outdoor_vmask ;
     }
 
-    jump = camera_z < 0 ? -1 : 1 ;
-    ptr += (jump > 0 ? dest->pitch : -(int)dest->pitch) ;
+    jump = (camera_z < 0) ? -1 : 1 ;
+    ptr += ((jump > 0) ? dest->pitch : -(int)dest->pitch) ;
     y   += jump ;
 
-    if (dest->depth != 8)
-        gr_error ("Profundidad de color no soportada\n(mode7, dest)") ;
-    if (outdoor && outdoor->depth != 8)
-        gr_error ("Profundidad de color no soportada\n(mode7, out)") ;
-    if (indoor && indoor->depth != 8)
-        gr_error ("Profundidad de color no soportada\n(mode7, in)") ;
+    if (dest->depth != 8) gr_error ("Profundidad de color no soportada\n(mode7, dest)") ;
+    if (outdoor && outdoor->depth != 8) gr_error ("Profundidad de color no soportada\n(mode7, out)") ;
+    if (indoor && indoor->depth != 8) gr_error ("Profundidad de color no soportada\n(mode7, in)") ;
 
-    if ((dat->flags & B_TRANSLUCENT) && !trans_table_updated)
-        gr_make_trans_table() ;
+    if ((dat->flags & B_TRANSLUCENT) && !trans_table_updated) gr_make_trans_table() ;
 
     if (!(dat->flags & B_TRANSLUCENT))
     for ( ; y < height && y >= 0 ; y += jump)
@@ -341,7 +331,7 @@
             bmp_y += vinc ;
         }
 
-        ptr = baseline + (jump > 0 ? dest->pitch : -(int)dest->pitch) ;
+            ptr = baseline + ((jump > 0) ? dest->pitch : -(int)dest->pitch) ;
     }
     else
     for ( ; y < height && y >= 0 ; y += jump)
@@ -385,7 +375,7 @@
             bmp_y += vinc ;
         }
 
-        ptr = baseline + (jump > 0 ? dest->pitch : -(int)dest->pitch) ;
+                ptr = baseline + ((jump > 0) ? dest->pitch : -(int)dest->pitch) ;
     }
 
     /* Crea una lista ordenada de instancias a dibujar */
Index: fxi/src/g_pal.c
===================================================================
--- a/fxi/src/g_pal.c	2007-08-28 14:39:57.000000000 +0200
+++ b/fxi/src/g_pal.c	2007-08-28 14:41:14.000000000 +0200
@@ -54,10 +54,15 @@
 
 extern GRAPH * gr_read_png (const char * filename) ;
 
+static unsigned char colors[256][3] ;
+
+PALETTE * first_palette = NULL ;
+
 SDL_Color  palette[256] ;
-SDL_Color vpalette[256] ;
 
+SDL_Color vpalette[256] ;
 Uint16     colorequiv[256] ;    /* Equivalencia paleta -> pantalla   */
+
 Uint16     colorghost[65536] ;  /* Deja un color a 50% de intensidad */
 
 int palette_loaded = 0 ;
@@ -65,6 +70,7 @@
 
 static int fade_inc = 0 ;
 int        fade_on = 0 ;
+int        fade_set = 0 ;
 int        fade_step = 64 ;
 SDL_Color  fade_from ;
 SDL_Color  fade_to ;
@@ -149,6 +155,161 @@
       252, 52,252, 252,108,252, 252,164,252, 252,220,252
 } ;
 
+void pal_refresh(PALETTE * pal) {
+    PALETTE * p ;
+    int n;
+
+    if (enable_16bits) {
+        if (!pal)
+            p = first_palette;
+        else
+            p = pal ;
+
+        while (p) {
+            for (n = 0 ; n < 256 ; n++)
+                p->colorequiv[n] = SDL_MapRGB (screen->format, p->rgb[n].r, p->rgb[n].g, p->rgb[n].b);
+            p = p->next;
+            if (pal) break;
+        }
+    }
+}
+
+
+void pal_use(PALETTE * pal)
+{
+    if (pal) pal->use++;
+}
+
+int pal_discard(PALETTE * pal)
+{
+    if (!pal) return 0;
+    if (pal->use) pal->use--;
+    return pal->use;
+}
+
+PALETTE * pal_new(PALETTE * basepal)
+{
+    PALETTE * pal = malloc(sizeof(PALETTE));
+
+    if (!pal) return NULL ;
+
+    if (basepal) {
+        memmove(pal->rgb, basepal->rgb, sizeof(pal->rgb)) ;
+        memmove(pal->colorequiv, basepal->colorequiv, sizeof(pal->colorequiv)) ;
+    } else {
+        /* Default */
+        memmove(pal->rgb, palette, sizeof(pal->rgb)) ;
+        if (enable_16bits) {
+            int n;
+            for (n = 0 ; n < 256 ; n++)
+                pal->colorequiv[n] = SDL_MapRGB (screen->format, pal->rgb[n].r, pal->rgb[n].g, pal->rgb[n].b) ;
+        }
+    }
+
+    pal->use        = 1 ;
+    pal->next       = first_palette ;
+    pal->prev       = NULL ;
+    first_palette   = pal ;
+
+    return pal;
+}
+
+PALETTE * pal_new2(unsigned char * datapal)
+{
+    PALETTE * pal = malloc(sizeof(PALETTE));
+    int n;
+
+    if (!pal) return NULL ;
+
+    if (datapal) {
+		for (n = 0 ; n < 256 ; n++)
+		{
+			pal->rgb[n].r = datapal[3*n    ];
+			pal->rgb[n].g = datapal[3*n + 1];
+			pal->rgb[n].b = datapal[3*n + 2];
+		}
+    } else {
+        /* Default */
+        memmove(pal->rgb, palette, sizeof(pal->rgb)) ;
+    }
+
+    if (enable_16bits) {
+        for (n = 0 ; n < 256 ; n++)
+            pal->colorequiv[n] = SDL_MapRGB (screen->format, pal->rgb[n].r, pal->rgb[n].g, pal->rgb[n].b) ;
+    }
+
+    pal->use        = 1 ;
+    pal->next       = first_palette ;
+    pal->prev       = NULL ;
+    first_palette   = pal ;
+
+    return pal;
+}
+
+void pal_destroy(PALETTE * pal)
+{
+    if (!pal) return ;
+
+    if (pal_discard(pal)) return ;
+
+    if (pal->next) pal->next->prev = pal->prev ;
+    if (pal->prev) pal->prev->next = pal->next ;
+
+    if (pal == first_palette) first_palette = pal->next ;
+
+    free (pal);
+}
+
+int pal_get (PALETTE * spal, int color, int num, Uint8 * pal)
+{
+    if (!spal || num < 1 || color < 0 || color > 255) return 0;
+    if (color+num >= 256) num = 256-color ;
+
+    while (num--)
+    {
+        *pal++ = spal->rgb[color  ].r ;
+        *pal++ = spal->rgb[color  ].g ;
+        *pal++ = spal->rgb[color++].b ;
+    }
+    return num;
+}
+
+int pal_set (PALETTE * spal, int color, int num, Uint8 * pal)
+{
+    if (!spal || num < 1 || color < 0 || color > 255) return 0;
+    if (color+num >= 256) num = 256-color ;
+
+    while (num--)
+    {
+        spal->rgb[color  ].r = *pal++ ;
+        spal->rgb[color  ].g = *pal++ ;
+        spal->rgb[color++].b = *pal++ ;
+    }
+    return num;
+}
+
+int pal_map_assign (int libid, int mapcode, PALETTE * palid)
+{
+    GRAPH * bmp = bitmap_get (libid, mapcode) ;
+    PALETTE * oldpal ;
+    if (!bmp || bmp->depth != 8 || !palid) return 0 ;
+    oldpal = bmp->palette ;
+    bmp->palette = palid ;
+    pal_use(bmp->palette) ;
+    if (oldpal) pal_destroy(oldpal) ;
+    return 1 ;
+}
+
+int pal_map_remove (int libid, int mapcode)
+{
+    GRAPH * bmp = bitmap_get (libid, mapcode) ;
+    if (!bmp || bmp->depth != 8) return 0 ;
+    if (bmp->palette) pal_destroy (bmp->palette) ;
+    bmp->palette = NULL ;
+    return 1 ;
+}
+
+/* ---------------------------- */
 
 static void activate_vpalette()
 {
@@ -216,21 +377,24 @@
 
 void gr_fade_init (int r, int g, int b, int speed)
 {
+    if (fade_pos.r == r && fade_pos.g == g && fade_pos.b == b) return;
+
     fade_inc  = speed;
     fade_step = 0;
     fade_on   = 1 ;
     fade_from = fade_pos;
-    fade_to.r = r > 200 ? 200 : r ;
-    fade_to.g = g > 200 ? 200 : g ;
-    fade_to.b = b > 200 ? 200 : b ;
+    fade_to.r = (r > 200) ? 200 : r ;
+    fade_to.g = (g > 200) ? 200 : g ;
+    fade_to.b = (b > 200) ? 200 : b ;
 
     GLODWORD(FADING) = 1 ;
 }
 
 void gr_fade_step()
 {
-    if (fade_on != 0)
+    if (fade_on)
     {
+        fade_set = 1 ;
         GLODWORD(FADING) = 1 ;
 
         fade_step += fade_inc ;
@@ -255,8 +419,16 @@
             (fade_pos.r == 100 && fade_pos.g == 100 && fade_pos.b == 100))
         {
             GLODWORD(FADING) = 0 ;
+            fade_step = 100 ;
             fade_on = 0;
         }
+    }
+
+    if (fade_set)
+    {
+        if (!fade_on && fade_to.r == 100 && fade_to.g == 100 && fade_to.b == 100) {
+            fade_set = 0;
+        }
 
         activate_vpalette() ;
 
@@ -265,15 +437,15 @@
             gr_fade16 (scrbitmap,  fade_pos.r, fade_pos.g, fade_pos.b);
         }
     }
+
 }
 
+#if 0
 int gr_read_pal (file * fp)
 {
-    unsigned char colors[256][3] ;
     int i ;
 
-    if (!file_read (fp, colors, 3 * 256))
-        return 0 ;
+    if (!file_read (fp, colors, 3 * 256)) return 0 ;
 
     /* Ignora definiciones de gama */
     file_seek (fp, 576, SEEK_CUR) ;
@@ -283,16 +455,53 @@
         palette[i].r = colors[i][0] << 2 ;
         palette[i].g = colors[i][1] << 2 ;
         palette[i].b = colors[i][2] << 2 ;
+    }
+
+    palette_loaded = 1 ;
+    palette_changed = 1 ;
+
+    return 1 ;
+    }
+#endif
 
+PALETTE * gr_read_pal (file * fp)
+{
+    int i ;
+    PALETTE * pal;
 
+    if (!file_read (fp, colors, 3 * 256)) return NULL ;
+
+    for (i = 0 ; i < 256 ; i++)
+    {
+        colors[i][0] = colors[i][0] << 2 ;
+        colors[i][1] = colors[i][1] << 2 ;
+        colors[i][2] = colors[i][2] << 2 ;
+        if (!palette_loaded) {
+            palette[i].r = colors[i][0] ;
+            palette[i].g = colors[i][1] ;
+            palette[i].b = colors[i][2] ;
+        }
     }
 
+    pal = pal_new2(colors);
+
     palette_loaded = 1 ;
     palette_changed = 1 ;
 
-    return 1 ;
+    return pal ;
+}
+
+PALETTE * gr_read_pal_with_gamma (file * fp)
+{
+    PALETTE * pal = gr_read_pal (fp);
+
+    /* Ignora definiciones de gama */
+    if (pal) file_seek (fp, 576, SEEK_CUR) ;
+
+    return pal ;
 }
 
+
 /*
  *  FUNCTION : gr_save_pal
  *
@@ -309,7 +518,6 @@
 {
     file * fp = file_open (filename, "wb");
     char header[8] = "pal\x1A\x0D\x0A";
-    unsigned char colors[256][3] ;
     int i;
 
     if (!fp)
@@ -341,18 +549,18 @@
     int r = 0 ;
     int i = 0 ;
 
-    if (!fp) return -1 ;
+    if (!fp) return 0 ;
     file_read (fp, header, 8) ;
     if (strcmp (header, "map\x1A\x0D\x0A") == 0)
     {
         file_seek (fp, 48, SEEK_SET) ;
-        r = gr_read_pal (fp) ;
+        r = gr_read_pal_with_gamma (fp) ;
     }
     else if (strcmp (header, "fpg\x1A\x0D\x0A") == 0 ||
         strcmp (header, "fnt\x1A\x0D\x0A") == 0 ||
         strcmp (header, "pal\x1A\x0D\x0A") == 0)
     {
-        r = gr_read_pal (fp) ;
+        r = gr_read_pal_with_gamma (fp) ;
     }
     else if (memcmp (header, "\x89PNG", 4) == 0)
     {
@@ -361,8 +569,11 @@
         file_close (fp);
         palette_loaded = 0;
         graph = gr_read_png(filename);
-        if (graph) bitmap_destroy(graph);
-        return 1;
+        if (graph) {
+            r = (int) graph->palette;
+            pal_use(graph->palette);
+            bitmap_destroy(graph);
+        }
     }
     else {
         // Soporte para FGC
@@ -374,7 +585,7 @@
             {
                 fgc_error = _("FGC file corrupt or truncated");
                 file_close(fp);
-                return -1;
+                return 0;
             }
             ARRANGE_DWORD(&fgcHeader.version);
             ARRANGE_DWORD(&fgcHeader.depth);
@@ -383,43 +594,42 @@
 
             if (fgcHeader.depth == 8) {
 
-                static unsigned char color_palette[256][3];
-
                 file_seek (fp, fgcHeader.palette, SEEK_SET) ;
+                r = gr_read_pal (fp);
 
 
-                if (file_read(fp, color_palette, 768) != 768) {
+/*
+                if (file_read(fp, colors, 768) != 768) {
                     fgc_error = _("PALETTE - FGC file is truncated");
                     file_close(fp);
-                    return -1;
+                    return 0;
                 }
 
                 for (i = 0 ; i < 256 ; i++) {
-                    palette[i].r = color_palette[i][0];
-                    palette[i].g = color_palette[i][1];
-                    palette[i].b = color_palette[i][2];
+                    palette[i].r = colors[i][0];
+                    palette[i].g = colors[i][1];
+                    palette[i].b = colors[i][2];
 
                 }
                 palette_loaded = 1 ;
                 palette_changed = 1 ;
                 r = 1 ;
+*/
             } else {
                 fgc_error = _("FGC file does not contain information about the colour palette");
                 file_close(fp);
-                return -1;
+                return 0;
             }
         }
         else if (strcmp (header, FBM_MAGIC) == 0) {
             // Soporte para FBM
 
-            static unsigned char color_palette[256][3];
-
             file_seek (fp, 0, SEEK_SET) ;
 
             if (file_read(fp,&fbmHeader,sizeof(FBM_FILE_HEADER)!=sizeof(FBM_FILE_HEADER))) {
                 fbm_error = _("FBM file corrupt or truncated");
                 file_close(fp);
-                return -1;
+                return 0;
             }
 
             ARRANGE_DWORD(&fbmHeader.depth);
@@ -427,27 +637,30 @@
             if (fbmHeader.depth!=8) {
                 fbm_error = _("FBM file does not contain information about the colour palette");
                 file_close(fp);
-                return -1;
+                return 0;
             }
 
             file_seek (fp, sizeof(FBM_FILE_HEADER)+sizeof(FBM_HEADER), SEEK_SET) ;
 
 
-            if (file_read(fp, color_palette, 768) != 768) {
+            r = gr_read_pal (fp);
+/*
+            if (file_read(fp, colors, 768) != 768) {
                 fbm_error = _("PALETTE - FGC file is truncated");
                 file_close(fp);
-                return -1;
+                return 0;
             }
 
             for (i = 0 ; i < 256 ; i++) {
-                palette[i].r = color_palette[i][0];
-                palette[i].g = color_palette[i][1];
-                palette[i].b = color_palette[i][2];
+                palette[i].r = colors[i][0];
+                palette[i].g = colors[i][1];
+                palette[i].b = colors[i][2];
             }
 
             palette_loaded = 1 ;
             palette_changed = 1 ;
             r = 1 ;
+*/
 
         } else if (strcmp (header, FPL_MAGIC) == 0) {
 
@@ -473,9 +686,7 @@
     g >>= screen->format->Gloss ;
     b >>= screen->format->Bloss ;
 
-    color= (r << screen->format->Rshift) |
-           (g << screen->format->Gshift) |
-           (b << screen->format->Bshift) ;
+    color= (r << screen->format->Rshift) | (g << screen->format->Gshift) | (b << screen->format->Bshift) ;
     if (!color) return 1 ;
     return color ;
 }
@@ -530,9 +741,9 @@
     for (n = first ; n <= last ; n++)
     {
         c = &palette[color_list[n]] ;
-        diff =  (key.r > c->r ? key.r-c->r : c->r-key.r)
-             +  (key.g > c->g ? key.g-c->g : c->g-key.g)
-             +  (key.b > c->b ? key.b-c->b : c->b-key.b) ;
+        diff =  ((key.r > c->r) ? key.r-c->r : c->r-key.r)
+             +  ((key.g > c->g) ? key.g-c->g : c->g-key.g)
+             +  ((key.b > c->b) ? key.b-c->b : c->b-key.b) ;
         if (diff < bestdiff) {
             bestdiff = diff ;
             best     = n ;
@@ -740,22 +951,22 @@
     /* Actualiza la paleta */
 
     palette_changed = 0 ;
-
-    if (fade_step != 100)
+/*
+    if (fade_step != 64 && fade_step != 0)
     {
         memcpy (vpalette, palette, sizeof(vpalette)) ;
         activate_vpalette() ;
         background_dirty = 1 ; // Temporal, hasta buscar una solucion mejor
     }
     else
-    {
+    { */
         if (enable_16bits) {
             for (n = 0 ; n < 256 ; n++)
                 colorequiv[n] = SDL_MapRGB (screen->format, palette[n].r, palette[n].g, palette[n].b) ;
         } else {
             SDL_SetColors (screen, palette, 0, 256) ;
         }
-    }
+//    }
 }
 
 void gr_set_rgb (int color, int r, int g, int b)
Index: fxi/src/g_scroll.c
===================================================================
--- a/fxi/src/g_scroll.c	2007-08-28 14:39:57.000000000 +0200
+++ b/fxi/src/g_scroll.c	2007-08-28 14:41:14.000000000 +0200
@@ -36,9 +36,6 @@
 
 #include "fxi.h"
 
-#define MIN(a,b) ((a)<(b)?(a):(b))
-#define MAX(a,b) ((a)>(b)?(a):(b))
-
 /* Indicadores de bloqueo */
 #define GRAPH_HWRAP 1
 #define GRAPH_VWRAP 2
Index: fxi/src/g_texts.c
===================================================================
--- a/fxi/src/g_texts.c	2007-08-28 14:39:57.000000000 +0200
+++ b/fxi/src/g_texts.c	2007-08-28 14:41:14.000000000 +0200
@@ -84,8 +84,7 @@
 {
       char *p1, *p2;
 
-      if (! str || ! *str)
-            return str;
+      if (! str || ! *str) return str;
       for (p1 = str, p2 = str + strlen(str) - 1; p2 > p1; ++p1, --p2)
       {
             *p1 ^= *p2;
@@ -185,9 +184,7 @@
     if (!str) return 1;
 
 	font = gr_font_get (text->fontid);
-	if (font == NULL) {
-		return 1;
-	}
+	if (!font) return 1;
 
 	/* Calculate the text dimensions */
 
@@ -204,8 +201,7 @@
 
 		for (c = 0 ; c < 256 ; c++)
 		{
-			if (font->glyph[c].bitmap == NULL)
-				continue;
+			if (font->glyph[c].bitmap == NULL) continue;
 			if (font->maxheight < (int)font->glyph[c].bitmap->height + font->glyph[c].yoffset)
 				font->maxheight = (int)font->glyph[c].bitmap->height + font->glyph[c].yoffset;
 		}
@@ -262,21 +258,18 @@
 		case TEXT_FLOAT:
 		case TEXT_INT:
 		case TEXT_DWORD:
-			if (text->last_value == *(int *)text->var)
-				return 0;
+			if (text->last_value == *(int *)text->var) return 0;
 			text->last_value = *(int *)text->var;
 			return 1;
 		case TEXT_BYTE:
 		case TEXT_SBYTE:
 		case TEXT_CHAR:
-			if (text->last_value == *(Uint8 *)text->var)
-				return 0;
+			if (text->last_value == *(Uint8 *)text->var) return 0;
 			text->last_value = *(Uint8 *)text->var;
 			return 1;
 		case TEXT_WORD:
 		case TEXT_SHORT:
-			if (text->last_value == *(Uint16 *)text->var)
-				return 0;
+			if (text->last_value == *(Uint16 *)text->var) return 0;
 			text->last_value = *(Uint16 *)text->var;
 			return 1;
 		case TEXT_CHARARRAY:
@@ -330,8 +323,7 @@
 
 		for (c = 0 ; c < 256 ; c++)
 		{
-			if (font->glyph[c].bitmap == NULL)
-				continue;
+			if (font->glyph[c].bitmap == NULL) continue;
 			if (font->maxheight < (int)font->glyph[c].bitmap->height + font->glyph[c].yoffset)
 				font->maxheight = (int)font->glyph[c].bitmap->height + font->glyph[c].yoffset;
 		}
@@ -374,8 +366,7 @@
 	fntcolor8 = text->color8;
 	fntcolor16 = text->color16;
 
-    if(!gr_text_put (0, clip, text->fontid, x, y, str))
-	    gr_text_destroy(text->id);
+    if(!gr_text_put (0, clip, text->fontid, x, y, str)) gr_text_destroy(text->id);
 
 	fntcolor8 = save8;
 	fntcolor16 = save16;
@@ -619,7 +610,7 @@
 
 	if (fntcolor8 == -1)
 	{
-		gr_setcolor (dest->depth == 8 ? gr_find_nearest_color(255,255,255):gr_rgb(255,255,255));
+		gr_setcolor ((dest->depth == 8) ? gr_find_nearest_color(255,255,255):gr_rgb(255,255,255));
 	}
 	else
 	{
