Index: fxi/src/g_font.c
===================================================================
--- fxi/src/g_font.c	2007-08-28 14:39:56.000000000 +0200
+++ fxi/src/g_font.c	2007-08-28 14:41:13.000000000 +0200
@@ -159,8 +159,7 @@
 		for (y = 0 ; y < height ; y++, ptr += bitmap->pitch)
 			memcpy (ptr, charptr + linesize*y, linesize);
 
-		if (bitmap->modified > 0)
-			bitmap->modified = 0 ;
+		if (bitmap->modified > 0) bitmap->modified = 0 ;
 		bitmap->info_flags = 0 ;
 	}
 
@@ -337,6 +336,7 @@
 	int types, i, id;
 	Uint32 y;
 	FONT * f;
+	PALETTE * pal = NULL;
 
 	struct
 	{
@@ -378,20 +378,20 @@
 	/* Read or ignore the palette */
 
 	if (bpp == 8)
-	{
-		if (palette_loaded)
-			file_seek (fp, 576 + 768, SEEK_CUR) ;
-		else
-			if (!gr_read_pal (fp)) return -1 ;
-	}
+	    if (!(pal = gr_read_pal_with_gamma (fp))) return -1 ;
 
 	/* Read the character data (detect old format) */
 
 	if (header[2] == 'x')
 	{
-		if (!file_readSint32(fp, &types)) return -1 ;
-		if (!file_read(fp, chardata, sizeof(chardata)))
+		if (!file_readSint32(fp, &types)) {
+		    pal_destroy(pal);
 			return -1 ;
+		}
+		if (!file_read(fp, chardata, sizeof(chardata))){
+		    pal_destroy(pal);
+		    return -1 ;
+		}
 		for (i = 0 ; i < 256 ; i++)
 		{
 			ARRANGE_DWORD (&chardata[i].width);
@@ -405,9 +405,14 @@
 	}
 	else
 	{
-		if (!file_readSint32(fp, &types)) return -1 ;
-		if (!file_read(fp, oldchardata, sizeof(oldchardata)))
+		if (!file_readSint32(fp, &types)) {
+		    pal_destroy(pal);
 			return -1 ;
+		}
+		if (!file_read(fp, oldchardata, sizeof(oldchardata))){
+		    pal_destroy(pal);
+		    return -1 ;
+		}
 		for (i = 0 ; i < 256 ; i++)
 		{
 			ARRANGE_DWORD (&oldchardata[i].width);
@@ -428,7 +433,11 @@
 	/* Create the font */
 
 	id = gr_font_new() ;
-	if (id == -1) return -1;
+	if (id == -1) {
+	    pal_destroy(pal);
+	    return -1 ;
+	}
+
 	f = fonts[id];
 	assert (f != 0) ;
 
@@ -453,31 +462,29 @@
 		f->glyph[i].xadvance = chardata[i].xadvance ;
 		f->glyph[i].yadvance = chardata[i].yadvance ;
 
-		if (chardata[i].fileoffset == 0 ||
-		    chardata[i].width      == 0 ||
-		    chardata[i].height     == 0) continue ;
+		if (chardata[i].fileoffset == 0 || chardata[i].width == 0 || chardata[i].height == 0) continue ;
 
 		f->glyph[i].xoffset = chardata[i].xoffset ;
 		f->glyph[i].yoffset = chardata[i].yoffset ;
 
 		file_seek (fp, chardata[i].fileoffset, SEEK_SET) ;
-		f->glyph[i].bitmap = gr = bitmap_new (i, chardata[i].width,
-			chardata[i].height, f->bpp, 1) ;
+		f->glyph[i].bitmap = gr = bitmap_new (i, chardata[i].width, chardata[i].height, f->bpp, 1) ;
 		assert (gr) ;
 		bitmap_add_cpoint (gr, 0, 0) ;
+		gr->palette = pal;
+		pal_use(pal);
 
 		for (y = 0, ptr = gr->data ; y < gr->height ; y++, ptr += gr->pitch)
 		{
-			if (!file_read (fp, ptr, gr->widthb))
-				break ;
-			if (gr->depth == 16)
-				gr_convert16_565ToScreen ((Uint16 *)ptr, gr->width);
+			if (!file_read (fp, ptr, gr->widthb)) break ;
+			if (gr->depth == 16) gr_convert16_565ToScreen ((Uint16 *)ptr, gr->width);
 		}
 
 		f->glyph[i].yoffset = chardata[i].yoffset ;
 	}
-	if (f->glyph[32].xadvance == 0)
-		f->glyph[32].xadvance = 4 ;
+	if (f->glyph[32].xadvance == 0) f->glyph[32].xadvance = 4 ;
+
+    pal_destroy(pal); // Elimino la instancia inicial
 
 	return id ;
 }
@@ -521,6 +528,7 @@
 		int	fileoffset ;
 	}
 	chardata[256] ;
+	int palette_saved = 0;
 
 	if (fontid < 0 || fontid > 255 || !fonts[fontid])
 	{
@@ -554,36 +562,42 @@
 	header[7] = font->bpp;
 	gzwrite (file, &header, 8);
 
+	/* Write the character information */
+
+	memset (chardata, 0, sizeof(chardata));
+	offset = 8 + 4 + ((font->bpp == 8) ? 576+768:0) + sizeof(chardata);
+
+	for (n = 0 ; n < 256 ; n++)
+	{
+		chardata[n].xadvance   = font->glyph[n].xadvance;
+		chardata[n].yadvance   = font->glyph[n].yadvance;
+
+		if (font->glyph[n].bitmap)
+		{
 	/* Write the palette */
 
-	if (font->bpp == 8)
+           	if (!palette_saved && font->bpp == 8)
 	{
 		Uint8   colors[256][3];
 		Uint8 * block = calloc(576,1) ;
+        		SDL_Color * gpal = palette ;
+        		int k;
 
-		for (n = 1 ; n < 256 ; n++)
-		{
-			colors[n][0] = palette[n].r >> 2 ;
-			colors[n][1] = palette[n].g >> 2 ;
-			colors[n][2] = palette[n].b >> 2 ;
+                if (font->glyph[n].bitmap->palette) gpal = font->glyph[n].bitmap->palette->rgb; else gpal = palette;
+
+                /* Generate palette info */
+                for (k = 0 ; k < 256 ; k++) {
+                    colors[k][0] = gpal[k].r >> 2 ;
+                    colors[k][1] = gpal[k].g >> 2 ;
+                    colors[k][2] = gpal[k].b >> 2 ;
 		}
+
 		gzwrite (file, &colors, 768) ;
 		gzwrite (file, block, 576) ;
 		free(block) ;
+        		palette_saved = 1;
 	}
 
-	/* Write the character information */
-
-	memset (chardata, 0, sizeof(chardata));
-	offset = 8 + 4 + (font->bpp == 8 ? 576+768:0) + sizeof(chardata);
-
-	for (n = 0 ; n < 256 ; n++)
-	{
-		chardata[n].xadvance   = font->glyph[n].xadvance;
-		chardata[n].yadvance   = font->glyph[n].yadvance;
-
-		if (font->glyph[n].bitmap)
-		{
 			chardata[n].width      = font->glyph[n].bitmap->width;
 			chardata[n].height     = font->glyph[n].bitmap->height;
 			chardata[n].xadvance   = font->glyph[n].xadvance;
@@ -592,8 +606,7 @@
 			chardata[n].yoffset    = font->glyph[n].yoffset;
 			chardata[n].fileoffset = offset;
 
-			offset += font->glyph[n].bitmap->widthb
-				    * chardata[n].height;
+			offset += font->glyph[n].bitmap->widthb * chardata[n].height;
 		}
 
 		ARRANGE_DWORD (&chardata[n].xadvance);
@@ -653,8 +666,7 @@
 				}
 			}
 
-			if (gr->depth == 16)
-				free(block);
+			if (gr->depth == 16) free(block);
 		}
 	}
 
@@ -701,6 +713,7 @@
 	int xadvance = 0;
 	int yadvance = 0;
 	int minyoffset = 0;
+	int len;
 
 	/* Arrays used to convert hex ASCII to binary */
 
@@ -737,8 +750,8 @@
 
 	for (line[2047] = 0 ; ; )
 	{
-		if (!file_gets (fp, line, 2047))
-			break;
+		if (!(len = file_gets (fp, line, 2047))) break;
+		if (line[len-1] == '\n') line[len-1] = '\0';
 
 		/* Handle global-level commands */
 
@@ -799,27 +812,22 @@
 				font->glyph[encoding].xoffset  = xoffset;
 				font->glyph[encoding].yoffset  = -yoffset-height;
 
-				if (minyoffset > -yoffset-height)
-					minyoffset = -yoffset-height;
+				if (minyoffset > -yoffset-height) minyoffset = -yoffset-height;
 
 				error = 1;
 				font->glyph[encoding].bitmap = bitmap_new (encoding, width, height, 1, 1);
-				if (font->glyph[encoding].bitmap == 0)
-					break;
+				if (font->glyph[encoding].bitmap == 0) break;
 				bitmap_add_cpoint (font->glyph[encoding].bitmap, 0, 0) ;
 
-				if (font->maxwidth < width)
-					font->maxwidth = width;
-				if (font->maxheight < height)
-					font->maxheight = height;
+				if (font->maxwidth < width) font->maxwidth = width;
+				if (font->maxheight < height) font->maxheight = height;
 
 				for (y = 0 ; y < height ; y++)
 				{
-					if (!file_gets (fp, line, 2047))
-						break;
+					if (!(len=file_gets (fp, line, 2047))) break;
+					if (line[len-1] == '\n') line[len-1] = '\0';
 					ptr  = line;
-					optr = (Uint8 *)font->glyph[encoding].bitmap->data +
-						   font->glyph[encoding].bitmap->pitch * y;
+					optr = (Uint8 *)font->glyph[encoding].bitmap->data + font->glyph[encoding].bitmap->pitch * y;
 
 					for (x = 0 ; x < width ; x += 8)
 					{
@@ -869,7 +877,6 @@
 
 FONT * gr_font_get (int id)
 {
-	if (id >= 0 && id <= 255)
-		return fonts[id];
+	if (id >= 0 && id <= 255) return fonts[id];
 	return NULL;
 }
Index: fxi/src/g_fpg.c
===================================================================
--- fxi/src/g_fpg.c	2007-08-28 14:39:56.000000000 +0200
+++ fxi/src/g_fpg.c	2007-08-28 14:41:13.000000000 +0200
@@ -128,8 +128,7 @@
 
 GRLIB * grlib_get (int libid)
 {
-	if (libid < 0 || libid >= lib_nextid)
-		return 0 ;
+	if (libid < 0 || libid >= lib_nextid) return 0 ;
 	return libs[libid] ;
 }
 
@@ -312,17 +311,7 @@
 	int libid ;
 	file * fp = file_open (libname, "rb") ;
 
-	if (!fp)
-	{
-#ifdef WIN32
-		char buffer[2048];
-		GetCurrentDirectory(2048, buffer);
-		gr_error (_("'%s': Library not found in %s\n"), libname, buffer) ;
-#else
-		gr_error (_("'%s': Library not found\n"), libname) ;
-#endif
-		return -1 ;
-	}
+	if (!fp) return -1 ;
 	libid = gr_read_lib (fp) ;
 	file_close (fp) ;
 	return libid ;
@@ -338,6 +327,7 @@
 	unsigned c;
 	GRLIB * lib ;
 	GRAPH * gr ;
+	PALETTE * pal = NULL ;
 
 	struct
 	{
@@ -366,13 +356,7 @@
 	else
 		return 0 ;
 
-	if (bpp == 8)
-	{
-		if (palette_loaded)
-			file_seek (fp, 576 + 768, SEEK_CUR) ;
-		else if (!gr_read_pal (fp))
-			return 0 ;
-	}
+	if (bpp == 8 && !(pal = gr_read_pal_with_gamma (fp))) return 0 ;
 
 	while (!file_eof(fp))
 	{
@@ -387,7 +371,11 @@
 		/* Cabecera del gráfico */
 
 		gr = bitmap_new (chunk.code, chunk.width, chunk.height, bpp, 1);
-		if (!gr) return 0 ;
+		if (!gr) {
+		    grlib_destroy (libid) ;
+            pal_destroy (pal) ; // Elimino la instancia inicial
+		    return 0 ;
+		}
 		memcpy (gr->name, chunk.name, 32) ;
 		gr->name[31] = 0 ;
 		gr->ncpoints = chunk.flags ;
@@ -398,7 +386,11 @@
 		if (gr->ncpoints)
 		{
 			gr->cpoints = (CPOINT *) malloc(gr->ncpoints * sizeof(CPOINT)) ;
-			if (!gr->cpoints) { free(gr) ; return 0 ; }
+			if (!gr->cpoints) {
+                bitmap_destroy (gr) ;
+                pal_destroy (pal) ;
+			    return 0 ;
+			}
 			for (c = 0 ; c < gr->ncpoints ; c++)
 			{
 				file_readSint16 (fp, &px) ;
@@ -426,20 +418,23 @@
 			Uint8 * ptr = (Uint8 *)gr->data + gr->pitch*y;
 			if (!file_read (fp, ptr, len))
 			{
-				free (gr) ;
+				bitmap_destroy (gr) ;
+    		    grlib_destroy (libid) ;
 				break ;
 			}
 			if (bpp == 16)
 			{
 				ARRANGE_WORDS (ptr, len/2);
-				if (scr_initialized)
-					gr_convert16_565ToScreen ((Uint16 *)ptr, len/2);
+				if (scr_initialized) gr_convert16_565ToScreen ((Uint16 *)ptr, len/2) ;
 			}
 		}
 
-
 		grlib_add_map (libid, gr) ;
+        pal_map_assign (libid, gr, pal) ;
 	}
+
+    pal_destroy (pal) ; // Elimino la instancia inicial
+
 	return libid ;
 }
 
@@ -458,9 +453,6 @@
 
 void grlib_init()
 {
-	if (!syslib)
-	{
-		syslib = grlib_create() ;
-	}
+	if (!syslib) syslib = grlib_create() ;
 }
 
Index: fxi/src/g_main.c
===================================================================
--- fxi/src/g_main.c	2007-08-28 14:39:56.000000000 +0200
+++ fxi/src/g_main.c	2007-08-28 14:41:13.000000000 +0200
@@ -111,7 +111,7 @@
 
 static int sdl_equiv[SDLK_LAST+1] ;
 key_equiv key_table[127] ;  /* Now we have a search table with equivs */
-unsigned char * keystate ;        /* Pointer to key states */
+unsigned char * keystate = NULL;        /* Pointer to key states */
 int keystate_size = 0 ;
 
 static int equivs[] =
@@ -302,9 +302,6 @@
 
 REGION    regions[32] ;
 
-#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
-#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
-
 /*
  *  FUNCTION : region_define
  *
@@ -599,7 +596,7 @@
     /* Reset ascii and scancode if last key was released... */
     /* must check all the linked equivs */
 
-    if (show_console == 0) memcpy (keystate, SDL_GetKeyState(NULL), keystate_size) ;
+    if (show_console == 0 && keystate) memcpy (keystate, SDL_GetKeyState(NULL), keystate_size) ;
 
     GLODWORD(MOUSEWHEELUP)   = 0 ;
     GLODWORD(MOUSEWHEELDOWN) = 0 ;
@@ -623,8 +620,13 @@
         switch (e.type)
         {
             case SDL_MOUSEMOTION:
+                if (enable_scale || scale_mode != SCALE_NONE) {
+                    GLODWORD(MOUSEX) = e.motion.x / 2 ;
+                    GLODWORD(MOUSEY) = e.motion.y / 2 ;
+                } else {
                 GLODWORD(MOUSEX) = e.motion.x ;
                 GLODWORD(MOUSEY) = e.motion.y ;
+                }
                 break ;
 /*
             case SDL_JOYAXISMOTION:
@@ -716,8 +718,7 @@
                     }
                     if (e.key.keysym.sym == SDLK_p)
                     {
-                        if (!show_console)
-                            show_profile = !show_profile;
+                        if (!show_console) show_profile = !show_profile;
                         background_dirty = 1;
                         break ;
                     }
@@ -870,8 +871,8 @@
     /* Now actualized every frame... */
     GLODWORD(SHIFTSTATUS) = ((m & KMOD_LSHIFT)                    ? 1 : 0) +
                             ((m & KMOD_RSHIFT)                    ? 2 : 0) +
-                            ((m & KMOD_RCTRL) || (m & KMOD_LCTRL) ? 4 : 0) +
-                            ((m & KMOD_LALT)  || (m & KMOD_RALT)  ? 8 : 0)  ;
+                            (((m & KMOD_RCTRL) || (m & KMOD_LCTRL)) ? 4 : 0) +
+                            (((m & KMOD_LALT)  || (m & KMOD_RALT))  ? 8 : 0) ;
 
     last_mouse_x = GLODWORD(MOUSEX) ;
     last_mouse_y = GLODWORD(MOUSEY) ;
@@ -1055,7 +1056,8 @@
     }
 
     // PATCH - XGRAPH DOES NOT ROTATE DESTINATION GRAPHIC
-    if (LOCDWORD(i,ANGLE) || scalex != 100 || scaley != 100) {
+    if ((map->current_keyframe >= 0 && map->keyframes[map->current_keyframe].angle) ||
+        LOCDWORD(i,ANGLE) || scalex != 100 || scaley != 100) {
         if (LOCDWORD(i,XGRAPH) && scalex == 100 && scaley == 100) {
             gr_blit (0, region, x, y, flags, map) ;
         } else {
@@ -1117,7 +1119,8 @@
     fclip = regions[r];
     if (clip) region_union (&fclip, clip);
 
-    if (LOCDWORD(i,ANGLE) || scalex != 100 || scaley != 100) {
+    if ((map->current_keyframe >= 0 && map->keyframes[map->current_keyframe].angle) ||
+        LOCDWORD(i,ANGLE) || scalex != 100 || scaley != 100) {
         if (LOCDWORD(i,XGRAPH) && scalex == 100 && scaley == 100) {
             gr_blit (0, &regions[r], x, y, flags, map) ;
         } else {
@@ -1198,7 +1201,8 @@
     region = regions[r];
     if (clip) region_union (&region, clip);
 
-    if (GLODWORD(MOUSEANGLE) || GLODWORD(MOUSESIZE) != 100)
+    if ((map->current_keyframe >= 0 && map->keyframes[map->current_keyframe].angle) ||
+        GLODWORD(MOUSEANGLE) || GLODWORD(MOUSESIZE) != 100)
         gr_rotated_blit (0, &region, GLODWORD(MOUSEX),
                          GLODWORD(MOUSEY), GLODWORD(MOUSEFLAGS),
                          GLODWORD(MOUSEANGLE), GLODWORD(MOUSESIZE),
@@ -1311,9 +1315,10 @@
         first_dll_object = object->next;
         if (object->x.bbox.x == -2)
             (*object->x.info)(object->x.what, &object->x.bbox);
+
         gr_mark_rect (object->x.bbox.x, object->x.bbox.y,
-                      object->x.bbox.x2 - object->x.bbox.x + 1,
-                      object->x.bbox.y2 - object->x.bbox.y + 1);
+                      object->x.bbox.x2 - object->x.bbox.x,
+                      object->x.bbox.y2 - object->x.bbox.y);
         free (object);
         dll_object_count--;
     }
@@ -1323,11 +1328,10 @@
         {
             next = object->next;
             object->next = next->next;
-            if (next->x.bbox.x == -2)
-                (*next->x.info)(next->x.what, &next->x.bbox);
+            if (next->x.bbox.x == -2) (*next->x.info)(next->x.what, &next->x.bbox);
             gr_mark_rect (next->x.bbox.x, next->x.bbox.y,
-                          next->x.bbox.x2 - next->x.bbox.x + 1,
-                          next->x.bbox.y2 - next->x.bbox.y + 1);
+                          next->x.bbox.x2 - next->x.bbox.x,
+                          next->x.bbox.y2 - next->x.bbox.y);
             free (next);
             dll_object_count--;
             break;
@@ -1338,8 +1342,7 @@
 
 int compare_actions (const OBJECT * a1, const OBJECT * a2)
 {
-    return (a1->z == a2->z ? a1->id - a2->id : a2->z - a1->z) ;
-//    return (a2->z - a1->z) ;
+    return ((a1->z == a2->z) ? a1->id - a2->id : a2->z - a1->z) ;
 }
 
 void draw_mode7 (void * ptr, REGION * clip)
@@ -1414,9 +1417,14 @@
     w = scr_width / 16;
     h = scr_height / 8;
 
-    for (cx = x/w*w ; cx < x+width ; cx += w)
+    x = MIN(x, x + width);
+    y = MIN(y, y + height);
+    width = ABS(width);
+    height = ABS(height);
+
+    for (cx = x / w * w ; cx <= x + width ; cx += w)
     {
-        for (cy = y/h*h ; cy < y+height ; cy += h)
+        for (cy = y / h * h ; cy <= y + height ; cy += h)
         {
             if (cx/w < 16 && cx/w >= 0)
                 zonearray[cx/w] |= (1 << (cy / h));
@@ -1438,19 +1446,7 @@
 
 void gr_mark_instance (INSTANCE * r)
 {
-    int x, y, w, h;
-
-    w = scr_width / 16;
-    h = scr_height / 8;
-
-    for (x = LOCDWORD(r, BOX_X0)/w*w ; x <= LOCDWORD(r, BOX_X1) ; x += w)
-    {
-        for (y = LOCDWORD(r, BOX_Y0)/h*h ; y <= LOCDWORD(r, BOX_Y1) ; y += h)
-        {
-            if (x/w < 16 && x/w >= 0)
-                zonearray[x/w] |= (1 << (y / h));
-        }
-    }
+    gr_mark_rect(LOCDWORD(r, BOX_X0), LOCDWORD(r, BOX_Y0), LOCDWORD(r, BOX_X1)-LOCDWORD(r, BOX_X0), LOCDWORD(r, BOX_Y1)-LOCDWORD(r, BOX_Y0));
 }
 
 /*
@@ -1491,44 +1487,21 @@
 
             if (onlychanged)
             {
-                if ((LOCDWORD(r,CHANGED) = instance_poschanged(r)) == 0)
-                    continue;
+                if ((LOCDWORD(r,CHANGED) = instance_poschanged(r)) == 0) continue;
 
                 /* Mark the previous position */
-
-                for (x = LOCDWORD(r, BOX_X0)/w*w ; x <= LOCDWORD(r, BOX_X1) ; x += w)
-                {
-                    for (y = LOCDWORD(r, BOX_Y0)/h*h ; y <= LOCDWORD(r, BOX_Y1) ; y += h)
-                    {
-                        if (x/w < 16 && x/w >= 0)
-                            zonearray[x/w] |= (1 << (y / h));
-                    }
-                }
+                gr_mark_rect(LOCDWORD(r, BOX_X0), LOCDWORD(r, BOX_Y0), LOCDWORD(r, BOX_X1)-LOCDWORD(r, BOX_X0), LOCDWORD(r, BOX_Y1)-LOCDWORD(r, BOX_Y0));
 
                 /* Update and mark the new position */
                 instance_posupdate(r);
                 instance_update_bbox (r);
 
-                for (x = LOCDWORD(r, BOX_X0)/w*w ; x <= LOCDWORD(r, BOX_X1) ; x += w)
-                {
-                    for (y = LOCDWORD(r, BOX_Y0)/h*h ; y <= LOCDWORD(r, BOX_Y1) ; y += h)
-                    {
-                        if (x/w < 16 && x/w >= 0)
-                            zonearray[x/w] |= (1 << (y / h));
-                    }
-                }
+                gr_mark_rect(LOCDWORD(r, BOX_X0), LOCDWORD(r, BOX_Y0), LOCDWORD(r, BOX_X1)-LOCDWORD(r, BOX_X0), LOCDWORD(r, BOX_Y1)-LOCDWORD(r, BOX_Y0));
             }
             else
             {
                 /* Mark the current position (next frame, the next will be marked */
-                for (x = LOCDWORD(r, BOX_X0)/w*w ; x <= LOCDWORD(r, BOX_X1) ; x += w)
-                {
-                    for (y = LOCDWORD(r, BOX_Y0)/h*h ; y <= LOCDWORD(r, BOX_Y1) ; y += h)
-                    {
-                        if (x/w < 16 && x/w >= 0)
-                            zonearray[x/w] |= (1 << (y / h));
-                    }
-                }
+                gr_mark_rect(LOCDWORD(r, BOX_X0), LOCDWORD(r, BOX_Y0), LOCDWORD(r, BOX_X1)-LOCDWORD(r, BOX_X0), LOCDWORD(r, BOX_Y1)-LOCDWORD(r, BOX_Y0));
 
                 /* Update the bounding box */
                 instance_update_bbox (r);
@@ -1543,24 +1516,17 @@
 
             if (!onlychanged || object_list[i].changed)
             {
-                for (x = region.x/w*w ; x <= region.x2 ; x += w)
-                    for (y = region.y/h*h ; y <= region.y2 ; y += h)
-                    {
-                        if (x/w < 16 && x/w >= 0)
-                            zonearray[x/w] |= (1 << (y / h));
-                    }
+                gr_mark_rect (region.x,region.y,region.x2-region.x,region.y2-region.y);
             }
 
             /* Mark updated object position */
 
             if (object_list[i].changed)
             {
-                for (x = object_list[i].bbox.x/w*w ; x <= object_list[i].bbox.x2 ; x += w)
-                    for (y = object_list[i].bbox.y/h*h ; y <= object_list[i].bbox.y2 ; y += h)
-                    {
-                        if (x/w < 16 && x/w >= 0)
-                            zonearray[x/w] |= (1 << (y / h));
-                    }
+                gr_mark_rect (object_list[i].bbox.x,
+                              object_list[i].bbox.y,
+                              object_list[i].bbox.x2-object_list[i].bbox.x,
+                              object_list[i].bbox.y2-object_list[i].bbox.y);
             }
         }
     }
@@ -1630,11 +1596,9 @@
                 {
                     /* Si hay algun hueco, entonces corto aca, ahora vuelve a entrar y esto entra en otra recta */
                     for (x2 = x ; x2 < x+cw ; x2++)
-                        if (!(zonearray[x2] & (1 << (y+ch))))
-                            break;
+                        if (!(zonearray[x2] & (1 << (y + ch)))) break;
 
-                    if (x2 < x+cw)
-                        break;
+                    if (x2 < x+cw) break;
 
                     for (x2 = x ; x2 < x+cw ; x2++)
                         zonearray[x2] &= ~(1 << (y+ch));
@@ -1872,19 +1836,18 @@
         gr_mark_instances (dump_type == 0);
         n = updaterects_count = gr_mark_rects (updaterects);
 
-        /* Reset the zone-to-update array for the next frame */
-        memset (zonearray, 0, 128/8);
-
-        gr_setcolor (0);
         for (a = 0 ; a < n ; a++)
         {
             if (background_is_black)
-                gr_box (dest, &updaterects[a], 0, 0, 9999, 9999) ;
+                gr_clear_region (scrbitmap, &updaterects[a]);
             else if (enable_16bits && background_8bits_used)
                 gr_blit (scrbitmap, &updaterects[a], 0, 0, B_NOCOLORKEY, background_8bits);
             else
                 gr_blit (scrbitmap, &updaterects[a], 0, 0, B_NOCOLORKEY, background);
         }
+
+        /* Reset the zone-to-update array for the next frame */
+        memset (zonearray, 0, 128/8);
     }
 
     gprof_end ("Background");
@@ -1903,18 +1866,18 @@
                 if (object_list[a].draw == draw_instance)
                 {
                     INSTANCE * i = (INSTANCE *)object_list[a].what;
-                    if (LOCDWORD(i,BOX_X1) < updaterects[n].x ||
-                        LOCDWORD(i,BOX_X0) > updaterects[n].x2 ||
-                        LOCDWORD(i,BOX_Y1) < updaterects[n].y ||
-                        LOCDWORD(i,BOX_Y0) > updaterects[n].y2)
+                    if (MAX(LOCDWORD(i,BOX_X0),LOCDWORD(i,BOX_X1)) < updaterects[n].x ||
+                        MIN(LOCDWORD(i,BOX_X0),LOCDWORD(i,BOX_X1)) > updaterects[n].x2 ||
+                        MAX(LOCDWORD(i,BOX_Y0),LOCDWORD(i,BOX_Y1)) < updaterects[n].y ||
+                        MIN(LOCDWORD(i,BOX_Y0),LOCDWORD(i,BOX_Y1)) > updaterects[n].y2)
                         continue;
                 }
                 else
                 {
-                    if (object_list[a].bbox.x2 < updaterects[n].x ||
-                        object_list[a].bbox.x  > updaterects[n].x2 ||
-                        object_list[a].bbox.y2 < updaterects[n].y ||
-                        object_list[a].bbox.y  > updaterects[n].y2)
+                    if (MAX(object_list[a].bbox.x,object_list[a].bbox.x2) < updaterects[n].x ||
+                        MIN(object_list[a].bbox.x,object_list[a].bbox.x2) > updaterects[n].x2 ||
+                        MAX(object_list[a].bbox.y,object_list[a].bbox.y2) < updaterects[n].y ||
+                        MIN(object_list[a].bbox.y,object_list[a].bbox.y2) > updaterects[n].y2)
                         continue;
                 }
                 (*object_list[a].draw) (object_list[a].what, &updaterects[n]) ;
@@ -1960,11 +1923,19 @@
 
         /* Fading */
 
-        if (fade_on != 0)
+        if (fade_on || fade_set)
         {
             gr_fade_step() ;
             background_dirty = 1;
         }
+    } else {
+        /* Muestro consola, marco toda la pantalla */
+
+        updaterects_count = 1;
+        updaterects[0].x = 0;
+        updaterects[0].y = 0;
+        updaterects[0].x2 = scr_width-1;
+        updaterects[0].y2 = scr_height-1;
     }
 
     /* Visualiza la consola */
@@ -1972,8 +1943,7 @@
     gr_con_show(show_console) ;
     gr_con_draw() ;
 
-    if (show_profile)
-        gprof_draw (scrbitmap);
+    if (show_profile) gprof_draw (scrbitmap);
 
     /* Actualiza la paleta y la pantalla */
 
@@ -1983,7 +1953,7 @@
 
 }
 
-/* FUnción de inicialización de la librería gráfica */
+/* Función de inicialización de la librería gráfica */
 
 static int screen_locked = 0 ;
 
@@ -1992,11 +1962,12 @@
     if (screen_locked) return 1 ;
     screen_locked = 1 ;
 
-    if (SDL_LockSurface (screen) < 0)
-        return -1 ;
+    if (SDL_LockSurface (screen) < 0) return -1 ;
 
     if ( (!enable_scale && scale_mode == SCALE_NONE) && !double_buffer)
     {
+        if (scrbitmap && !scrbitmap_is_fake) free (scrbitmap->data) ;
+
         if (!scrbitmap)
         {
             scrbitmap = bitmap_new (0, screen->w, screen->h, enable_16bits ? 16:8, 1) ;
@@ -2023,6 +1994,12 @@
     }
     else
     {
+        if (scrbitmap && scrbitmap_is_fake)
+        {
+            bitmap_destroy_fake (scrbitmap) ;
+            scrbitmap = NULL ;
+        }
+
         scrbitmap_is_fake = 0 ;
 
         if (!scrbitmap)
@@ -2042,6 +2019,7 @@
 {
     int     a ;
     GRAPH   * scr;
+    int     m = 1;
 
     if (!screen_locked) return ;
     screen_locked = 0 ;
@@ -2050,10 +2028,9 @@
     if (enable_scale || scale_mode != SCALE_NONE)
     {
         int aux_scale_mode;
+        m = 2;
 
-        if (enable_scale || GLODWORD(SCALE_MODE) != SCALE_NONE ) {
-            scale_mode     = GLODWORD(SCALE_MODE);
-        }
+        if (enable_scale || GLODWORD(SCALE_MODE) != SCALE_NONE ) scale_mode = GLODWORD(SCALE_MODE);
         aux_scale_mode = (scale_mode != SCALE_NONE) ? scale_mode : SCALE_SCALE2X;
 
         if (scrbitmap->depth == 8)
@@ -2062,12 +2039,11 @@
             Uint16 * extra;
             int length = scrbitmap->width * scrbitmap->height, n;
 
-            if (scrbitmap_extra == NULL
-                || scrbitmap_extra->width != scrbitmap->width
-                || scrbitmap_extra->height != scrbitmap->height)
+            if (scrbitmap_extra         == NULL             ||
+                scrbitmap_extra->width  != scrbitmap->width ||
+                scrbitmap_extra->height != scrbitmap->height)
             {
-                if (scrbitmap_extra)
-                    bitmap_destroy (scrbitmap_extra);
+                if (scrbitmap_extra) bitmap_destroy (scrbitmap_extra);
                 scrbitmap_extra = bitmap_new (0, scrbitmap->width, scrbitmap->height, 16, 1);
             }
 
@@ -2088,49 +2064,40 @@
         /* Esto podria ir en un modulo aparte */
         switch ( aux_scale_mode ) {
             case    SCALE_SCALE2X:
-                    scale2x (scr->data, scr->pitch,
-                             screen->pixels, screen->pitch,
-                             scr->width, scr->height);
+                    scale2x (scr->data, scr->pitch, screen->pixels, screen->pitch, scr->width, scr->height);
                     break;
 
             case    SCALE_HQ2X:
-                    hq2x (scr->data, scr->pitch,
-                          screen->pixels, screen->pitch,
-                          scr->width, scr->height);
+                    hq2x (scr->data, scr->pitch, screen->pixels, screen->pitch, scr->width, scr->height);
                     break;
 
             case    SCALE_SCANLINE2X:
-                    scanline2x (scr->data, scr->pitch,
-                                screen->pixels, screen->pitch,
-                                scr->width, scr->height);
+                    scanline2x (scr->data, scr->pitch, screen->pixels, screen->pitch, scr->width, scr->height);
                     break;
 
             case    SCALE_NOFILTER:
-                    scale_normal2x (scr->data, scr->pitch,
-                                    screen->pixels, screen->pitch,
-                                    scr->width, scr->height);
+                    scale_normal2x (scr->data, scr->pitch, screen->pixels, screen->pitch, scr->width, scr->height);
                     break;
 
             case    SCALE_NONE:
                     /* No usado */
                     break;
         }
+
         SDL_UnlockSurface (screen) ;
-        SDL_UpdateRect (screen, 0, 0, 0, 0) ;
+        SDL_Flip(screen) ;
+
+/*        SDL_UpdateRect (screen, 0, 0, 0, 0) ; */
     }
     else if (scrbitmap_is_fake)
     {
         SDL_UnlockSurface (screen) ;
 
-        scrbitmap->data = 0 ;
+/*        scrbitmap->data = 0 ;
         if (double_buffer)
             SDL_Flip(screen) ;
-        else
-        {
-            if (updaterects_count == 0)
-                /* Nothing to update! */ ;
-            else
-            {
+        else */
+        if (updaterects_count) {
                 SDL_Rect rects[128];
                 int i;
 
@@ -2138,14 +2105,11 @@
                 {
                     rects[i].x = updaterects[i].x;
                     rects[i].y = updaterects[i].y;
-                    rects[i].w = updaterects[i].x2 - rects[i].x + 1;
-                    rects[i].h = updaterects[i].y2 - rects[i].y + 1;
+                rects[i].w = (updaterects[i].x2 - rects[i].x + 1);
+                rects[i].h = (updaterects[i].y2 - rects[i].y + 1);
                 }
                 SDL_UpdateRects (screen, updaterects_count, rects) ;
             }
-            SDL_UnlockSurface (screen) ;
-            SDL_UpdateRect (screen, 0, 0, 0, 0) ;
-        }
     }
     else
     {
@@ -2198,7 +2162,8 @@
         }
 
         SDL_UnlockSurface (screen) ;
-        SDL_UpdateRect (screen, 0, 0, 0, 0) ;
+        SDL_Flip(screen) ;
+/*        SDL_UpdateRect (screen, 0, 0, 0, 0) ; */
     }
 }
 
@@ -2235,7 +2200,7 @@
     if (scr_initialized && scrbitmap)
     {
         if (scrbitmap_is_fake)
-            free (scrbitmap) ;
+            bitmap_destroy_fake (scrbitmap) ;
         else
             bitmap_destroy (scrbitmap) ;
 
@@ -2355,6 +2320,8 @@
     regions[0].x2 = width-1 ;
     regions[0].y2 = height-1 ;
 
+    if (enable_16bits) pal_refresh(NULL) ;
+
     /* Bitmaps de fondo */
 
     if (!background || scr_width != width || scr_height != height)
@@ -2384,10 +2351,11 @@
     scr_width = width ;
     scr_height = height ;
 
+    SDL_WarpMouse(scr_width / 2, scr_height / 2);
+
     /* Paleta de colores por defecto */
 
-    if (!palette_loaded)
-    {
+    if (!palette_loaded) {
         for (n = 0 ; n < 256 ; n++)
             gr_set_rgb (n, default_palette[n*3]/4, default_palette[n*3+1]/4, default_palette[n*3+2]/4) ;
     }
Index: fxi/src/g_maps.c
===================================================================
--- fxi/src/g_maps.c	2007-08-28 14:39:56.000000000 +0200
+++ fxi/src/g_maps.c	2007-08-28 14:41:13.000000000 +0200
@@ -128,6 +128,8 @@
 	gr->prev             = NULL;
 	gr->current_keyframe = -1;
 
+	gr->palette          = NULL ;
+
 	if (first)
 		first->prev = gr;
 	first = gr;
@@ -185,6 +187,8 @@
 	gr->offset = map->offset ;
 	gr->info_flags = map->info_flags ;
 	gr->modified = map->modified ;
+	gr->palette = map->palette ;
+	pal_use(map->palette);
 	memcpy (gr->name, map->name, sizeof(map->name)) ;
 	return gr ;
 }
@@ -256,10 +260,29 @@
 	if (map->keyframes) free(map->keyframes);
 	if (map->sequences) free(map->sequences);
 
+	pal_destroy(map->palette);
+
 	free (map->data) ;
 	free (map) ;
 }
 
+void bitmap_destroy_fake (GRAPH * map)
+{
+    if (!map) return;
+
+    if (map->prev) map->prev->next = map->next;
+    if (map->next) map->next->prev = map->prev;
+/*  if (map->next_time) map->next->prev = map->next; */
+    if (first == map) first = map->next;
+
+    if (map->cpoints) free(map->cpoints);
+    if (map->keyframes) free(map->keyframes);
+    if (map->sequences) free(map->sequences);
+
+    pal_destroy(map->palette);
+
+    free (map) ;
+}
 
 static GRAPH * gr_read_map (file * fp)
 {
@@ -269,6 +292,7 @@
 	int depth, code ;
 	GRAPH * gr ;
 	int len;
+	PALETTE * pal = NULL;
 
 	/* Carga los datos de cabecera */
 
@@ -280,25 +304,23 @@
 	else if (strcmp (header, M01_MAGIC) == 0)
 		depth = 1 ;
 	else
-		return 0 ;
+		return NULL ;
 
 	file_readUint16 (fp, &w) ;
 	file_readUint16 (fp, &h) ;
 	file_readSint32 (fp, &code) ;
 
 	gr = bitmap_new (code, w, h, depth, 1) ;
-	if (!gr) return 0 ;
+	if (!gr) return NULL ;
 	file_read (fp, gr->name, 32) ;
 	gr->name[31] = 0 ;
 
 	/* Datos de paleta */
 
 	if (gr->depth == 8)
-	{
-		if (palette_loaded)
-			file_seek (fp, 576 + 768, SEEK_CUR) ;
-		else
-			if (!gr_read_pal (fp)) return 0 ;
+		if (!(pal = gr_read_pal_with_gamma (fp))) {
+			bitmap_destroy(gr);
+			return NULL ;
 	}
 
 	/* Puntos de control */
@@ -310,8 +332,9 @@
 	{
 		gr->cpoints = (CPOINT *) malloc (c * sizeof(CPOINT)) ;
 		if (!gr->cpoints) {
-		    free(gr) ;
-		    return 0 ;
+			bitmap_destroy(gr);
+			pal_destroy(pal);
+			return NULL ;
 		}
 
 		for (c = 0 ; c < gr->ncpoints ; c++)
@@ -339,9 +362,9 @@
 		Uint8 * line = (Uint8 *)gr->data + gr->pitch*y;
 		if (!file_read (fp, line, len))
 		{
-			free (gr->data) ;
-			free (gr) ;
-			return 0 ;
+			bitmap_destroy(gr);
+			pal_destroy(pal);
+			return NULL ;
 		}
 		if (gr->depth == 16)
 		{
@@ -350,6 +373,8 @@
 		}
 	}
 
+	if (gr->depth == 8 && !gr->palette) gr->palette = pal;
+
 	gr->modified = 1 ;
 	return gr ;
 }
@@ -412,6 +437,7 @@
 	GRAPH * gr ;
 
 	gr = bitmap_new (0, w, h, depth, frames) ;
+	if (!gr) return NULL;
 	gr->code = bitmap_next_code() ;
 	assert (syslib) ;
 	grlib_add_map (0, gr) ;
Index: fxi/src/g_mode7.c
===================================================================
--- fxi/src/g_mode7.c	2007-08-28 14:38:26.000000000 +0200
+++ fxi/src/g_mode7.c	2007-08-28 14:41:14.000000000 +0200
@@ -71,8 +71,7 @@
 
 void gr_mode7_bbox (int n, REGION * r)
 {
-    if (n >= 0 && n <= 9)
-        *r = *current_mode7[n].region;
+    if (n >= 0 && n <= 9) *r = *current_mode7[n].region;
 }
 
 int gr_mode7_active (int n)
@@ -253,11 +252,8 @@
 
         //if (point_z >= camera_z) break ;
 
-        lines[y].right_bmp_x = fdiv( fmul((point_x - camera_x), -camera_z),
-                           (point_z - camera_z) ) + camera_x ;
-
-        lines[y].right_bmp_y = fdiv( fmul((point_y - camera_y), -camera_z),
-                           (point_z - camera_z) ) + camera_y ;
+        lines[y].right_bmp_x = fdiv(fmul((point_x - camera_x), -camera_z), (point_z - camera_z)) + camera_x ;
+        lines[y].right_bmp_y = fdiv(fmul((point_y - camera_y), -camera_z), (point_z - camera_z)) + camera_y ;
 
         /* Averigua el incremento necesario para cada paso de la línea */
 
@@ -275,27 +271,21 @@
     if (outdoor)
     {
         outdoor_hmask = outdoor_vmask = 0xFFFFFFFF ;
-        while (~(outdoor_hmask << 1) < (int)outdoor->width-1)
-            outdoor_hmask <<= 1 ;
-        while (~(outdoor_vmask << 1) < (int)outdoor->height-1)
-            outdoor_vmask <<= 1 ;
+        while (~(outdoor_hmask << 1) < (int)outdoor->width-1) outdoor_hmask <<= 1 ;
+        while (~(outdoor_vmask << 1) < (int)outdoor->height-1) outdoor_vmask <<= 1 ;
         outdoor_hmask = ~outdoor_hmask ;
         outdoor_vmask = ~outdoor_vmask ;
     }
 
-    jump = camera_z < 0 ? -1 : 1 ;
-    ptr += (jump > 0 ? dest->pitch : -(int)dest->pitch) ;
+    jump = (camera_z < 0) ? -1 : 1 ;
+    ptr += ((jump > 0) ? dest->pitch : -(int)dest->pitch) ;
     y   += jump ;
 
-    if (dest->depth != 8)
-        gr_error ("Profundidad de color no soportada\n(mode7, dest)") ;
-    if (outdoor && outdoor->depth != 8)
-        gr_error ("Profundidad de color no soportada\n(mode7, out)") ;
-    if (indoor && indoor->depth != 8)
-        gr_error ("Profundidad de color no soportada\n(mode7, in)") ;
+    if (dest->depth != 8) gr_error ("Profundidad de color no soportada\n(mode7, dest)") ;
+    if (outdoor && outdoor->depth != 8) gr_error ("Profundidad de color no soportada\n(mode7, out)") ;
+    if (indoor && indoor->depth != 8) gr_error ("Profundidad de color no soportada\n(mode7, in)") ;
 
-    if ((dat->flags & B_TRANSLUCENT) && !trans_table_updated)
-        gr_make_trans_table() ;
+    if ((dat->flags & B_TRANSLUCENT) && !trans_table_updated) gr_make_trans_table() ;
 
     if (!(dat->flags & B_TRANSLUCENT))
     for ( ; y < height && y >= 0 ; y += jump)
@@ -341,7 +331,7 @@
             bmp_y += vinc ;
         }
 
-        ptr = baseline + (jump > 0 ? dest->pitch : -(int)dest->pitch) ;
+            ptr = baseline + ((jump > 0) ? dest->pitch : -(int)dest->pitch) ;
     }
     else
     for ( ; y < height && y >= 0 ; y += jump)
@@ -385,7 +375,7 @@
             bmp_y += vinc ;
         }
 
-        ptr = baseline + (jump > 0 ? dest->pitch : -(int)dest->pitch) ;
+                ptr = baseline + ((jump > 0) ? dest->pitch : -(int)dest->pitch) ;
     }
 
     /* Crea una lista ordenada de instancias a dibujar */
Index: fxi/src/g_pal.c
===================================================================
--- fxi/src/g_pal.c	2007-08-28 14:39:57.000000000 +0200
+++ fxi/src/g_pal.c	2007-08-28 14:41:14.000000000 +0200
@@ -54,10 +54,15 @@
 
 extern GRAPH * gr_read_png (const char * filename) ;
 
+static unsigned char colors[256][3] ;
+
+PALETTE * first_palette = NULL ;
+
 SDL_Color  palette[256] ;
-SDL_Color vpalette[256] ;
 
+SDL_Color vpalette[256] ;
 Uint16     colorequiv[256] ;    /* Equivalencia paleta -> pantalla   */
+
 Uint16     colorghost[65536] ;  /* Deja un color a 50% de intensidad */
 
 int palette_loaded = 0 ;
@@ -65,6 +70,7 @@
 
 static int fade_inc = 0 ;
 int        fade_on = 0 ;
+int        fade_set = 0 ;
 int        fade_step = 64 ;
 SDL_Color  fade_from ;
 SDL_Color  fade_to ;
@@ -149,6 +155,161 @@
       252, 52,252, 252,108,252, 252,164,252, 252,220,252
 } ;
 
+void pal_refresh(PALETTE * pal) {
+    PALETTE * p ;
+    int n;
+
+    if (enable_16bits) {
+        if (!pal)
+            p = first_palette;
+        else
+            p = pal ;
+
+        while (p) {
+            for (n = 0 ; n < 256 ; n++)
+                p->colorequiv[n] = SDL_MapRGB (screen->format, p->rgb[n].r, p->rgb[n].g, p->rgb[n].b);
+            p = p->next;
+            if (pal) break;
+        }
+    }
+}
+
+
+void pal_use(PALETTE * pal)
+{
+    if (pal) pal->use++;
+}
+
+int pal_discard(PALETTE * pal)
+{
+    if (!pal) return 0;
+    if (pal->use) pal->use--;
+    return pal->use;
+}
+
+PALETTE * pal_new(PALETTE * basepal)
+{
+    PALETTE * pal = malloc(sizeof(PALETTE));
+
+    if (!pal) return NULL ;
+
+    if (basepal) {
+        memmove(pal->rgb, basepal->rgb, sizeof(pal->rgb)) ;
+        memmove(pal->colorequiv, basepal->colorequiv, sizeof(pal->colorequiv)) ;
+    } else {
+        /* Default */
+        memmove(pal->rgb, palette, sizeof(pal->rgb)) ;
+        if (enable_16bits) {
+            int n;
+            for (n = 0 ; n < 256 ; n++)
+                pal->colorequiv[n] = SDL_MapRGB (screen->format, pal->rgb[n].r, pal->rgb[n].g, pal->rgb[n].b) ;
+        }
+    }
+
+    pal->use        = 1 ;
+    pal->next       = first_palette ;
+    pal->prev       = NULL ;
+    first_palette   = pal ;
+
+    return pal;
+}
+
+PALETTE * pal_new2(unsigned char * datapal)
+{
+    PALETTE * pal = malloc(sizeof(PALETTE));
+    int n;
+
+    if (!pal) return NULL ;
+
+    if (datapal) {
+		for (n = 0 ; n < 256 ; n++)
+		{
+			pal->rgb[n].r = datapal[3*n    ];
+			pal->rgb[n].g = datapal[3*n + 1];
+			pal->rgb[n].b = datapal[3*n + 2];
+		}
+    } else {
+        /* Default */
+        memmove(pal->rgb, palette, sizeof(pal->rgb)) ;
+    }
+
+    if (enable_16bits) {
+        for (n = 0 ; n < 256 ; n++)
+            pal->colorequiv[n] = SDL_MapRGB (screen->format, pal->rgb[n].r, pal->rgb[n].g, pal->rgb[n].b) ;
+    }
+
+    pal->use        = 1 ;
+    pal->next       = first_palette ;
+    pal->prev       = NULL ;
+    first_palette   = pal ;
+
+    return pal;
+}
+
+void pal_destroy(PALETTE * pal)
+{
+    if (!pal) return ;
+
+    if (pal_discard(pal)) return ;
+
+    if (pal->next) pal->next->prev = pal->prev ;
+    if (pal->prev) pal->prev->next = pal->next ;
+
+    if (pal == first_palette) first_palette = pal->next ;
+
+    free (pal);
+}
+
+int pal_get (PALETTE * spal, int color, int num, Uint8 * pal)
+{
+    if (!spal || num < 1 || color < 0 || color > 255) return 0;
+    if (color+num >= 256) num = 256-color ;
+
+    while (num--)
+    {
+        *pal++ = spal->rgb[color  ].r ;
+        *pal++ = spal->rgb[color  ].g ;
+        *pal++ = spal->rgb[color++].b ;
+    }
+    return num;
+}
+
+int pal_set (PALETTE * spal, int color, int num, Uint8 * pal)
+{
+    if (!spal || num < 1 || color < 0 || color > 255) return 0;
+    if (color+num >= 256) num = 256-color ;
+
+    while (num--)
+    {
+        spal->rgb[color  ].r = *pal++ ;
+        spal->rgb[color  ].g = *pal++ ;
+        spal->rgb[color++].b = *pal++ ;
+    }
+    return num;
+}
+
+int pal_map_assign (int libid, int mapcode, PALETTE * palid)
+{
+    GRAPH * bmp = bitmap_get (libid, mapcode) ;
+    PALETTE * oldpal ;
+    if (!bmp || bmp->depth != 8 || !palid) return 0 ;
+    oldpal = bmp->palette ;
+    bmp->palette = palid ;
+    pal_use(bmp->palette) ;
+    if (oldpal) pal_destroy(oldpal) ;
+    return 1 ;
+}
+
+int pal_map_remove (int libid, int mapcode)
+{
+    GRAPH * bmp = bitmap_get (libid, mapcode) ;
+    if (!bmp || bmp->depth != 8) return 0 ;
+    if (bmp->palette) pal_destroy (bmp->palette) ;
+    bmp->palette = NULL ;
+    return 1 ;
+}
+
+/* ---------------------------- */
 
 static void activate_vpalette()
 {
@@ -216,21 +377,24 @@
 
 void gr_fade_init (int r, int g, int b, int speed)
 {
+    if (fade_pos.r == r && fade_pos.g == g && fade_pos.b == b) return;
+
     fade_inc  = speed;
     fade_step = 0;
     fade_on   = 1 ;
     fade_from = fade_pos;
-    fade_to.r = r > 200 ? 200 : r ;
-    fade_to.g = g > 200 ? 200 : g ;
-    fade_to.b = b > 200 ? 200 : b ;
+    fade_to.r = (r > 200) ? 200 : r ;
+    fade_to.g = (g > 200) ? 200 : g ;
+    fade_to.b = (b > 200) ? 200 : b ;
 
     GLODWORD(FADING) = 1 ;
 }
 
 void gr_fade_step()
 {
-    if (fade_on != 0)
+    if (fade_on)
     {
+        fade_set = 1 ;
         GLODWORD(FADING) = 1 ;
 
         fade_step += fade_inc ;
@@ -255,8 +419,16 @@
             (fade_pos.r == 100 && fade_pos.g == 100 && fade_pos.b == 100))
         {
             GLODWORD(FADING) = 0 ;
+            fade_step = 100 ;
             fade_on = 0;
         }
+    }
+
+    if (fade_set)
+    {
+        if (!fade_on && fade_to.r == 100 && fade_to.g == 100 && fade_to.b == 100) {
+            fade_set = 0;
+        }
 
         activate_vpalette() ;
 
@@ -265,15 +437,15 @@
             gr_fade16 (scrbitmap,  fade_pos.r, fade_pos.g, fade_pos.b);
         }
     }
+
 }
 
+#if 0
 int gr_read_pal (file * fp)
 {
-    unsigned char colors[256][3] ;
     int i ;
 
-    if (!file_read (fp, colors, 3 * 256))
-        return 0 ;
+    if (!file_read (fp, colors, 3 * 256)) return 0 ;
 
     /* Ignora definiciones de gama */
     file_seek (fp, 576, SEEK_CUR) ;
@@ -283,16 +455,53 @@
         palette[i].r = colors[i][0] << 2 ;
         palette[i].g = colors[i][1] << 2 ;
         palette[i].b = colors[i][2] << 2 ;
+    }
+
+    palette_loaded = 1 ;
+    palette_changed = 1 ;
+
+    return 1 ;
+    }
+#endif
 
+PALETTE * gr_read_pal (file * fp)
+{
+    int i ;
+    PALETTE * pal;
 
+    if (!file_read (fp, colors, 3 * 256)) return NULL ;
+
+    for (i = 0 ; i < 256 ; i++)
+    {
+        colors[i][0] = colors[i][0] << 2 ;
+        colors[i][1] = colors[i][1] << 2 ;
+        colors[i][2] = colors[i][2] << 2 ;
+        if (!palette_loaded) {
+            palette[i].r = colors[i][0] ;
+            palette[i].g = colors[i][1] ;
+            palette[i].b = colors[i][2] ;
+        }
     }
 
+    pal = pal_new2(colors);
+
     palette_loaded = 1 ;
     palette_changed = 1 ;
 
-    return 1 ;
+    return pal ;
+}
+
+PALETTE * gr_read_pal_with_gamma (file * fp)
+{
+    PALETTE * pal = gr_read_pal (fp);
+
+    /* Ignora definiciones de gama */
+    if (pal) file_seek (fp, 576, SEEK_CUR) ;
+
+    return pal ;
 }
 
+
 /*
  *  FUNCTION : gr_save_pal
  *
@@ -309,7 +518,6 @@
 {
     file * fp = file_open (filename, "wb");
     char header[8] = "pal\x1A\x0D\x0A";
-    unsigned char colors[256][3] ;
     int i;
 
     if (!fp)
@@ -341,18 +549,18 @@
     int r = 0 ;
     int i = 0 ;
 
-    if (!fp) return -1 ;
+    if (!fp) return 0 ;
     file_read (fp, header, 8) ;
     if (strcmp (header, "map\x1A\x0D\x0A") == 0)
     {
         file_seek (fp, 48, SEEK_SET) ;
-        r = gr_read_pal (fp) ;
+        r = gr_read_pal_with_gamma (fp) ;
     }
     else if (strcmp (header, "fpg\x1A\x0D\x0A") == 0 ||
         strcmp (header, "fnt\x1A\x0D\x0A") == 0 ||
         strcmp (header, "pal\x1A\x0D\x0A") == 0)
     {
-        r = gr_read_pal (fp) ;
+        r = gr_read_pal_with_gamma (fp) ;
     }
     else if (memcmp (header, "\x89PNG", 4) == 0)
     {
@@ -361,8 +569,11 @@
         file_close (fp);
         palette_loaded = 0;
         graph = gr_read_png(filename);
-        if (graph) bitmap_destroy(graph);
-        return 1;
+        if (graph) {
+            r = (int) graph->palette;
+            pal_use(graph->palette);
+            bitmap_destroy(graph);
+        }
     }
     else {
         // Soporte para FGC
@@ -374,7 +585,7 @@
             {
                 fgc_error = _("FGC file corrupt or truncated");
                 file_close(fp);
-                return -1;
+                return 0;
             }
             ARRANGE_DWORD(&fgcHeader.version);
             ARRANGE_DWORD(&fgcHeader.depth);
@@ -383,43 +594,42 @@
 
             if (fgcHeader.depth == 8) {
 
-                static unsigned char color_palette[256][3];
-
                 file_seek (fp, fgcHeader.palette, SEEK_SET) ;
+                r = gr_read_pal (fp);
 
 
-                if (file_read(fp, color_palette, 768) != 768) {
+/*
+                if (file_read(fp, colors, 768) != 768) {
                     fgc_error = _("PALETTE - FGC file is truncated");
                     file_close(fp);
-                    return -1;
+                    return 0;
                 }
 
                 for (i = 0 ; i < 256 ; i++) {
-                    palette[i].r = color_palette[i][0];
-                    palette[i].g = color_palette[i][1];
-                    palette[i].b = color_palette[i][2];
+                    palette[i].r = colors[i][0];
+                    palette[i].g = colors[i][1];
+                    palette[i].b = colors[i][2];
 
                 }
                 palette_loaded = 1 ;
                 palette_changed = 1 ;
                 r = 1 ;
+*/
             } else {
                 fgc_error = _("FGC file does not contain information about the colour palette");
                 file_close(fp);
-                return -1;
+                return 0;
             }
         }
         else if (strcmp (header, FBM_MAGIC) == 0) {
             // Soporte para FBM
 
-            static unsigned char color_palette[256][3];
-
             file_seek (fp, 0, SEEK_SET) ;
 
             if (file_read(fp,&fbmHeader,sizeof(FBM_FILE_HEADER)!=sizeof(FBM_FILE_HEADER))) {
                 fbm_error = _("FBM file corrupt or truncated");
                 file_close(fp);
-                return -1;
+                return 0;
             }
 
             ARRANGE_DWORD(&fbmHeader.depth);
@@ -427,27 +637,30 @@
             if (fbmHeader.depth!=8) {
                 fbm_error = _("FBM file does not contain information about the colour palette");
                 file_close(fp);
-                return -1;
+                return 0;
             }
 
             file_seek (fp, sizeof(FBM_FILE_HEADER)+sizeof(FBM_HEADER), SEEK_SET) ;
 
 
-            if (file_read(fp, color_palette, 768) != 768) {
+            r = gr_read_pal (fp);
+/*
+            if (file_read(fp, colors, 768) != 768) {
                 fbm_error = _("PALETTE - FGC file is truncated");
                 file_close(fp);
-                return -1;
+                return 0;
             }
 
             for (i = 0 ; i < 256 ; i++) {
-                palette[i].r = color_palette[i][0];
-                palette[i].g = color_palette[i][1];
-                palette[i].b = color_palette[i][2];
+                palette[i].r = colors[i][0];
+                palette[i].g = colors[i][1];
+                palette[i].b = colors[i][2];
             }
 
             palette_loaded = 1 ;
             palette_changed = 1 ;
             r = 1 ;
+*/
 
         } else if (strcmp (header, FPL_MAGIC) == 0) {
 
@@ -473,9 +686,7 @@
     g >>= screen->format->Gloss ;
     b >>= screen->format->Bloss ;
 
-    color= (r << screen->format->Rshift) |
-           (g << screen->format->Gshift) |
-           (b << screen->format->Bshift) ;
+    color= (r << screen->format->Rshift) | (g << screen->format->Gshift) | (b << screen->format->Bshift) ;
     if (!color) return 1 ;
     return color ;
 }
@@ -530,9 +741,9 @@
     for (n = first ; n <= last ; n++)
     {
         c = &palette[color_list[n]] ;
-        diff =  (key.r > c->r ? key.r-c->r : c->r-key.r)
-             +  (key.g > c->g ? key.g-c->g : c->g-key.g)
-             +  (key.b > c->b ? key.b-c->b : c->b-key.b) ;
+        diff =  ((key.r > c->r) ? key.r-c->r : c->r-key.r)
+             +  ((key.g > c->g) ? key.g-c->g : c->g-key.g)
+             +  ((key.b > c->b) ? key.b-c->b : c->b-key.b) ;
         if (diff < bestdiff) {
             bestdiff = diff ;
             best     = n ;
@@ -740,22 +951,22 @@
     /* Actualiza la paleta */
 
     palette_changed = 0 ;
-
-    if (fade_step != 100)
+/*
+    if (fade_step != 64 && fade_step != 0)
     {
         memcpy (vpalette, palette, sizeof(vpalette)) ;
         activate_vpalette() ;
         background_dirty = 1 ; // Temporal, hasta buscar una solucion mejor
     }
     else
-    {
+    { */
         if (enable_16bits) {
             for (n = 0 ; n < 256 ; n++)
                 colorequiv[n] = SDL_MapRGB (screen->format, palette[n].r, palette[n].g, palette[n].b) ;
         } else {
             SDL_SetColors (screen, palette, 0, 256) ;
         }
-    }
+//    }
 }
 
 void gr_set_rgb (int color, int r, int g, int b)
Index: fxi/src/g_scroll.c
===================================================================
--- fxi/src/g_scroll.c	2007-08-28 14:39:57.000000000 +0200
+++ fxi/src/g_scroll.c	2007-08-28 14:41:14.000000000 +0200
@@ -36,9 +36,6 @@
 
 #include "fxi.h"
 
-#define MIN(a,b) ((a)<(b)?(a):(b))
-#define MAX(a,b) ((a)>(b)?(a):(b))
-
 /* Indicadores de bloqueo */
 #define GRAPH_HWRAP 1
 #define GRAPH_VWRAP 2
Index: fxi/src/g_texts.c
===================================================================
--- fxi/src/g_texts.c	2007-08-28 14:39:57.000000000 +0200
+++ fxi/src/g_texts.c	2007-08-28 14:41:14.000000000 +0200
@@ -84,8 +84,7 @@
 {
       char *p1, *p2;
 
-      if (! str || ! *str)
-            return str;
+      if (! str || ! *str) return str;
       for (p1 = str, p2 = str + strlen(str) - 1; p2 > p1; ++p1, --p2)
       {
             *p1 ^= *p2;
@@ -185,9 +184,7 @@
     if (!str) return 1;
 
 	font = gr_font_get (text->fontid);
-	if (font == NULL) {
-		return 1;
-	}
+	if (!font) return 1;
 
 	/* Calculate the text dimensions */
 
@@ -204,8 +201,7 @@
 
 		for (c = 0 ; c < 256 ; c++)
 		{
-			if (font->glyph[c].bitmap == NULL)
-				continue;
+			if (font->glyph[c].bitmap == NULL) continue;
 			if (font->maxheight < (int)font->glyph[c].bitmap->height + font->glyph[c].yoffset)
 				font->maxheight = (int)font->glyph[c].bitmap->height + font->glyph[c].yoffset;
 		}
@@ -262,21 +258,18 @@
 		case TEXT_FLOAT:
 		case TEXT_INT:
 		case TEXT_DWORD:
-			if (text->last_value == *(int *)text->var)
-				return 0;
+			if (text->last_value == *(int *)text->var) return 0;
 			text->last_value = *(int *)text->var;
 			return 1;
 		case TEXT_BYTE:
 		case TEXT_SBYTE:
 		case TEXT_CHAR:
-			if (text->last_value == *(Uint8 *)text->var)
-				return 0;
+			if (text->last_value == *(Uint8 *)text->var) return 0;
 			text->last_value = *(Uint8 *)text->var;
 			return 1;
 		case TEXT_WORD:
 		case TEXT_SHORT:
-			if (text->last_value == *(Uint16 *)text->var)
-				return 0;
+			if (text->last_value == *(Uint16 *)text->var) return 0;
 			text->last_value = *(Uint16 *)text->var;
 			return 1;
 		case TEXT_CHARARRAY:
@@ -330,8 +323,7 @@
 
 		for (c = 0 ; c < 256 ; c++)
 		{
-			if (font->glyph[c].bitmap == NULL)
-				continue;
+			if (font->glyph[c].bitmap == NULL) continue;
 			if (font->maxheight < (int)font->glyph[c].bitmap->height + font->glyph[c].yoffset)
 				font->maxheight = (int)font->glyph[c].bitmap->height + font->glyph[c].yoffset;
 		}
@@ -374,8 +366,7 @@
 	fntcolor8 = text->color8;
 	fntcolor16 = text->color16;
 
-    if(!gr_text_put (0, clip, text->fontid, x, y, str))
-	    gr_text_destroy(text->id);
+    if(!gr_text_put (0, clip, text->fontid, x, y, str)) gr_text_destroy(text->id);
 
 	fntcolor8 = save8;
 	fntcolor16 = save16;
@@ -619,7 +610,7 @@
 
 	if (fntcolor8 == -1)
 	{
-		gr_setcolor (dest->depth == 8 ? gr_find_nearest_color(255,255,255):gr_rgb(255,255,255));
+		gr_setcolor ((dest->depth == 8) ? gr_find_nearest_color(255,255,255):gr_rgb(255,255,255));
 	}
 	else
 	{
Index: fxi/src/i_debug.c
===================================================================
--- fxi/src/i_debug.c	2007-08-28 14:39:58.000000000 +0200
+++ fxi/src/i_debug.c	2007-08-28 14:41:14.000000000 +0200
@@ -155,7 +155,7 @@
     { "STR2FLOAT", MN_STR2FLOAT, 1 },
     { "FLOAT2STR", MN_FLOAT2STR, 1 },
     { "POINTER2STR", MN_POINTER2STR, 1 },
-    { "POINTER2BOL", MN_POINTER2BOL, 1 },
+//    { "POINTER2BOL", MN_POINTER2BOL, 1 },
 
     { "A2STR", MN_A2STR, 0 },
     { "STR2A", MN_STR2A, 0 },
@@ -238,7 +238,7 @@
     if (dcb.data.NID && dcbproc->data.ID) {
         sprintf (buffer, "%s", getid(dcbproc->data.ID)) ;
     } else {
-        sprintf (buffer, "%s", proc->type == 0 ? "MAIN":"PROC") ;
+        sprintf (buffer, "%s", (proc->type == 0) ? "MAIN":"PROC") ;
     }
 
     line[0] = 0 ;
@@ -283,7 +283,7 @@
             if (dcb.data.NID && dcbproc->data.ID) {
                 sprintf (buffer, "%s", getid(dcbproc->data.ID)) ;
             } else {
-                sprintf (buffer, "%s", proc->type == 0 ? "MAIN":"PROC") ;
+                sprintf (buffer, "%s", (proc->type == 0) ? "MAIN":"PROC") ;
             }
 
             line[0] = 0 ;
Index: fxi/src/i_func.c
===================================================================
--- fxi/src/i_func.c	2007-08-28 14:41:05.000000000 +0200
+++ fxi/src/i_func.c	2007-08-28 14:41:15.000000000 +0200
@@ -173,10 +173,10 @@
 
 static int fxi_rand (INSTANCE * my, int * params)
 {
-    int num1 = params[0] ;
-    int num2 = params[1] ;
+    int num1 = MIN(params[0], params[1]) ;
+    int num2 = MAX(params[0], params[1]) ;
 
-    return num1 + (int)(((double)(num2-num1+1) * rand()) / (RAND_MAX+1.0)) ;
+    return num1 + (rand()%(num2-num1+1)) ;
 }
 
 static int fxi_rand_seed (INSTANCE * my, int * params)
@@ -188,7 +188,7 @@
 static int fxi_abs (INSTANCE * my, int * params)
 {
     float num = *(float *)&params[0] ;
-    float res = num < 0 ? -num:num ;
+    float res = (num < 0) ? -num:num ;
     return *(int *)&res ;
 }
 
@@ -204,11 +204,11 @@
     double dy = params[3] - params[1] ;
     int angle ;
 
-    if (dx == 0) return dy > 0 ? 270000 : 90000 ;
+    if (dx == 0) return (dy > 0) ? 270000L : 90000L ;
 
     angle = (int) (atan(dy / dx) * 180000.0 / M_PI) ;
 
-    return dx > 0 ? -angle:-angle+180000 ;
+    return (dx > 0) ? -angle:-angle+180000L ;
 }
 
 static int fxi_fget_dist (INSTANCE * my, int * params)
@@ -225,11 +225,11 @@
     int dest  = params[1] ;
     int incr  = params[2] ;
 
-    if (angle < dest && dest-angle > 180000)
-        angle += 360000 ;
+    if (angle < dest && dest-angle > 180000L)
+        angle += 360000L ;
 
-    if (angle > dest && angle-dest > 180000)
-        angle -= 360000 ;
+    if (angle > dest && angle-dest > 180000L)
+        angle -= 360000L ;
 
     if (angle < dest)
     {
@@ -242,8 +242,8 @@
         if (angle < dest) angle = dest ;
     }
 
-    if (angle < 0) return angle + 360000 ;
-    if (angle >= 360000) return angle - 360000 ;
+    if (angle < 0) return angle + 360000L ;
+    if (angle >= 360000L) return angle - 360000L ;
     return angle ;
 }
 
@@ -397,7 +397,7 @@
             if (instance_visible(i))
                 gr_mark_instance(i);
 
-            switch (params[1] >= 100 ? params[1]-100 : params[1])
+            switch ((params[1] >= 100) ? params[1]-100 : params[1])
             {
                 case 0:     /* S_KILL */
                     LOCDWORD(i, STATUS) = (LOCDWORD(i, STATUS) & STATUS_WAITING_MASK) | STATUS_KILLED ;
@@ -516,6 +516,7 @@
 
     if (!params[0])
     {
+        LOCDWORD(my, TYPE_SCAN) = 0 ;
         if (LOCDWORD(my, ID_SCAN))
         {
             ptr = instance_get (LOCDWORD(my,ID_SCAN)) ;
@@ -530,10 +531,10 @@
             }
             ptr = ptr->next ;
         }
-        LOCDWORD(my,ID_SCAN) = 0 ;
         return 0 ;
     }
 
+    LOCDWORD(my, ID_SCAN) = 0 ;
     if (LOCDWORD(my,TYPE_SCAN))
     {
         ptr = instance_get (LOCDWORD(my,TYPE_SCAN)) ;
@@ -554,7 +555,6 @@
         }
         ptr = ptr->next ;
     }
-    LOCDWORD(my,TYPE_SCAN) = 0 ;
     return 0 ;
 }
 
@@ -709,13 +709,14 @@
 
     scalex = LOCDWORD(i,GRAPHSIZEX);
     scaley = LOCDWORD(i,GRAPHSIZEY);
-    if (scalex == 100 && scaley == 100)
-        scalex = scaley = LOCDWORD(i,GRAPHSIZE);
+    if (scalex == 100 && scaley == 100) scalex = scaley = LOCDWORD(i,GRAPHSIZE);
 
     map = instance_graph (i) ;
     if (!map) return ;
+
     // PATCH - XGRAPH DOES NOT ROTATE DESTINATION GRAPHIC
-    if (LOCDWORD(i,ANGLE) || scaley != 100 || scalex != 100) {
+    if ((map->current_keyframe >= 0 && map->keyframes[map->current_keyframe].angle) ||
+        LOCDWORD(i,ANGLE) || scaley != 100 || scalex != 100) {
         if (LOCDWORD(i,XGRAPH) && scalex == 100 && scaley == 100) {
             gr_blit (dest, r, x, y, LOCDWORD(i,FLAGS), map) ;
         } else {
@@ -785,10 +786,8 @@
 
     /* Creates a temporary bitmap (only once) */
 
-    if (!bmp)
-        bmp = bitmap_new (0, 2, 2, enable_16bits ? 16:8, 1) ;
-    if (!bmp)
-        return 0 ;
+    if (!bmp) bmp = bitmap_new (0, 2, 2, enable_16bits ? 16:8, 1) ;
+    if (!bmp) return 0 ;
     memset (bmp->data, 0, 2) ;
 
     /* Retrieves process information */
@@ -810,11 +809,9 @@
             {
                 REGION * r = scrolls[i].region;
 
-                if (r->x > mx || r->x2 < mx || r->y > my || r->y2 < my)
-                    continue;
+                if (r->x > mx || r->x2 < mx || r->y > my || r->y2 < my) continue;
                 draw_at (bmp, x+r->x-mx-scrolls[i].posx0, y+r->y-my-scrolls[i].posy0, &bbox1, proc1);
-                if (enable_16bits ? *(Uint16 *)bmp->data : *(Uint8 *)bmp->data)
-                    return 1;
+                if (enable_16bits ? *(Uint16 *)bmp->data : *(Uint8 *)bmp->data) return 1;
             }
         }
         return 0;
@@ -856,8 +853,8 @@
         bitmap_destroy (bmp) ;
         return 0;
     }
-    memset (bmp->data, 0, w*h*(depth == 16?2:1)) ;
-    memset (bmp2->data, 0, w*h*(depth == 16?2:1)) ;
+    memset (bmp->data, 0, w*h*((depth == 16)?2:1)) ;
+    memset (bmp2->data, 0, w*h*((depth == 16)?2:1)) ;
 
     get_pos (proc1, &x, &y) ;
     x -= bbox1.x ;
@@ -919,20 +916,18 @@
 {
     INSTANCE * ptr = instance_get(params[0]) ;
 
-    if (params[0] == -1)
-        return check_collision_with_mouse(my) ? 1:0 ;
+    if (params[0] == -1) return (check_collision_with_mouse(my)) ? 1 : 0 ;
 
     /* ADDED IN 0.74 - Checks only for a single instance */
-    /*DEBUG*/
 
-    if (params[0] >= FIRST_INSTANCE_ID && ptr)
-        return check_collision(my,ptr) ;
+    if (params[0] >= FIRST_INSTANCE_ID && ptr) return check_collision(my,ptr) ;
 
     /* we must use full list of instances or get types from it */
     ptr = first_instance ;
 
     if (!params[0])
     {
+        LOCDWORD(my, TYPE_SCAN) = 0 ;
         if (LOCDWORD(my, ID_SCAN))
         {
             ptr = instance_get (LOCDWORD(my, ID_SCAN)) ;
@@ -954,17 +949,18 @@
             }
             ptr = ptr->next ;
         }
-        LOCDWORD (my, ID_SCAN) = 0 ;
         return 0 ;
     }
 
+    LOCDWORD (my, ID_SCAN) = 0 ;
     if (LOCDWORD(my,TYPE_SCAN))
     {
         ptr = instance_get (LOCDWORD(my,TYPE_SCAN)) ;
-        if (ptr && LOCDWORD(ptr,PROCESS_TYPE) != params[0]) ptr = first_instance ;
-        else if (ptr) ptr = ptr->next ;
+        if (ptr && LOCDWORD(ptr, PROCESS_TYPE) != params[0])
+            ptr = first_instance ;
+        else if (ptr)
+            ptr = ptr->next ;
     }
-
     while (ptr)
     {
         if (LOCDWORD(ptr,PROCESS_TYPE) == params[0] && ptr != my)
@@ -979,7 +975,6 @@
         }
         ptr = ptr->next ;
     }
-    LOCDWORD(my,TYPE_SCAN) = 0 ;
     return 0 ;
 }
 
@@ -1033,7 +1028,7 @@
     if (params[0]>1600 || params[1]>1400)
         gr_error (_("Unsupported graphic mode"));
 
-    GLODWORD(GRAPH_MODE) = ((GLODWORD(GRAPH_MODE) & 0xFF) | params[2]);
+    GLODWORD(GRAPH_MODE) = ((GLODWORD(GRAPH_MODE) & 0xFF00) | params[2]);
     gr_init(params[0], params[1]) ;
     return 1 ;
 }
@@ -1165,10 +1160,71 @@
 
 /* Paleta de colores */
 
+
+static int fxi_pal_create (INSTANCE * my, int * params)
+{
+    return (int) pal_new((PALETTE *)NULL) ;
+}
+
+static int fxi_pal_clone (INSTANCE * my, int * params)
+{
+    return (int) pal_new((PALETTE *)(params[0])) ;
+}
+
+static int fxi_pal_unload (INSTANCE * my, int * params)
+{
+    pal_destroy((PALETTE *)(params[0])) ;
+    return 1;
+}
+
+static int fxi_pal_refresh (INSTANCE * my, int * params)
+{
+    pal_refresh(NULL) ;
+    return 1;
+}
+
+static int fxi_pal_refresh_2 (INSTANCE * my, int * params)
+{
+    pal_refresh((PALETTE *)(params[0]));
+    return 1;
+}
+
+static int fxi_pal_map_assign (INSTANCE * my, int * params)
+{
+    return pal_map_assign (params[0], params[1], (PALETTE *)(params[2]));
+}
+
+static int fxi_pal_map_remove (INSTANCE * my, int * params)
+{
+    return pal_map_remove (params[0], params[1]);
+}
+
+static int fxi_pal_map_getid (INSTANCE * my, int * params)
+{
+    GRAPH * bmp = bitmap_get (params[0], params[1]) ;
+    if (!bmp || bmp->depth != 8) return 0 ;
+    return (int) bmp->palette ;
+}
+
+static int fxi_pal_set (INSTANCE * my, int * params)
+{
+    return (pal_set ((PALETTE *)(params[0]), params[1], params[2], (Uint8 *)params[3])) ;
+}
+
+static int fxi_pal_get (INSTANCE * my, int * params)
+{
+    return (pal_get ((PALETTE *)(params[0]), params[1], params[2], (Uint8 *)params[3])) ;
+}
+
+
 static int fxi_load_fpl (INSTANCE * my, int * params)
 {
     const char * palname = string_get (params[0]) ;
-    int r = palname ? fpl_load(palname) : 0 ;
+    int r ;
+    int old_palette_loaded = palette_loaded ;
+    palette_loaded = 0 ;
+    r = palname ? fpl_load(palname) : 0 ;
+    if (!r) palette_loaded = old_palette_loaded ;
     string_discard (params[0]) ;
     return r ;
 }
@@ -1184,7 +1240,11 @@
 static int fxi_load_pal (INSTANCE * my, int * params)
 {
     const char * palname = string_get (params[0]) ;
-    int r = palname ? gr_load_pal(palname) : 0 ;
+    int r ;
+    int old_palette_loaded = palette_loaded ;
+    palette_loaded = 0 ;
+    r = palname ? gr_load_pal(palname) : 0 ;
+    if (!r) palette_loaded = old_palette_loaded ;
     string_discard (params[0]) ;
     return r ;
 }
@@ -1663,7 +1723,7 @@
         background_8bits_used = 0;
     }
 
-    if (params[4] == 0 && params[5] == 100)
+    if (params[4] == 0 && params[5] == 100 && !(map->current_keyframe >= 0 && map->keyframes[map->current_keyframe].angle))
     {
         gr_blit (background, &regions[r], params[2], params[3], params[6], map) ;
         return 0 ;
@@ -1841,7 +1901,7 @@
     GRAPH * dest = bitmap_get (params[0], params[1]) ;
     GRAPH * orig = bitmap_get (params[0], params[2]) ;
 
-    if (params[5] == 0 && params[6] == 100)
+    if (params[5] == 0 && params[6] == 100 && !(orig->current_keyframe >= 0 && orig->keyframes[orig->current_keyframe].angle))
         gr_blit (dest, 0, params[3], params[4], params[7], orig) ;
     else
         gr_rotated_blit (dest, 0, params[3], params[4], params[7], params[5], params[6], params[6], orig) ;
@@ -1857,7 +1917,7 @@
     GRAPH * dest = bitmap_get (params[0], params[1]) ;
     GRAPH * orig = bitmap_get (params[2], params[3]) ;
 
-    if (params[6] == 0 && params[7] == 100 && params[8] == 100)
+    if (params[6] == 0 && params[7] == 100 && params[8] == 100 && !(orig->current_keyframe >= 0 && orig->keyframes[orig->current_keyframe].angle))
         gr_blit (dest, 0, params[4], params[5], params[9], orig) ;
     else
         gr_rotated_blit (dest, 0, params[4], params[5], params[9], params[6], params[7], params[8], orig) ;
@@ -2108,8 +2168,7 @@
     GRAPH * map ;
     unsigned char c = params[1];
 
-    if (font->charset == CHARSET_CP850)
-        c = win_to_dos[c];
+    if (font->charset == CHARSET_CP850) c = win_to_dos[c];
 
     if (!scr_initialized) gr_init (320, 200) ;
     if (!font) return 0;
@@ -2133,13 +2192,11 @@
     GRAPH * map  = bitmap_get(params[2], params[3]);
     unsigned char c = params[1];
 
-    if (font->charset == CHARSET_CP850)
-        c = win_to_dos[c];
+    if (font->charset == CHARSET_CP850) c = win_to_dos[c];
 
     if (font && map)
     {
-        if (font->glyph[c].bitmap)
-            bitmap_destroy (font->glyph[c].bitmap);
+        if (font->glyph[c].bitmap) bitmap_destroy (font->glyph[c].bitmap);
         font->glyph[c].bitmap = bitmap_clone(map);
         if (map->ncpoints >= 3 && map->cpoints)
         {
@@ -2401,11 +2458,49 @@
 
 static int fxi_fputs (INSTANCE * my, int * params)
 {
-    int r = file_puts ((file *)params[0], string_get(params[1])) ;
+    char *str = string_get(params[1]);
+    int r = file_puts ((file *)params[0], str) ;
+    if (str[strlen(str)-1] != '\n') file_puts ((file *)params[0], "\r\n") ;
+/*    int r = file_puts ((file *)params[0], string_get(params[1])) ; */
     string_discard(params[1]) ;
     return r ;
 }
 
+static int fxi_fgets (INSTANCE * my, int * params)
+{
+    char buffer[1024] ;
+    int str, str2 = 0, str3 ;
+    int len, sigue = 1 ;
+
+    while(sigue)
+    {
+        len = file_gets ((file *)params[0], buffer, sizeof(buffer)) ;
+        if (len < 1)
+            sigue = 0 ;
+        else {
+            if (buffer[len-1] == '\n')
+            {
+                len-- ;
+                buffer[len] = '\0' ;
+                sigue = 0 ;
+            }
+            if (buffer[len-1] == '\r') buffer[len-1] = '\0' ;
+        }
+        str = string_new (buffer) ;
+        if (str2)
+        {
+            str3 = string_add (str2, str) ;
+            string_discard (str) ;
+            string_discard (str2) ;
+            str2 = str3 ;
+        }
+        else
+            str2 = str ;
+    }
+    string_use (str2) ;
+    return str2 ;
+}
+
 static int fxi_file (INSTANCE * my, int * params)
 {
     char buffer[1024] ;
@@ -2430,39 +2525,6 @@
     return str ;
 }
 
-static int fxi_fgets (INSTANCE * my, int * params)
-{
-    char buffer[1024] ;
-    int str, str2 = 0, str3 ;
-    int len, sigue ;
-
-    for (;;)
-    {
-        file_gets ((file *)params[0], buffer, sizeof(buffer)) ;
-        len = strlen(buffer) ;
-        if (len > 1 && buffer[len-1] == '\n' && buffer[len-2] == '\\')
-        {
-            buffer[len-2] = 0 ;
-            sigue = 1 ;
-        }
-        else    sigue = 0 ;
-
-        str = string_new (buffer) ;
-        if (str2)
-        {
-            str3 = string_add (str2, str) ;
-            string_discard (str) ;
-            string_discard (str2) ;
-            str2 = str3 ;
-        }
-        else    str2 = str ;
-
-        if (!sigue) break ;
-    }
-    string_use (str2) ;
-    return str2 ;
-}
-
 static int fxi_feof (INSTANCE * my, int * params)
 {
     return file_eof ((file *)params[0]) ;
@@ -3992,9 +4054,9 @@
                 }
             }
             r1/=tabla[9];g1/=tabla[9];b1/=tabla[9];
-            r=((int)r1)>255?255:(int)r1;
-            g=((int)g1)>255?255:(int)g1;
-            b=((int)b1)>255?255:(int)b1;
+            r=(((int)r1)>255)?255:(int)r1;
+            g=(((int)g1)>255)?255:(int)g1;
+            b=(((int)b1)>255)?255:(int)b1;
 
             if(r<0)r=0;
             if(g<0)g=0;
@@ -4831,7 +4893,7 @@
     }
 
     stat (globd.gl_pathv[currentFile], &s);
-    gr_con_printf (_("%s (size %d) is %s"), globd.gl_pathv[currentFile], s.st_size, S_ISDIR(s.st_mode) ? _("a directory"):_("a file"));
+    gr_con_printf (_("%s (size %d) is %s"), globd.gl_pathv[currentFile], s.st_size, (S_ISDIR(s.st_mode)) ? _("a directory"):_("a file"));
 
     /* Store the file name and path */
     if (GLODWORD(FILE_NAME))
@@ -4862,7 +4924,7 @@
     }
 
     /* Store integer and boolean variables */
-    GLODWORD(FILE_DIRECTORY) = (S_ISDIR(s.st_mode) ? 1:0);
+    GLODWORD(FILE_DIRECTORY) = ((S_ISDIR(s.st_mode)) ? 1:0);
     GLODWORD(FILE_HIDDEN)    = (*ptr == '.');
     GLODWORD(FILE_READONLY)  = !(s.st_mode & 0444);
     GLODWORD(FILE_SIZE)      = s.st_size;
Index: fxi/src/i_main.c
===================================================================
--- fxi/src/i_main.c	2007-08-28 14:39:59.000000000 +0200
+++ fxi/src/i_main.c	2007-08-28 14:41:15.000000000 +0200
@@ -182,7 +182,7 @@
 	return result;
 }
 
-/*static */void freestrings(PROCDEF * proc, int * data)
+void freestrings(PROCDEF * proc, int * data)
 {
     // Splinter, descarto todas las strings privadas
     int i, s = 0, r;
@@ -211,54 +211,52 @@
             if (must_exit) break ;
 
         } else {
-            if (!last_instance_run) {
-                /* Ejecuta uno a uno todos los procesos */
-                i_count = 0 ;
-            }
-
-            while (1)
-            {
-                if (last_instance_run && instance_exists(last_instance_run)) {
+            if (last_instance_run) {
+                if (instance_exists(last_instance_run)) {
                     i = last_instance_run;
                 } else {
                     last_instance_run = NULL;
                     i = instance_next_by_priority();
-                    if (!i) break;
                 }
-                if (LOCDWORD(i, STATUS) == STATUS_KILLED ||
-                    LOCDWORD(i, STATUS) == STATUS_DEAD   ||
+            } else {
+                i = instance_next_by_priority();
+                i_count = 0 ;
+            }
+
+            while (i)
+            {
+                if (LOCDWORD(i, STATUS) == STATUS_KILLED || LOCDWORD(i, STATUS) == STATUS_DEAD ||
                     last_instance_run)
                 {
+                    // Run instance
+                } else if (LOCDWORD(i, STATUS) == STATUS_RUNNING && LOCDWORD(i, FRAME_PERCENT) < 100) {
+                    LOCDWORD(i, TYPE_SCAN) = 0;
+                    LOCDWORD(i, ID_SCAN) = 0;
+                } else {
+                    i = instance_next_by_priority();
                     last_instance_run = NULL;
-
-                    instance_go (i);
-
-                    if (force_debug || must_exit) break;
                     continue;
                 }
 
-                last_instance_run = NULL;
-
-                if (LOCDWORD(i, STATUS) != STATUS_RUNNING) continue;
+                i_count++;
 
-                if (LOCDWORD(i, FRAME_PERCENT) < 100) {
-                    LOCDWORD(i, TYPE_SCAN) = 0;
-                    LOCDWORD(i, ID_SCAN) = 0;
+                last_instance_run = NULL;
 
                     instance_go (i);
 
-                    if (force_debug || must_exit) break;
-                    i_count++;
-                }
+                if (force_debug) {
+                    show_console = 1;
+                    last_instance_run  = trace_instance;
+                    break;
             }
 
             if (must_exit) break ;
 
-            if (force_debug) {
-                show_console = 1;
-                last_instance_run  = trace_instance;
+                i = instance_next_by_priority();
             }
 
+            if (must_exit) break ;
+
             /* Si no se ejecutó nada: Dibujar, actualizar variables, etc. */
 
             if (!i_count && !force_debug)
@@ -290,8 +288,7 @@
                     i = next ;
                 }
 
-                if (!first_instance)
-                    break ;
+                if (!first_instance) break ;
 
                 /* Dibuja el frame */
 
@@ -326,8 +323,7 @@
 
 int instance_go (INSTANCE * r)
 {
-    if (!r)
-        return 0 ;
+    if (!r) return 0 ;
 
     register int * ptr = r->codeptr ;
     register int * stack_ptr = stack_gptr ;
@@ -335,10 +331,10 @@
     int n ;
     int return_value = LOCDWORD(r, PROCESS_ID) ;
     int was_visible;
-    SYSPROC * p ;
-    INSTANCE * i ;
-    PROCDEF * proc = r->proc, * aproc ;
-    static char buffer[16], * str ;
+    SYSPROC * p = NULL ;
+    INSTANCE * i = NULL ;
+    PROCDEF * proc = r->proc;
+    static char buffer[16], * str = NULL ;
 
     /* This variable contains a pointer to the private area at the stack.
        It is 0 if the current process uses the instance's private area instead */
@@ -353,17 +349,22 @@
 
     /* ------------------------------------------------------------------------------- */
     /* Restauro si salio por debug */
+#if 0
     if (r->inpridata) {
         private_data = r->inpridata;
         base_code = r->inproc->code;
         proc = r->inproc;
     }
+#endif
+
+    switchval = r->switchval;
+    switchval_string = r->switchval_string;
+    cased = r->cased;
 
     if (r->stack)
     {
         /* Restore a saved stack, if present */
-        if ((*r->stack) & STACK_SIZE_MASK)
-            memcpy (stack_ptr, r->stack+1, *r->stack * 4);
+        if ((*r->stack) & STACK_SIZE_MASK) memcpy (stack_ptr, r->stack+1, ((*r->stack) & STACK_SIZE_MASK) * 4);
         stack_ptr += ((*r->stack) & STACK_SIZE_MASK);
         free (r->stack);
         r->stack = NULL;
@@ -385,7 +386,11 @@
 
     trace_sentence = -1;
 
-    while(!must_exit && (LOCDWORD(r, STATUS) & STATUS_WAITING_MASK) != STATUS_KILLED)
+    while(!must_exit /*&&
+          (LOCDWORD(r, STATUS) == STATUS_RUNNING ||
+           LOCDWORD(r, STATUS) == STATUS_DEAD) &&
+          !(LOCDWORD(r, STATUS) & STATUS_WAITING_MASK)
+         */)
     {
         if (debug_next && trace_sentence != -1) {
             force_debug = 1;
@@ -393,11 +398,16 @@
             r->codeptr = ptr ;
             stack_gptr = stack_ptr ;
             return_value = LOCDWORD(r, PROCESS_ID);
-
+#if 0
             if (private_data != r->pridata) {
                 r->inpridata = private_data;
                 r->inproc = proc;
             }
+#endif
+            r->switchval = switchval;
+            r->switchval_string = switchval_string;
+            r->cased = cased;
+
             break;
         }
 
@@ -462,11 +472,12 @@
 
             case MN_CALL:
             case MN_PROC:
-                aproc = procdef_get (ptr[1]) ;
-                if (!aproc) gr_error ("Error: Procedimiento desconocido\n") ;
-                proc = aproc;
+                proc = procdef_get (ptr[1]) ;
+                if (!proc) gr_error ("Error: Procedimiento desconocido\n") ;
 
+#if 0
                 if (proc->flags & (PROC_USES_FRAME | PROC_USES_LOCALS | PROC_USES_PUBLICS))
+#endif
                 {
                     /* Process uses FRAME or locals, must create an instance */
                     i = instance_new (proc, r) ;
@@ -483,7 +494,8 @@
                     LOCDWORD(r,STATUS) |= STATUS_WAITING_MASK;
                     i->called_by   = r;
 
-                    /* Ejecuto la funcion/processo... */
+                    // Ejecuto la funcion/processo...
+
                     if (*ptr == MN_CALL) {
                         *stack_ptr++ = instance_go (i);
                     } else {
@@ -499,7 +511,12 @@
                     /* If the process is a function in a frame, save the stack and leave */
                     /* Si sigue corriendo la funcion/proceso que lance, es porque esta en un frame.
                        Si esta ejecutando codigo, es porque su STATUS es RUNNING */
-                    if (child_is_alive && LOCDWORD(r,STATUS) & STATUS_WAITING_MASK)
+                    if (child_is_alive &&
+                        ((LOCDWORD(r,STATUS) & STATUS_WAITING_MASK) ||
+                         (LOCDWORD(r,STATUS) & ~STATUS_WAITING_MASK) == STATUS_FROZEN ||
+                         (LOCDWORD(r,STATUS) & ~STATUS_WAITING_MASK) == STATUS_SLEEPING
+                        )
+                       )
                     {
                         /* En este caso me pongo a dormir y retorno */
                         i->called_by   = r;
@@ -516,7 +533,7 @@
                         /* Esta instancia no va a ejecutar otro codigo hasta que retorne el hijo */
                         r->codeptr = ptr ;
 
-                        /* Apunto global stack a stack_begin (inicio de mi stack) */
+                        /* Apunto global stack a stack_begin (inicio del stack original) */
                         stack_gptr = stack_begin;
 
                         /* Si no fue un call, seteo un flag en la len para no retornar valor */
@@ -538,6 +555,7 @@
                     }
                     proc = r->proc;
                 }
+#if 0
                 else
                 {
                     /* This process can be called locally: create a private memory area using the stack */
@@ -561,6 +579,7 @@
                     *stack_ptr++ = (Sint32) old_data;               //                    (stack_ptr[-2] in return)
                     base_code = ptr = proc->code;
                 }
+#endif
                 break ;
 
             case MN_SYSCALL:
@@ -639,7 +658,7 @@
             case MN_REMOTE | MN_STRING:
             case MN_REMOTE | MN_FLOAT:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = (int) &LOCDWORD(i, ptr[1]) ;
@@ -655,7 +674,7 @@
             case MN_REMOTE_PUBLIC | MN_STRING:
             case MN_REMOTE_PUBLIC | MN_FLOAT:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = (int) &PUBDWORD(i, ptr[1]) ;
@@ -696,7 +715,7 @@
             case MN_GET_REMOTE | MN_FLOAT:
             case MN_GET_REMOTE | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = LOCDWORD(i,ptr[1]) ;
@@ -707,7 +726,7 @@
             case MN_GET_REMOTE_PUBLIC | MN_FLOAT:
             case MN_GET_REMOTE_PUBLIC | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = PUBDWORD(i,ptr[1]) ;
@@ -755,7 +774,7 @@
 
             case MN_GET_REMOTE | MN_STRING:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = LOCDWORD(i,ptr[1]) ;
@@ -765,7 +784,7 @@
 
             case MN_GET_REMOTE_PUBLIC | MN_STRING:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = PUBDWORD(i,ptr[1]) ;
@@ -830,7 +849,7 @@
             case MN_WORD | MN_GET_REMOTE:
             case MN_WORD | MN_GET_REMOTE | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = LOCWORD(i,ptr[1]) ;
@@ -840,7 +859,7 @@
             case MN_WORD | MN_GET_REMOTE_PUBLIC:
             case MN_WORD | MN_GET_REMOTE_PUBLIC | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = PUBWORD(i,ptr[1]) ;
@@ -853,11 +872,11 @@
                 ptr++ ;
                 break ;
 
-            case MN_WORD | MN_NOT:
+/*            case MN_WORD | MN_NOT:
             case MN_WORD | MN_NOT | MN_UNSIGNED:
                 stack_ptr[-1] = !(stack_ptr[-1]) ;
                 ptr++ ;
-                break ;
+                break ; */
 
             /* Acceso a variables tipo BYTE */
 
@@ -903,7 +922,7 @@
 
             case MN_BYTE | MN_GET_REMOTE:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = (signed char) LOCBYTE(i,ptr[1]) ;
@@ -912,7 +931,7 @@
 
             case MN_BYTE | MN_GET_REMOTE | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = LOCBYTE(i,ptr[1]) ;
@@ -921,7 +940,7 @@
 
             case MN_BYTE | MN_GET_REMOTE_PUBLIC:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = (signed char) PUBBYTE(i,ptr[1]) ;
@@ -930,7 +949,7 @@
 
             case MN_BYTE | MN_GET_REMOTE_PUBLIC | MN_UNSIGNED:
                 i = instance_get (stack_ptr[-1]) ;
-                if (i == 0)
+                if (!i)
                     gr_error (_("Error executing process %s (%d): Inactive procedure %d\n"), proc->name, LOCDWORD(r,PROCESS_ID), stack_ptr[-1]) ;
                 else
                     stack_ptr[-1] = PUBBYTE(i,ptr[1]) ;
@@ -947,11 +966,11 @@
                 ptr++ ;
                 break ;
 
-            case MN_BYTE | MN_NOT:
+/*            case MN_BYTE | MN_NOT:
             case MN_BYTE | MN_NOT | MN_UNSIGNED:
                 stack_ptr[-1] = !(stack_ptr[-1]) ;
                 ptr++ ;
-                break ;
+                break ; */
 
             /* Operaciones matemáticas  en coma floatante */
 
@@ -1098,121 +1117,101 @@
             /* Operaciones a nivel de bit */
 
             case MN_ROR:
-//                (Sint32)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Sint32)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_ROR | MN_UNSIGNED:
-//                (Uint32)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 stack_ptr[-2] = (Uint32)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_WORD | MN_ROR:
-//                (Sint16)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 stack_ptr[-2] = (Sint16)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_WORD | MN_ROR | MN_UNSIGNED:
-//                (Uint16)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 stack_ptr[-2] = (Uint16)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BYTE | MN_ROR:
-//                (Sint8)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 stack_ptr[-2] = (Sint8)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BYTE | MN_ROR | MN_UNSIGNED:
-//                (Uint8)(stack_ptr[-2]) >>= stack_ptr[-1] ;
                 stack_ptr[-2] = (Uint8)(stack_ptr[-2]) >> stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_ROL:
-//                (Sint32)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Sint32)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
+
             /* Todos estos ROL siguientes no serian necesarios, pero bueno... */
             case MN_ROL | MN_UNSIGNED:
-//                (Uint32)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Uint32)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_WORD | MN_ROL:
-//                (Sint16)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Sint16)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_WORD | MN_ROL | MN_UNSIGNED:
-//                (Uint16)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Uint16)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BYTE | MN_ROL:
-//                (Sint8)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Sint8)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BYTE | MN_ROL | MN_UNSIGNED:
-//                (Uint8)(stack_ptr[-2]) <<= stack_ptr[-1] ;
                 (stack_ptr[-2]) = (Uint8)(stack_ptr[-2]) << stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
-/*
-            case MN_ROL:
-                stack_ptr[-2] >>= stack_ptr[-1] ;
-                stack_ptr-- ;
-                ptr++ ;
-                break ;
-
-            case MN_ROL:
-                stack_ptr[-2] <<= stack_ptr[-1] ;
-                stack_ptr-- ;
-                ptr++ ;
-                break ;
-*/
             case MN_BAND:
+            case MN_BAND | MN_UNSIGNED:
                 stack_ptr[-2] &= stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BOR:
+            case MN_BOR | MN_UNSIGNED:
                 stack_ptr[-2] |= stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BXOR:
+            case MN_BXOR | MN_UNSIGNED:
                 stack_ptr[-2] ^= stack_ptr[-1] ;
                 stack_ptr-- ;
                 ptr++ ;
                 break ;
 
             case MN_BNOT:
+            case MN_BNOT | MN_UNSIGNED:
                 stack_ptr[-1] = ~(stack_ptr[-1]) ;
                 ptr++ ;
                 break ;
@@ -1495,21 +1494,23 @@
                 string_use (stack_ptr[-ptr[1]-1]) ;
                 ptr += 2 ;
                 break ;
-
+/*
             case MN_POINTER2BOL:
-                stack_ptr[-ptr[1]-1] = stack_ptr[-ptr[1]-1] ? 1:0 ;
+                stack_ptr[-ptr[1]-1] = (stack_ptr[-ptr[1]-1]) ? 1:0 ;
                 ptr += 2 ;
                 break ;
-
+*/
             case MN_STR2FLOAT:
-                n = stack_ptr[-ptr[1]-1] ; str = (char *)string_get(n) ;
+                n = stack_ptr[-ptr[1]-1] ;
+                str = (char *)string_get(n) ;
                 *(float *)(&stack_ptr[-ptr[1]-1]) = str ? (float)atof(str) : 0.0f ;
                 string_discard (n) ;
                 ptr += 2 ;
                 break ;
 
             case MN_STR2INT:
-                n = stack_ptr[-ptr[1]-1] ; str = (char *)string_get(n) ;
+                n = stack_ptr[-ptr[1]-1] ;
+                str = (char *)string_get(n) ;
                 stack_ptr[-ptr[1]-1] = str ? atoi(str) : 0 ;
                 string_discard (n) ;
                 ptr += 2 ;
@@ -2035,8 +2036,7 @@
                 break ;
 
             case MN_SWITCH | MN_STRING:
-                if (switchval_string != 0)
-                    string_discard (switchval_string);
+                if (switchval_string != 0) string_discard (switchval_string);
                 switchval_string = *--stack_ptr;
                 cased = 0;
                 ptr++;
@@ -2099,11 +2099,9 @@
                 stack_gptr = stack_ptr ;
                 return_value = LOCDWORD(r, PROCESS_ID);
 
-                if (r->called_by &&
-                    instance_exists(r->called_by) &&
-                    (LOCDWORD(r->called_by, STATUS) & STATUS_WAITING_MASK) &&
-                    !(r->proc->flags & PROC_FUNCTION)
-                   )
+                if (!(r->proc->flags & PROC_FUNCTION) &&
+                    r->called_by && instance_exists(r->called_by) &&
+                    (LOCDWORD(r->called_by, STATUS) & STATUS_WAITING_MASK))
                 {
                     /* We're returning and the parent is waiting: wake it up */
                     if (r->called_by->stack && !(r->called_by->stack[0] & STACK_NO_RETURN_VALUE)) {
@@ -2116,28 +2114,30 @@
                 goto break_all ;
 
             case MN_END:
+#if 0
                 if (private_data == r->pridata) /* Esto es una nueva instancia */
+#endif
                 {
-                    if (LOCDWORD (r,STATUS) != STATUS_DEAD)
-                        LOCDWORD (r,STATUS) = STATUS_KILLED ;
+                    if (LOCDWORD(r,STATUS) != STATUS_DEAD) LOCDWORD(r,STATUS) = STATUS_KILLED ;
                     stack_gptr = stack_ptr ;
                     goto break_all ;
                 }
-
+#if 0
                 return_value = LOCDWORD(r, PROCESS_ID);
                 *stack_ptr++ = return_value;
-
+#endif
             case MN_RETURN:
+#if 0
                 if (private_data == r->pridata) /* Esto es una nueva instancia */
+#endif
                 {
-                    if (LOCDWORD (r,STATUS) != STATUS_DEAD)
-                        LOCDWORD (r,STATUS) = STATUS_KILLED ;
+                    if (LOCDWORD(r,STATUS) != STATUS_DEAD) LOCDWORD(r,STATUS) = STATUS_KILLED ;
                     stack_ptr-- ;
                     stack_gptr = stack_ptr ;
                     return_value = *stack_ptr ;
                     goto break_all ;
                 }
-
+#if 0
                 /* The process is inside a stack-call */
                 proc = (PROCDEF *)stack_ptr[-4]; // stack_ptr[-4] = Recupero el proc de la instancia actual
                 freestrings(proc, private_data);
@@ -2159,7 +2159,7 @@
 
                 r->inpridata = NULL;
                 r->inproc = NULL;
-
+#endif
                 break;
 
             /* Otros */
@@ -2195,7 +2195,7 @@
         }
 
         /* Si me killearon o estoy en waiting salgo */
-        if (LOCDWORD(r,STATUS) == STATUS_KILLED || LOCDWORD(r,STATUS) & STATUS_WAITING_MASK) {
+        if ((LOCDWORD(r,STATUS) & ~STATUS_WAITING_MASK) == STATUS_KILLED || (LOCDWORD(r,STATUS) & STATUS_WAITING_MASK)) {
             r->codeptr = ptr;
             stack_gptr = stack_ptr ;
             return_value = LOCDWORD(r, PROCESS_ID);
@@ -2217,40 +2217,34 @@
 
     gprof_end (proc->name);
 
+    if (!*ptr || *ptr == MN_RETURN || *ptr == MN_END || LOCDWORD(r, STATUS) == STATUS_KILLED) {
     /* Check for waiting parent */
-    if (r->called_by && instance_exists(r->called_by)         &&
-        LOCDWORD(r->called_by, STATUS) & STATUS_WAITING_MASK  &&
-        (LOCDWORD(r, STATUS) == STATUS_KILLED || !*ptr || *ptr == MN_RETURN || *ptr == MN_END)
-       )
+        if (r->called_by && instance_exists(r->called_by) && (LOCDWORD(r->called_by, STATUS) & STATUS_WAITING_MASK))
     {
         /* We're returning and the parent is waiting: wake it up */
-        if (r->called_by->stack &&
-            !((*r->called_by->stack) & STACK_NO_RETURN_VALUE)
-           )
-        {
-            r->called_by->stack[(*r->called_by->stack) & STACK_SIZE_MASK] = return_value;
+            if (r->called_by->stack && !(r->called_by->stack[0] & STACK_NO_RETURN_VALUE)) {
+                r->called_by->stack[r->called_by->stack[0] & STACK_SIZE_MASK] = return_value;
         }
+
         LOCDWORD(r->called_by, STATUS) &= ~STATUS_WAITING_MASK;
     }
+        r->called_by = NULL;
 
-    /* The process should be destroyed immediately,
-     * it is a function-type one */
-    if (!*ptr || *ptr == MN_RETURN || *ptr == MN_END || LOCDWORD(r, STATUS) == STATUS_KILLED) // Splinter
-    {
+        /* The process should be destroyed immediately, it is a function-type one */
         /* Ejecuto ONEXIT */
         if ((LOCDWORD(r,STATUS) & ~STATUS_WAITING_MASK) != STATUS_DEAD && r->exitcode) {
             LOCDWORD(r,STATUS) = STATUS_DEAD;
             r->codeptr = r->exitcode;
-            if (r->called_by && instance_exists(r->called_by)) {
-                r->called_by = NULL;
-            }
+
             instance_go(r);
         } else {
             instance_destroy(r);
         }
 
-        if (was_visible)
-            object_list_dirty = 1;
+        /* Apunto global stack a stack_begin (inicio del stack original) */
+        stack_gptr = stack_begin;
+
+        if (was_visible) object_list_dirty = 1;
     }
     else if (LOCDWORD(r, STATUS) != STATUS_KILLED && r->first_run)
     {
@@ -2266,13 +2260,15 @@
         object_list_unsorted = 1;
     }
 
-    if (switchval_string != 0)
-        string_discard(switchval_string);
+//    if (switchval_string != 0) string_discard(switchval_string);
 
     if (debug_next && trace_sentence != -1) {
         force_debug = 1;
         debug_next = 0;
     }
 
+    /* Apunto global stack a stack_begin (inicio del stack original) */
+/*    stack_gptr = stack_begin; */
+
     return return_value;
 }
Index: fxi/src/img_pcx.c
===================================================================
--- fxi/src/img_pcx.c	2007-08-28 14:39:59.000000000 +0200
+++ fxi/src/img_pcx.c	2007-08-28 14:41:16.000000000 +0200
@@ -81,6 +81,10 @@
 	Uint8	Filler[54];
 } PCXheader ;
 
+
+
+static unsigned char colors[256][3] ;
+
 /*
  *  FUNCTION : gr_read_pcx
  *
@@ -94,14 +98,15 @@
  *
  */
 
-GRAPH *
-gr_read_pcx (const char * filename)
+GRAPH * gr_read_pcx (const char * filename)
 {
 	PCXheader header ;
 	file *    file ;
 	int       width, height, x, y, p, count ;
 	GRAPH *   bitmap ;
 	Uint8 *   ptr, ch ;
+	int       i;
+
 
 	file = file_open (filename, "rb") ;
 	if (!file) gr_error (_("%s: Could not open the file\n"), filename) ;
@@ -147,6 +152,25 @@
 				}
 			}
 		}
+
+		if(file_read(file, &ch, 1)==1 && ch == 0x0c) {
+			if (file_read (file, colors, 3 * 256)) {
+				int i ;
+
+				if (!palette_loaded) {
+					for (i = 0 ; i < 256 ; i++) {
+						palette[i].r = colors[i][0] ;
+						palette[i].g = colors[i][1] ;
+						palette[i].b = colors[i][2] ;
+					}
+				}
+
+				bitmap->palette = pal_new2(colors);
+
+				palette_loaded = 1 ;
+				palette_changed = 1 ;
+			}
+		}
 	} else {
 		gr_error (_("%s: unsupported color depth\n"), filename) ;
 	}
Index: fxi/src/img_png.c
===================================================================
--- fxi/src/img_png.c	2007-08-28 14:39:59.000000000 +0200
+++ fxi/src/img_png.c	2007-08-28 14:41:16.000000000 +0200
@@ -144,35 +144,41 @@
     /* Recupera el fichero, convirtiendo a 16 bits si es preciso */
 
     rowbytes = png_get_rowbytes (png_ptr, info_ptr) ;
-    bitmap = bitmap_new (0, width, height, color == PNG_COLOR_TYPE_PALETTE ? 8 : 16, 1) ;
-    if (!bitmap) gr_error (_("Error loading PNG file")) ;
-    if (color == PNG_COLOR_TYPE_PALETTE)
-    {
+    bitmap = bitmap_new (0, width, height, (color == PNG_COLOR_TYPE_PALETTE) ? 8 : 16, 1) ;
+    if (!bitmap) {
+        file_close (png) ;
+        free ( rowpointers ) ;
+        free ( row ) ;
+        return 0 ;
+    }
+
+    if (color == PNG_COLOR_TYPE_PALETTE) {
         /* Read the color palette */
 
-        if (!palette_loaded)
-        {
             png_colorp png_palette = (png_colorp) png_malloc (png_ptr, 256*sizeof(png_color)) ;
-            if (!png_palette)
-                gr_error (_("Out of memory")) ;
-            else
-            {
+        if (!png_palette) gr_error (_("Out of memory")) ;
+
                 png_get_PLTE (png_ptr, info_ptr, &png_palette, &n) ;
 
-                for (n-- ; n <= 255 ; n--)
-                {
+        bitmap->palette = pal_new(NULL);
+
+        for (n = 0; n < 256 ; n++) {
+            bitmap->palette->rgb[n].r = png_palette[n].red;
+            bitmap->palette->rgb[n].g = png_palette[n].green;
+            bitmap->palette->rgb[n].b = png_palette[n].blue;
+            if (!palette_loaded) {
                     palette[n].r = png_palette[n].red;
                     palette[n].g = png_palette[n].green;
                     palette[n].b = png_palette[n].blue;
                 }
             }
 
+        pal_refresh(bitmap->palette);
+
             palette_loaded = 1 ;
             palette_changed = 1 ;
-        }
 
-        for (n = 0 ; n < height ; n++)
-            rowpointers[n] = ((Uint8*)bitmap->data) + n*bitmap->pitch ;
+        for (n = 0 ; n < height ; n++) rowpointers[n] = ((Uint8*)bitmap->data) + n*bitmap->pitch ;
         png_read_image (png_ptr, rowpointers) ;
 
         /* If the depth is less than 8, expand the pixel values */
@@ -260,9 +266,7 @@
             Bmask &= 0xFF0000 ;
             Gmask &= 0x00FF00 ;
             Rmask &= 0x0000FF ;
-        }
-        else
-        {
+        } else {
             Bshift = 8;
             Gshift = 5;
             Rshift = 3;
@@ -271,26 +275,21 @@
             Rmask  = 0x0000F7;
         }
 
-        for (n = 0 ; n < height ; n++)
-        {
+        for (n = 0 ; n < height ; n++) {
             rowpointers[0] = (void *)row ;
             png_read_rows (png_ptr, rowpointers, 0, 1) ;
 
             ptr = (Uint16*) bitmap->data + n*bitmap->pitch/2;
             orig = row ;
-            for (x = 0 ; x < width ; x++)
-            {
+            for (x = 0 ; x < width ; x++) {
                 ARRANGE_DWORD(orig);
 
-                if ((*orig) & 0x80000000)
-                {
-                  *ptr = ((*orig & Rmask) >> Rshift)|
-                     ((*orig & Gmask) >> Gshift)|
-                     ((*orig & Bmask) >> Bshift)  ;
-
+                if ((*orig) & 0x80000000) {
+                  *ptr = ((*orig & Rmask) >> Rshift)|((*orig & Gmask) >> Gshift)|((*orig & Bmask) >> Bshift)  ;
                   if (!*ptr) (*ptr)++ ;
                 }
-                else *ptr = 0 ;
+                else
+                    *ptr = 0 ;
                 ptr++, orig++ ;
             }
         }
@@ -298,8 +297,7 @@
 
     /* Fin */
 
-    if (!setjmp (png_ptr->jmpbuf))
-        png_read_end (png_ptr, 0) ;
+    if (!setjmp (png_ptr->jmpbuf)) png_read_end (png_ptr, 0) ;
     file_close (png) ;
     bitmap->modified = 1 ;
 
@@ -335,6 +333,7 @@
     png_colorp  pal ;
     Uint32      * data, * ptr ;
     Uint16      * orig ;
+    SDL_Color * gpal = NULL;
 
     if (!file) return(0) ;
 
@@ -347,8 +346,7 @@
     png_ptr  = png_create_write_struct (PNG_LIBPNG_VER_STRING, 0, 0, 0) ;
     info_ptr = png_create_info_struct  (png_ptr) ;
 
-    if (!png_ptr || !info_ptr)
-    {
+    if (!png_ptr || !info_ptr) {
         free ( rowpointers ) ;
         fclose(file) ;
         return(0) ;
@@ -356,8 +354,7 @@
 
     /* Error handling... */
 
-    if (setjmp(png_ptr->jmpbuf))
-    {
+    if (setjmp(png_ptr->jmpbuf)) {
         fclose (file) ;
         png_destroy_write_struct (&png_ptr, NULL) ;
         free ( rowpointers ) ;
@@ -368,8 +365,7 @@
 
     /* NOTE: NO SUPPORT FOR ANIMATIONS! */
 
-    if (gr->depth == 8)
-    {
+    if (gr->depth == 8) {
         /* 8 bits PNG file */
         png_set_IHDR (png_ptr, info_ptr, gr->width,
                       gr->height, 8, PNG_COLOR_TYPE_PALETTE,
@@ -377,20 +373,20 @@
                       PNG_FILTER_TYPE_BASE) ;
 
         pal = (png_colorp) png_malloc (png_ptr, 256*sizeof(png_color)) ;
-        if (!pal)
-        {
+        if (!pal) {
             fclose (file) ;
             png_destroy_write_struct (&png_ptr, NULL) ;
             free ( rowpointers ) ;
             return(0) ;
         }
 
+        if (gr->palette) gpal = gr->palette->rgb; else gpal = palette;
+
         /* Generate palette info */
-        for (k = 0 ; k < 256 ; k++)
-        {
-            pal[k].red   = palette[k].r ;
-            pal[k].green = palette[k].g ;
-            pal[k].blue  = palette[k].b ;
+        for (k = 0 ; k < 256 ; k++) {
+            pal[k].red   = gpal[k].r ;
+            pal[k].green = gpal[k].g ;
+            pal[k].blue  = gpal[k].b ;
         }
         png_set_PLTE (png_ptr, info_ptr, pal, 256) ;
         png_write_info (png_ptr, info_ptr) ;
@@ -403,9 +399,7 @@
         /* Free allocated palette... */
         png_free (png_ptr, (png_voidp) pal) ;
         info_ptr->palette = NULL ;
-    }
-    else
-    {
+    } else {
         png_set_IHDR (png_ptr, info_ptr, gr->width,
                       gr->height, 8, PNG_COLOR_TYPE_RGB_ALPHA,
                       PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE,
@@ -413,24 +407,20 @@
         png_write_info (png_ptr, info_ptr) ;
 
         data = malloc (gr->width * gr->height * 4) ;
-        if (!data)
-        {
+        if (!data) {
             fclose (file) ;
             png_destroy_write_struct (&png_ptr, NULL) ;
             free ( rowpointers ) ;
             return(0) ;
         }
-        for (k = 0 ; k < (unsigned)gr->height ; k++)
-        {
+        for (k = 0 ; k < (unsigned)gr->height ; k++) {
             ptr  = data + gr->width * k ; /* uses dword for each pixel! */
             orig = (Uint16 *)gr->data + gr->width * k ;
             rowpointers[k] = (Uint8 *)ptr ;
-            for (i = 0 ; i < (unsigned)gr->width ; i++)
-            {
+            for (i = 0 ; i < (unsigned)gr->width ; i++) {
                 if (*orig == 0 && !(gr->info_flags & GI_NOCOLORKEY))
                     *ptr = 0x00000000 ;
-                else
-                {
+                else {
                     *ptr = ((*orig & 0xf800) >> 8) |
                            ((*orig & 0x07e0) << 5) |
                            ((*orig & 0x001f) << 19)|
Index: fxi/src/instance.c
===================================================================
--- fxi/src/instance.c	2007-08-28 14:38:27.000000000 +0200
+++ fxi/src/instance.c	2007-08-28 14:41:16.000000000 +0200
@@ -53,12 +53,12 @@
 /* destrucción, duplicado, etc.                                           */
 /* ---------------------------------------------------------------------- */
 
-INSTANCE * first_instance = 0 ;
-INSTANCE * last_instance  = 0 ;
+INSTANCE * first_instance = NULL ;
+INSTANCE * last_instance  = NULL ;
 
 /* Priority lists */
 
-static INSTANCE * first_by_priority;
+static INSTANCE * first_by_priority     = NULL ;
 static INSTANCE * iterator_by_priority = NULL;
 static int        iterator_reset = 1;
 
@@ -128,6 +128,10 @@
 	r->inpridata    = NULL ;
 	r->inproc       = NULL ;
 
+    r->switchval        = 0;
+    r->switchval_string = 0;
+    r->cased            = 0;
+
 	r->breakpoint   = 0 ;
 
 	r->private_size = father->private_size ;
@@ -242,6 +246,10 @@
 	r->inpridata    = NULL ;
 	r->inproc       = NULL ;
 
+    r->switchval        = 0;
+    r->switchval_string = 0;
+    r->cased            = 0;
+
 	r->breakpoint   = 0 ;
 
 	r->private_size = proc->private_size ;
@@ -390,8 +398,7 @@
 	while (i)
 	{
 		next = i->next ;
-		if (i != except)
-			instance_destroy (i) ;
+		if (i != except) instance_destroy (i) ;
 		i = next ;
 	}
 }
@@ -417,13 +424,11 @@
 	INSTANCE * father, * bigbro, * smallbro, * smallson, * bigson, * smallerbro=NULL;
 	int n ;
 
-	if (LOCDWORD(r, GRAPHID) != 0)
-		object_list_dirty = 1;
+	if (LOCDWORD(r, GRAPHID) != 0) object_list_dirty = 1;
 
 	LOCDWORD(r, STATUS) = STATUS_RUNNING;
 
-	if (LOCDWORD(r, BOX_X0) != -2)
-		gr_mark_instance(r);
+	if (LOCDWORD(r, BOX_X0) != -2) gr_mark_instance(r);
 
 	/* Actualiza la cuenta de referencia de las variables tipo string */
 
@@ -440,15 +445,11 @@
 
     /* Si tengo hermano mayor */
 	bigbro = instance_get(LOCDWORD(r,BIGBRO)) ;
-	if (bigbro) {
-	    LOCDWORD(bigbro,SMALLBRO) = LOCDWORD(r,SMALLBRO) ;
-	}
+	if (bigbro) LOCDWORD(bigbro,SMALLBRO) = LOCDWORD(r,SMALLBRO) ;
 
     /* Si tengo un hermano */
 	smallbro = instance_get(LOCDWORD(r,SMALLBRO)) ;
-	if (smallbro) {
-	    LOCDWORD(smallbro,BIGBRO) = LOCDWORD(r,BIGBRO) ;
-	}
+	if (smallbro) LOCDWORD(smallbro,BIGBRO) = LOCDWORD(r,BIGBRO) ;
 
     /* Yo, ya estoy fuera */
 
@@ -508,41 +509,28 @@
 
 	/* Quita la instancia de la lista */
 
-	if (r->prev) {
-	    r->prev->next  = r->next ;
-	}
+	if (r->prev) r->prev->next  = r->next ;
 
-	if (r->next) {
-	    r->next->prev = r->prev ;
-	}
+	if (r->next) r->next->prev = r->prev ;
 
-	if (first_instance == r)
-		first_instance = r->next ;
+	if (first_instance == r) first_instance = r->next ;
 
-	if (last_instance == r)
-		last_instance = r->prev ;
+	if (last_instance == r) last_instance = r->prev ;
 
 	/* Remove the instance from the priority list */
-	if (first_by_priority == r)
-		first_by_priority = r->next_by_priority;
+	if (first_by_priority == r) first_by_priority = r->next_by_priority;
 
-	if (r->prev_by_priority)
-		r->prev_by_priority->next_by_priority = r->next_by_priority;
-
-	if (r->next_by_priority)
-		r->next_by_priority->prev_by_priority = r->prev_by_priority;
+	if (r->prev_by_priority) r->prev_by_priority->next_by_priority = r->next_by_priority;
+	if (r->next_by_priority) r->next_by_priority->prev_by_priority = r->prev_by_priority;
 
 	/* Remove the instance from the dirty list */
 
-	if (dirty_list == r)
+	if (dirty_list == r) {
 		dirty_list = r->next_dirty;
-    else if (r->is_dirty)
-	{
+    } else if (r->is_dirty) {
 		INSTANCE * i = dirty_list;
-		while (i)
-		{
-			if (i->next_dirty == r)
-			{
+		while (i) {
+			if (i->next_dirty == r) {
 				i->next_dirty = r->next_dirty;
 				break;
 			}
@@ -550,12 +538,11 @@
 		}
 	}
 
-	if (r->stack)
-		free (r->stack) ;
+	if (r->stack) free (r->stack) ;
 
-	free (r->locdata) ;
-	free (r->pubdata) ;
-	free (r->pridata) ;
+	if (r->locdata) free (r->locdata) ;
+	if (r->pubdata) free (r->pubdata) ;
+	if (r->pridata) free (r->pridata) ;
 	free (r) ;
 }
 
@@ -598,9 +585,8 @@
 	if (scalex == 100 && scaley == 100)
 		scalex = scaley = LOCDWORD(i,GRAPHSIZE);
 
-	gr_get_bbox (&dest, r, x, y,
-		LOCDWORD(i,FLAGS) ^ LOCDWORD(i,XGRAPH_FLAGS),
-		LOCDWORD(i,XGRAPH) ? 0 : LOCDWORD(i,ANGLE),
+	gr_get_bbox (&dest, r, x, y, LOCDWORD(i,FLAGS) ^ LOCDWORD(i,XGRAPH_FLAGS),
+                        		 (LOCDWORD(i,XGRAPH)) ? 0 : LOCDWORD(i,ANGLE),
 		scalex, scaley, gr) ;
 
 	if (LOCDWORD(i, CTYPE) == 1)	/* c_scroll */
@@ -641,8 +627,7 @@
 	if ((LOCDWORD(i,STATUS) & ~STATUS_WAITING_MASK) == STATUS_SLEEPING ||
 	    (LOCDWORD(i,STATUS) & ~STATUS_WAITING_MASK) == STATUS_RUNNING)
 	{
-		if (instance_graph(i))
-			return 1;
+		if (instance_graph(i)) return 1;
 	}
 
 	return 0;
@@ -696,14 +681,10 @@
 {
 	GRAPH * graph = instance_graph(i);
 
-	if (graph && (graph->modified ||
-	              (graph->frames > 0 && graph->next_time < current_time)
-	              )
-	   )
+	if (graph && (graph->modified || (graph->frames > 1 && graph->next_time < current_time)))
 	    return 1;
 
-	return
-	    LOCDWORD(i,SAVED_X)       != LOCDWORD(i,COORDX)		||
+	return  LOCDWORD(i,SAVED_X)       != LOCDWORD(i,COORDX)		||
 		LOCDWORD(i,SAVED_Y)       != LOCDWORD(i,COORDY)		||
 		LOCDWORD(i,SAVED_GRAPH)   != LOCDWORD(i,GRAPHID)	||
 		LOCDWORD(i,SAVED_ANGLE)   != LOCDWORD(i,ANGLE)		||
@@ -800,17 +781,14 @@
 
 INSTANCE * instance_next_by_priority()
 {
-	INSTANCE * i;
-	INSTANCE * j;
-	INSTANCE * best_prev;
-	INSTANCE * best_next;
-
-	if (iterator_by_priority == NULL)
-	{
+	INSTANCE * i = NULL ;
+	INSTANCE * j = NULL ;
+	INSTANCE * best_prev = NULL ;
+	INSTANCE * best_next = NULL ;
+	if (!iterator_by_priority) {
 		// NULL will be returned once and then the list will be reset
 
-		if (!iterator_reset)
-		{
+		if (!iterator_reset) {
 			iterator_reset = 1;
 			return NULL;
 		}
@@ -819,23 +797,18 @@
 		// Add all dirty instances to its place at the list
 
 		i = dirty_list;
-		while (i != NULL)
-		{
+		while (i != NULL) {
 			// Check the priority value
 
-			if (LOCDWORD(i, PRIORITY) < MIN_PRIORITY)
-				LOCDWORD(i, PRIORITY) = MIN_PRIORITY;
-			if (LOCDWORD(i, PRIORITY) > MAX_PRIORITY)
-				LOCDWORD(i, PRIORITY) = MAX_PRIORITY;
+			if (LOCDWORD(i, PRIORITY) < MIN_PRIORITY) LOCDWORD(i, PRIORITY) = MIN_PRIORITY;
+			if (LOCDWORD(i, PRIORITY) > MAX_PRIORITY) LOCDWORD(i, PRIORITY) = MAX_PRIORITY;
 
 			// Remove the instance from the list
 
-			if (i->prev_by_priority)
-				i->prev_by_priority->next_by_priority = i->next_by_priority;
-			if (i->next_by_priority)
-				i->next_by_priority->prev_by_priority = i->prev_by_priority;
-			if (first_by_priority == i)
-				first_by_priority = i->next_by_priority;
+			if (i->prev_by_priority) i->prev_by_priority->next_by_priority = i->next_by_priority;
+			if (i->next_by_priority) i->next_by_priority->prev_by_priority = i->prev_by_priority;
+
+			if (first_by_priority == i) first_by_priority = i->next_by_priority;
 
 			// Add the instance to the list. The easy case is when there is
 			// already some instance with the same priority.
@@ -846,61 +819,48 @@
             i->prev_by_priority = NULL;
 			i->next_by_priority = NULL;
 
-			while (j)
-			{
-				if (LOCDWORD(j, PRIORITY) == LOCDWORD(i, PRIORITY))
-				{
+			while (j) {
+				if (LOCDWORD(j, PRIORITY) == LOCDWORD(i, PRIORITY)) {
 					i->prev_by_priority = j;
 					i->next_by_priority = j->next_by_priority;
 					j->next_by_priority = i;
 
-					if (i->next_by_priority)
-						i->next_by_priority->prev_by_priority = i;
+					if (i->next_by_priority) i->next_by_priority->prev_by_priority = i;
 					break;
-				}
-				else if (LOCDWORD(j, PRIORITY) > LOCDWORD(i, PRIORITY))
-				{
+				} else if (LOCDWORD(j, PRIORITY) > LOCDWORD(i, PRIORITY)) {
 					best_prev = j;
-				}
-				else if (!best_next)
-				{
+				} else if (!best_next) {
 					best_next = j;
 				}
 
 				j = j->next_by_priority;
 			}
 
-			if (j == NULL)
-			{
+			if (!j) {
 				// No best case
-				if (best_prev)
-				{
+				if (best_prev) {
 					// But some instance was found with a lower priority
 
 					i->next_by_priority = best_prev->next_by_priority;
 					best_prev->next_by_priority = i;
 
-					if (i->next_by_priority)
-						i->next_by_priority->prev_by_priority = i;
+					if (i->next_by_priority) i->next_by_priority->prev_by_priority = i;
 
 				    i->prev_by_priority = best_prev; /* Splinter */
-				}
-				else if (best_next)
-				{
+				} else if (best_next) {
 					// But some instance was found with a higher priority
 
 					i->prev_by_priority = best_next->prev_by_priority;
 					best_next->prev_by_priority = i;
 
-					if (i->prev_by_priority)
+					if (i->prev_by_priority) {
 						i->prev_by_priority->next_by_priority = i;
-					else
+					} else {
 						first_by_priority = i;
+					}
 
 				    i->next_by_priority = best_next; /* Splinter */
-				}
-				else
-				{
+				} else {
 					// There are no instances in the list
 
 					first_by_priority   = i;
@@ -915,12 +875,19 @@
 
 		dirty_list = NULL;
 
+		if (first_by_priority)
 		iterator_by_priority = first_by_priority->next_by_priority;
+		else
+		    iterator_by_priority = NULL;
+
 		return first_by_priority;
 	}
 
 	i = iterator_by_priority;
+
+	if (iterator_by_priority)
 	iterator_by_priority = iterator_by_priority->next_by_priority;
+
 	return i;
 }
 
