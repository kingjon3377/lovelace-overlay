# Copyright (C) 2007  Miriam Ruiz <little_miry@yahoo.es>
# Licensed under the GPL, see /usr/share/common-licenses/GPL

Index: fxi/src/dcbr.c
===================================================================
--- fxi/src/dcbr.c	2007-08-28 14:38:47.000000000 +0200
+++ fxi/src/dcbr.c	2007-08-28 14:46:00.000000000 +0200
@@ -45,6 +45,14 @@
 #else
 #include <direct.h>
 #endif
+
+#ifdef USE_GETTEXT
+#include <libintl.h>
+#define _(String) gettext (String)
+#else
+#define _(String) String
+#endif
+
 #include "fxi.h"
 #include "dcb.h"
 #include "dirs.h"
@@ -140,7 +148,7 @@
 
 	fp = file_open (filename, "rb0") ;
 	if (!fp)
-		gr_error ("Error al abrir %s\n", filename) ;
+		gr_error (_("'%s': Error opening file\n"), filename) ;
 
 	return dcb_load_from (fp, 0);
 }
Index: fxi/src/fbm.c
===================================================================
--- fxi/src/fbm.c	2007-08-28 14:38:47.000000000 +0200
+++ fxi/src/fbm.c	2007-08-28 14:44:30.000000000 +0200
@@ -34,6 +34,13 @@
 #include <string.h>
 #include <stdlib.h>
 
+#ifdef USE_GETTEXT
+#include <libintl.h>
+#define _(String) gettext (String)
+#else
+#define _(String) String
+#endif
+
 #include "fxi.h"
 #include "fbm.h"
 
@@ -118,7 +125,7 @@
 	{
 		if (file_read (fp, &file_header, sizeof(FBM_FILE_HEADER)) != sizeof(FBM_FILE_HEADER))
 		{
-			fbm_error = "Error de lectura";
+			fbm_error = "Read error";
 			return NULL;
 		}
 
@@ -127,12 +134,12 @@
 
 		if (strcmp (file_header.magic, FBM_MAGIC) != 0)
 		{
-			fbm_error = "El fichero no es un FBM válido";
+			fbm_error = _("Not a valid FBM file");
 			return NULL;
 		}
 		if ((file_header.version & 0xFF00) != 0x0100)
 		{
-			fbm_error = "El fichero FBM es de una versión posterior incompatible";
+			fbm_error = _("FBM file is from a later incompatible version");
 			return NULL;
 		}
 	}
@@ -145,7 +152,7 @@
 
 	if (file_read (fp, &header, sizeof(FBM_HEADER)) != sizeof(FBM_HEADER))
 	{
-		fbm_error = "Error de lectura";
+		fbm_error = "Read error";
 		return NULL;
 	}
 
@@ -163,12 +170,12 @@
 
 	if (!FBM_VALID_DEPTH(file_header.depth))
 	{
-		fbm_error = "Fichero FBM corrupto";
+		fbm_error = _("FBM file is corrupt");
 		return NULL;
 	}
 	if (header.width > FBM_MAX_WIDTH || header.height > FBM_MAX_HEIGHT)
 	{
-		fbm_error = "Fichero FBM corrupto";
+		fbm_error = "FBM file is corrupt";
 		return NULL;
 	}
 
@@ -179,7 +186,7 @@
 
 	if (sequences == NULL || keyframes == NULL)
 	{
-		fbm_error = "No hay memoria libre suficiente para cargar el FBM";
+		fbm_error = _("Not enough free memory to load FBM file");
 		error = 1;
 	}
 
@@ -190,7 +197,7 @@
 		graph = bitmap_new (header.code, header.width, header.height, file_header.depth, header.max_frame+1);
 		if (graph == NULL)
 		{
-			fbm_error = "Error al crear el gráfico en memoria";
+			fbm_error = _("Error creating graphic in memory");
 			error = 1;
 		}
 		else
@@ -220,7 +227,7 @@
 				{
 					if (file_read(fp, color_palette, 768) != 768)
 					{
-						fbm_error = "Fichero FBM truncado";
+						fbm_error = _("FBM file is truncated");
 						error = 1;
 					}
 					else
@@ -249,7 +256,7 @@
 				size = sizeof(FBM_SEQUENCE) * (header.max_sequence+1);
 				if (file_read(fp, sequences, size) != size)
 				{
-					fbm_error = "Fichero FBM truncado";
+					fbm_error = _("FBM file is truncated");
 					error = 1;
 				}
 				else
@@ -263,7 +270,7 @@
 				size = sizeof(FBM_KEYFRAME) * (header.max_keyframe+1);
 				if (file_read(fp, keyframes, size) != size)
 				{
-					fbm_error = "Fichero FBM truncado";
+					fbm_error = _("FBM file is truncated");
 					error = 1;
 				}
 				else
@@ -278,7 +285,7 @@
 				{
                     if (file_read(fp, &control_point, size) != size)
 					{
-						fbm_error = "Fichero FBM truncado";
+						fbm_error = _("FBM file is truncated");
 						error = 1;
 					}
 					else
@@ -304,7 +311,7 @@
                 for (n = 0; n < h; n++) {
     				if (file_read(fp, ((char *) graph->data_start) + n * graph->pitch, size) != size)
     				{
-    					fbm_error = "Fichero FBM truncado";
+    					fbm_error = _("FBM file is truncated");
     					error = 1;
     				}
 
@@ -355,7 +362,7 @@
 
 	if (!fp)
 	{
-		fbm_error = "Error al abrir fichero";
+		fbm_error = _("Error opening file");
 		return NULL;
 	}
 
@@ -431,7 +438,7 @@
 
 	if (file_write (fp, &header, sizeof(FBM_HEADER)) != sizeof(FBM_HEADER))
 	{
-		fbm_error = "Error escribiendo fichero FBM";
+		fbm_error = _("Error writing FBM file");
 		return 0;
 	}
 
@@ -448,7 +455,7 @@
 
 		if (file_write (fp, &color_palette, 768) != 768)
 		{
-			fbm_error = "Error escribiendo fichero FBM";
+			fbm_error = _("Error writing FBM file");
 			return 0;
 		}
 	}
@@ -460,7 +467,7 @@
 	if (file_write (fp, map->sequences, size) != size)
 	{
 		arrange_sequences(map);
-		fbm_error = "Error escribiendo fichero FBM";
+		fbm_error = _("Error writing FBM file");
 		return 0;
 	}
 	arrange_sequences(map);
@@ -472,7 +479,7 @@
 	if (file_write (fp, map->keyframes, size) != size)
 	{
 		arrange_keyframes(map);
-		fbm_error = "Error escribiendo fichero FBM";
+		fbm_error = _("Error writing FBM file");
 		return 0;
 	}
 	arrange_keyframes(map);
@@ -495,7 +502,7 @@
 
 			if (file_write (fp, &cp, sizeof(cp)) != sizeof(cp))
 			{
-				fbm_error = "Error escribiendo fichero FBM";
+				fbm_error = _("Error writing FBM file");
 				return 0;
 			}
 		}
@@ -515,7 +522,7 @@
 
 		if (data_copy == NULL)
 		{
-			fbm_error = "No hay memoria libre suficiente";
+			fbm_error = _("Out of memory");
 			return 0;
 		}
 	}
@@ -535,7 +542,7 @@
 
     	if (file_write(fp, data, size) != size)
 	    {
-    		fbm_error = "Error escribiendo fichero FBM";
+    		fbm_error = _("Error writing FBM file");
 		    free (data_copy);
 		    return 0;
 	    }
@@ -571,7 +578,7 @@
 	fp = file_open (filename, "wb9");
 	if (fp == NULL)
 	{
-		fbm_error = "Error al crear fichero FBM";
+		fbm_error = _("Error creating FBM file");
 		return 0;
 	}
 
@@ -586,7 +593,7 @@
 
 	if (file_write (fp, &file_header, sizeof(FBM_FILE_HEADER)) != sizeof(FBM_FILE_HEADER))
 	{
-		fbm_error = "Error escribiendo en fichero FBM";
+		fbm_error = _("Error writing FBM file");
 		file_close (fp);
 		return 0;
 	}
Index: fxi/src/fgc.c
===================================================================
--- fxi/src/fgc.c	2007-08-28 14:38:47.000000000 +0200
+++ fxi/src/fgc.c	2007-08-28 14:44:30.000000000 +0200
@@ -39,6 +39,13 @@
 #include <assert.h>
 #endif
 
+#ifdef USE_GETTEXT
+#include <libintl.h>
+#define _(String) gettext (String)
+#else
+#define _(String) String
+#endif
+
 #include "fxi.h"
 #include "fbm.h"
 #include "fgc.h"
@@ -75,13 +82,13 @@
 
 	if (!fp)
 	{
-		fgc_error = "Error al abrir el fichero";
+		fgc_error = "Error opening file";
 		return -1;
 	}
 
 	if (file_read (fp, &header, sizeof(FGC_HEADER)) != sizeof(FGC_HEADER))
 	{
-		fgc_error = "Fichero FGC corrupto o truncado";
+		fgc_error = "FGC file is corrupt or truncated";
 		file_close(fp);
 		return -1;
 	}
@@ -93,7 +100,7 @@
 
 	if (strcmp (header.magic, FGC_MAGIC) != 0 || (header.version & 0xFF00) != 0x0100)
 	{
-		fgc_error = "No es un fichero FGC o compatible";
+		fgc_error = _("Not an FGC file or compatible");
 		file_close(fp);
 		return -1;
 	}
@@ -107,14 +114,14 @@
 
 	if (offsets == NULL)
 	{
-		fgc_error = "No hay memoria libre suficiente";
+		fgc_error = _("Out of memory");
 		file_close(fp);
 		return -1;
 	}
 
 	if (file_read (fp, offsets, 4*header.count) != 4*(int)header.count)
 	{
-		fgc_error = "Fichero FGC corrupto o truncado";
+		fgc_error = _("FGC file is corrupt or truncated");
 		free(offsets);
 		file_close(fp);
 		return -1;
@@ -132,7 +139,7 @@
 
 		if (file_read(fp, color_palette, 768) != 768)
 		{
-			fgc_error = "PALETA - Fichero FGC truncado";
+			fgc_error = _("PALETTE - FGC file is truncaded");
 			free(offsets);
 			file_close(fp);
 			return -1;
@@ -198,7 +205,7 @@
 	lib = grlib_get(id);
 	if (lib == NULL || !lib->maps)
 	{
-		fgc_error = "Número de librería incorrecta";
+		fgc_error = _("Incorrect library number");
 		return 0;
 	}
 
@@ -227,7 +234,7 @@
 		}
 		if (header.depth != lib->maps[i]->depth)
 		{
-			fgc_error = "La librería contiene mapas de diferente profundidad";
+			fgc_error = _("Library contains maps of different depth");
 			return 0;
 		}
 	}
@@ -241,14 +248,14 @@
 	fp = file_open (filename, "wb9");
 	if (fp == NULL)
 	{
-		fgc_error = "Error al crear fichero FGC";
+		fgc_error = _("Error creating FGC file");
 		return 0;
 	}
 
 	offsets = (Uint32 *)malloc(4*header.count + 4);
 	if (offsets == NULL)
 	{
-		fgc_error = "No hay memoria libre suficiente";
+		fgc_error = _("Out of memory");
 		file_close(fp);
 		return -1;
 	}
@@ -285,7 +292,7 @@
 
 	if (file_write(fp, &header, sizeof(FGC_HEADER)) != sizeof(FGC_HEADER))
 	{
-		fgc_error = "Error escribiendo en fichero FGC";
+		fgc_error = _("Error writing FGC file");
 		file_close (fp);
 		return 0;
 	} 
@@ -295,7 +302,7 @@
 	
 	if (file_write(fp, offsets, 4*header.count) != 4*(int)header.count)
 	{
-		fgc_error = "Error escribiendo en fichero FGC";
+		fgc_error = _("Error writing FGC file");
 		file_close (fp);
 		return 0;
 	} 
@@ -314,7 +321,7 @@
 		}
 		if (file_write(fp, color_palette, 768) != 768)
 		{
-			fgc_error = "Error al escribir, FGC truncado";
+			fgc_error = _("Write error, FGC file is truncated");
 			free(offsets);
 			file_close(fp);
 			return -1;
Index: fxi/src/fnc_exports.c
===================================================================
--- fxi/src/fnc_exports.c	2007-08-28 14:38:47.000000000 +0200
+++ fxi/src/fnc_exports.c	2007-08-28 14:44:30.000000000 +0200
@@ -35,6 +35,13 @@
 
 #include <stdlib.h>
 
+#ifdef USE_GETTEXT
+#include <libintl.h>
+#define _(String) gettext (String)
+#else
+#define _(String) String
+#endif
+
 #include <fxi.h>
 #include <fnx_loadlib.h>
 #include <fmath.h>
@@ -683,7 +690,7 @@
 		while (ptr != NULL)
 		{
 			if (ptr->count == 0)
-				gr_con_printf ("[FXI] Warning: '%s' not imported!", ptr->name);
+				gr_con_printf (_("[FXI] Warning: '%s' not imported!"), ptr->name);
 
 			bucket_use[n]++;
 			if (max_use < bucket_use[n])
@@ -693,7 +700,7 @@
 		}
 	}
 
-	gr_con_printf ("[FXI] %4d symbols imported by DLL", global_count);
+	gr_con_printf (_("[FXI] %4d symbols imported by DLL"), global_count);
 
 	/* Show information about hash table proficiency */
 
@@ -706,12 +713,12 @@
 		}
 
 		if (count > 0)
-			gr_con_printf ("[FXI] %4d buckets of size %d", count, n);
+			gr_con_printf (_("[FXI] %4d buckets of size %d"), count, n);
 	}
 
 	/* Not found symbols are reported by fnc_import */
 
 	if (global_notfound)
-		gr_con_printf ("[FXI] %4d symbols not found", global_notfound);
+		gr_con_printf (_("[FXI] %4d symbols not found"), global_notfound);
 }
 
Index: fxi/src/fpl.c
===================================================================
--- fxi/src/fpl.c	2007-08-28 14:38:47.000000000 +0200
+++ fxi/src/fpl.c	2007-08-28 14:44:30.000000000 +0200
@@ -34,6 +34,13 @@
 #include <string.h>
 #include <stdlib.h>
 
+#ifdef USE_GETTEXT
+#include <libintl.h>
+#define _(String) gettext (String)
+#else
+#define _(String) String
+#endif
+
 #include "fxi.h"
 #include "fpl.h"
 
@@ -65,12 +72,12 @@
 	// Read the header and check the file type and version
 
 	if (file_read (fp, &header, sizeof(FPL_HEADER)) != sizeof(FPL_HEADER)) {
-		fpl_error = "Error de lectura" ;
+		fpl_error = _("Read error") ;
 		return 0 ;
 	}
 
     if (strncmp(header.magic, FPL_MAGIC, strlen(FPL_MAGIC)) == 0) {
-		fpl_error = "Fichero FPL inválido" ;
+		fpl_error = _("Invalid FPL file") ;
 		return 0 ;
     }
 
@@ -78,17 +85,17 @@
 	ARRANGE_DWORD(&file_header.version);
 
 	if (!FPL_VALID_DEPTH(header.depth)) {
-		fpl_error = "Profundidad de color no válida en el fichero FPL" ;
+		fpl_error = _("Invalid colour depth in the FPL file") ;
 		return 0 ;
 	}
 
 	if ((header.version & 0xFF00) != 0x0100) {
-		fpl_error = "El fichero FPL es de una versión posterior incompatible";
+		fpl_error = _("FPL belongs to a later incompatible version");
 		return 0;
 	}
 
 	if (file_read(fp, color_palette, 768) != 768) {
-		fpl_error = "Fichero FPL truncado";
+		fpl_error = _("Truncated FPL file");
 		return 0;
 	}
 
@@ -135,7 +142,7 @@
 
 	if (file_write (fp, &color_palette, 768) != 768)
 	{
-		fbm_error = "Error escribiendo fichero FPL";
+		fbm_error = _("Error writing FPL file");
 		return 0;
 	}
 
@@ -166,7 +173,7 @@
 	fp = file_open (filename, "wb9");
 	if (fp == NULL)
 	{
-		fpl_error = "Error al crear fichero FPL";
+		fpl_error = _("Error creating FPL file");
 		return 0;
 	}
 
@@ -181,7 +188,7 @@
 
 	if (file_write (fp, &file_header, sizeof(FPL_HEADER)) != sizeof(FPL_HEADER))
 	{
-		fpl_error = "Error escribiendo en fichero FPL";
+		fpl_error = _("Error writing FPL file");
 		file_close (fp);
 		return 0;
 	}
@@ -216,7 +223,7 @@
 	fp = file_open (filename, "rb9");
 	if (fp == NULL)
 	{
-		fpl_error = "Error al abrir fichero FPL";
+		fpl_error = _("Error opening FPL file");
 		return 0;
 	}
 
Index: fxi/src/f_sort.c
===================================================================
--- fxi/src/f_sort.c	2007-08-28 14:38:47.000000000 +0200
+++ fxi/src/f_sort.c	2007-08-28 14:39:55.000000000 +0200
@@ -32,6 +32,13 @@
 #include <stdlib.h>
 #include <string.h>
 
+#ifdef USE_GETTEXT
+#include <libintl.h>
+#define _(String) gettext (String)
+#else
+#define _(String) String
+#endif
+
 #include "fxi.h"
 
 int keyoffset = 0;
@@ -78,7 +85,7 @@
 	}
 	if (i >= MAX_TYPECHUNKS-1)
 	{
-		gr_con_printf ("Tipo de dato demasiado complejo");
+		gr_con_printf (_("Data type too complex"));
 		return;
 	}
 	for (i = MAX_TYPECHUNKS-1 ; i > 0 ; i--)
@@ -173,7 +180,7 @@
 			}
 			if (maxvar == NULL)
 			{
-				gr_con_printf ("Estructura vacía");
+				gr_con_printf (_("Empty structure"));
 				return 0;
 			}
 
@@ -181,7 +188,7 @@
 		}
 
 		default:
-			gr_con_printf ("Tipo desconocido");
+			gr_con_printf (_("Unknown type"));
 			return 0;
 	}
 }
@@ -239,7 +246,7 @@
 			compare = compare_float;
 			break;
 		default:
-			gr_con_printf ("Tipo de dato usado como clave de ordenación inválido");
+			gr_con_printf (_("Invalid data type used as sorting key"));
 			return 0;
 	}
 
@@ -267,17 +274,17 @@
 
 	if (type->BaseType[0] != TYPE_ARRAY)
 	{
-		gr_con_printf ("Sólo se permite ordenar un array de estructuras o valores");
+		gr_con_printf (_("Only arrays of structures or values can be sorted"));
 		return 0;
 	}
 	if (vars > 1)
 	{
-		gr_con_printf ("Intento de ordenar una estructura con un sólo elemento");
+		gr_con_printf (_("Trying to sort a structure with just one element"));
 		return 0;
 	}
 	if (type->Count[0] < 2)
 	{
-		gr_con_printf ("Intento de ordenar un array con un sólo elemento");
+		gr_con_printf (_("Trying to sort an array with just one element"));
 		return 0;
 	}
 
@@ -326,17 +333,17 @@
 
 	if (type->BaseType[0] != TYPE_ARRAY)
 	{
-		gr_con_printf ("Sólo se permite ordenar un array de estructuras o valores");
+		gr_con_printf (_("Only arrays of structures or values can be sorted"));
 		return 0;
 	}
 	if (vars > 1)
 	{
-		gr_con_printf ("Intento de ordenar una estructura con un sólo elemento");
+		gr_con_printf (_("Trying to sort a structure with just one element"));
 		return 0;
 	}
 	if (type->Count[0] < 2)
 	{
-		gr_con_printf ("Intento de ordenar un array con un sólo elemento");
+		gr_con_printf (_("Trying to sort an array with just one element"));
 		return 0;
 	}
 
@@ -347,7 +354,7 @@
 
 	if ((Uint8 *)key_data > (Uint8*)data + element_size || key_data < data)
 	{
-		gr_con_printf ("Intento de ordenar usando una clave externa al primer elemento");
+		gr_con_printf (_("Trying to sort using an key external to the first element"));
 		return 0;
 	}
 
@@ -402,7 +409,7 @@
 	}
 	if (vars > 1)
 	{
-		gr_con_printf ("Intento de ordenar una estructura con un sólo elemento");
+		gr_con_printf (_("Trying to sort a structure with just one element"));
 		return 0;
 	}
 
@@ -467,7 +474,7 @@
 	}
 	if (vars > 1)
 	{
-		gr_con_printf ("Intento de ordenar una estructura con un sólo elemento");
+		gr_con_printf (_("Trying to sort a structure with just one element"));
 		return 0;
 	}
 
@@ -478,7 +485,7 @@
 
 	if ((Uint8 *)key_data > (Uint8*)data + element_size || key_data < data)
 	{
-		gr_con_printf ("Intento de ordenar usando una clave externa al primer elemento");
+		gr_con_printf (_("Trying to sort using an key external to the first element"));
 		return 0;
 	}
 
