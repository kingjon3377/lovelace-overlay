--- cmix-2.0.12.orig/src/analyzer/lex-yy.cc
+++ cmix-2.0.12/src/analyzer/lex-yy.cc
@@ -1,51 +1,87 @@
 #include <cmixconf.h>
-#define yy_create_buffer ccc_create_buffer
-#define yy_delete_buffer ccc_delete_buffer
-#define yy_scan_buffer ccc_scan_buffer
-#define yy_scan_string ccc_scan_string
-#define yy_scan_bytes ccc_scan_bytes
-#define yy_flex_debug ccc_flex_debug
-#define yy_init_buffer ccc_init_buffer
-#define yy_flush_buffer ccc_flush_buffer
-#define yy_load_buffer_state ccc_load_buffer_state
-#define yy_switch_to_buffer ccc_switch_to_buffer
-#define yyin cccin
-#define yyleng cccleng
-#define yylex ccclex
-#define yyout cccout
-#define yyrestart cccrestart
-#define yytext ccctext
+#line 2 "temp"
 
-#line 19 "temp"
-/* A lexical scanner generated by flex */
+#line 4 "temp"
 
-/* Scanner skeleton version:
- * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.89 96/05/25 21:02:21 vern Exp $
- */
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
 
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 31
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
 
+/* begin standard C headers. */
 #include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
 
+/* end standard C headers. */
 
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
 #endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
 #endif
 
+#endif /* ! FLEXINT_H */
 
 #ifdef __cplusplus
 
-#include <stdlib.h>
-#include <unistd.h>
-
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
-
 /* The "const" storage-class-modifier is valid. */
 #define YY_USE_CONST
 
@@ -53,34 +89,17 @@
 
 #if __STDC__
 
-#define YY_USE_PROTOS
 #define YY_USE_CONST
 
 #endif	/* __STDC__ */
 #endif	/* ! __cplusplus */
 
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
 #ifdef YY_USE_CONST
 #define yyconst const
 #else
 #define yyconst
 #endif
 
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
 /* Returned upon end-of-file. */
 #define YY_NULL 0
 
@@ -95,71 +114,71 @@
  * but we do it the disgusting crufty way forced on us by the ()-less
  * definition of BEGIN.
  */
-#define BEGIN yy_start = 1 + 2 *
+#define BEGIN (yy_start) = 1 + 2 *
 
 /* Translate the current start state into a value that can be later handed
  * to BEGIN to return to the state.  The YYSTATE alias is for lex
  * compatibility.
  */
-#define YY_START ((yy_start - 1) / 2)
+#define YY_START (((yy_start) - 1) / 2)
 #define YYSTATE YY_START
 
 /* Action number for EOF rule of a given start state. */
 #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
 
 /* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
+#define YY_NEW_FILE cccrestart(cccin  )
 
 #define YY_END_OF_BUFFER_CHAR 0
 
 /* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
 #define YY_BUF_SIZE 16384
+#endif
 
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
 typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
 
-extern int yyleng;
-extern FILE *yyin, *yyout;
+extern int cccleng;
+
+extern FILE *cccin, *cccout;
 
 #define EOB_ACT_CONTINUE_SCAN 0
 #define EOB_ACT_END_OF_FILE 1
 #define EOB_ACT_LAST_MATCH 2
 
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
 	do \
 		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
+		/* Undo effects of setting up ccctext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
 		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up ccctext again */ \
 		} \
 	while ( 0 )
 
-#define unput(c) yyunput( c, yytext_ptr )
+#define unput(c) yyunput( c, (yytext_ptr)  )
 
 /* The following is because we cannot portably get our hands on size_t
  * (without autoconf's help, which isn't available because we want
  * flex-generated scanners to compile on their own).
  */
-typedef unsigned int yy_size_t;
 
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef unsigned int yy_size_t;
+#endif
 
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
 struct yy_buffer_state
 	{
 	FILE *yy_input_file;
@@ -196,12 +215,16 @@
 	 */
 	int yy_at_bol;
 
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
 	int yy_fill_buffer;
 
 	int yy_buffer_status;
+
 #define YY_BUFFER_NEW 0
 #define YY_BUFFER_NORMAL 1
 	/* When an EOF's been seen but there's still some text to process
@@ -211,102 +234,138 @@
 	 * possible backing-up.
 	 *
 	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
+	 * (via cccrestart()), so that the user can continue scanning by
+	 * just pointing cccin at a new input file.
 	 */
 #define YY_BUFFER_EOF_PENDING 2
+
 	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
 
-static YY_BUFFER_STATE yy_current_buffer = 0;
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
 
 /* We provide macros for accessing buffer states in case in the
  * future we want to put the buffer states in a more general
  * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
  */
-#define YY_CURRENT_BUFFER yy_current_buffer
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
 
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
 
-/* yy_hold_char holds the character lost when yytext is formed. */
+/* yy_hold_char holds the character lost when ccctext is formed. */
 static char yy_hold_char;
-
 static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
+int cccleng;
 
 /* Points to current character in buffer. */
 static char *yy_c_buf_p = (char *) 0;
 static int yy_init = 1;		/* whether we need to initialize */
 static int yy_start = 0;	/* start state number */
 
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
+/* Flag which is used to allow cccwrap()'s to do buffer switches
+ * instead of setting up a fresh cccin.  A bit of a hack ...
  */
 static int yy_did_buffer_switch_on_eof;
 
-void yyrestart YY_PROTO(( FILE *input_file ));
+void cccrestart (FILE *input_file  );
+void ccc_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE ccc_create_buffer (FILE *file,int size  );
+void ccc_delete_buffer (YY_BUFFER_STATE b  );
+void ccc_flush_buffer (YY_BUFFER_STATE b  );
+void cccpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void cccpop_buffer_state (void );
+
+static void cccensure_buffer_stack (void );
+static void ccc_load_buffer_state (void );
+static void ccc_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER ccc_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE ccc_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE ccc_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE ccc_scan_bytes (yyconst char *bytes,int len  );
+
+void *cccalloc (yy_size_t  );
+void *cccrealloc (void *,yy_size_t  );
+void cccfree (void *  );
 
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
-
-#define yy_new_buffer yy_create_buffer
+#define yy_new_buffer ccc_create_buffer
 
 #define yy_set_interactive(is_interactive) \
 	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        cccensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ccc_create_buffer(cccin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
 	}
 
 #define yy_set_bol(at_bol) \
 	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
+	if ( ! YY_CURRENT_BUFFER ){\
+        cccensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ccc_create_buffer(cccin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
 	}
 
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
 
+/* Begin user sect3 */
 
-#define yywrap() 1
+#define cccwrap(n) 1
 #define YY_SKIP_YYWRAP
+
 typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+FILE *cccin = (FILE *) 0, *cccout = (FILE *) 0;
+
 typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
 
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+extern int ccclineno;
+
+int ccclineno = 1;
+
+extern char *ccctext;
+#define yytext_ptr ccctext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
 
 /* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
+ * corresponding action - sets up ccctext.
  */
 #define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
+	(yytext_ptr) = yy_bp; \
+	cccleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
 	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
+	(yy_c_buf_p) = yy_cp;
 
 #define YY_NUM_RULES 97
 #define YY_END_OF_BUFFER 98
-static yyconst short int yy_accept[287] =
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[287] =
     {   0,
         0,    0,   98,   96,   90,   89,   77,   96,   83,   76,
        96,   71,   72,   81,   80,   68,   79,   75,   82,   35,
@@ -341,7 +400,7 @@
        94,   94,   93,   93,   93,    0
     } ;
 
-static yyconst int yy_ec[256] =
+static yyconst flex_int32_t yy_ec[256] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
         2,    2,    2,    1,    1,    1,    1,    1,    1,    1,
@@ -373,7 +432,7 @@
         1,    1,    1,    1,    1
     } ;
 
-static yyconst int yy_meta[71] =
+static yyconst flex_int32_t yy_meta[71] =
     {   0,
         1,    1,    2,    1,    1,    1,    1,    1,    1,    3,
         4,    4,    1,    1,    1,    1,    1,    1,    5,    5,
@@ -384,7 +443,7 @@
         6,    6,    6,    6,    6,    6,    1,    1,    1,    1
     } ;
 
-static yyconst short int yy_base[298] =
+static yyconst flex_int16_t yy_base[298] =
     {   0,
         0,   69,  494,  495,   70,  495,  468,   69,  467,   68,
       452,  495,  495,  465,   64,  495,   65,   63,  464,   92,
@@ -421,7 +480,7 @@
 
     } ;
 
-static yyconst short int yy_def[298] =
+static yyconst flex_int16_t yy_def[298] =
     {   0,
       286,    1,  286,  286,  286,  286,  286,  287,  286,  286,
       288,  286,  286,  286,  286,  286,  286,  286,  286,  286,
@@ -458,7 +517,7 @@
 
     } ;
 
-static yyconst short int yy_nxt[566] =
+static yyconst flex_int16_t yy_nxt[566] =
     {   0,
         4,    5,    6,    5,    7,    8,    4,    9,   10,   11,
        12,   13,   14,   15,   16,   17,   18,   19,   20,   21,
@@ -524,7 +583,7 @@
       286,  286,  286,  286,  286
     } ;
 
-static yyconst short int yy_chk[566] =
+static yyconst flex_int16_t yy_chk[566] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -593,6 +652,9 @@
 static yy_state_type yy_last_accepting_state;
 static char *yy_last_accepting_cpos;
 
+extern int ccc_flex_debug;
+int ccc_flex_debug = 0;
+
 /* The intent behind this definition is that it'll catch
  * any uses of REJECT which flex missed.
  */
@@ -600,9 +662,8 @@
 #define yymore() yymore_used_but_not_detected
 #define YY_MORE_ADJ 0
 #define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
+char *ccctext;
 #line 1 "lex.l"
-#define INITIAL 0
 /* -*-fundamental-*-
  * Authors:  Peter Holst Andersen (txix@diku.dk)
  *           Jens Peter Secher (jpsecher@diku.dk)
@@ -616,7 +677,8 @@
 #line 13 "lex.l"
     #include <stdarg.h>
     #include <stdlib.h>
-    #include <strstream.h>
+    #include <strstream>
+    using std::ostrstream;
     #include "errno.h"
     #include "auxilary.h"
     #include "fileops.h"
@@ -633,8 +695,19 @@
 
     static int typedef_name(char *str);
 
-#define YY_NO_UNPUT 1
-#line 637 "temp"
+#line 698 "temp"
+
+#define INITIAL 0
+
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
 
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
@@ -642,65 +715,28 @@
 
 #ifndef YY_SKIP_YYWRAP
 #ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
+extern "C" int cccwrap (void );
 #else
-extern int yywrap YY_PROTO(( void ));
+extern int cccwrap (void );
 #endif
 #endif
 
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
-
 #ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+static void yy_flex_strncpy (char *,yyconst char *,int );
 #endif
 
 #ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
+static int yy_flex_strlen (yyconst char * );
 #endif
 
 #ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
 
+#ifdef __cplusplus
+static int yyinput (void );
 #else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
+static int input (void );
 #endif
 
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
 #endif
 
 /* Amount of stuff to slurp up with each read. */
@@ -709,12 +745,11 @@
 #endif
 
 /* Copy whatever the last rule matched to the standard output. */
-
 #ifndef ECHO
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#define ECHO (void) fwrite( ccctext, cccleng, 1, cccout )
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -722,21 +757,35 @@
  */
 #ifndef YY_INPUT
 #define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
 		{ \
-		int c = '*', n; \
+		int c = '*'; \
+		size_t n; \
 		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			     (c = getc( cccin )) != EOF && c != '\n'; ++n ) \
 			buf[n] = (char) c; \
 		if ( c == '\n' ) \
 			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
+		if ( c == EOF && ferror( cccin ) ) \
 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
 		result = n; \
 		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, cccin))==0 && ferror(cccin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(cccin); \
+			} \
+		}\
+\
+
 #endif
 
 /* No semi-colon after return; correct usage is to write "yyterminate();" -
@@ -757,14 +806,20 @@
 #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
 #endif
 
+/* end tables serialization structures and prototypes */
+
 /* Default declaration of generated scanner - a define so the user can
  * easily add parameters.
  */
 #ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
+#define YY_DECL_IS_OURS 1
+
+extern int ccclex (void);
+
+#define YY_DECL int ccclex (void)
+#endif /* !YY_DECL */
 
-/* Code executed at the beginning of each rule, after yytext and yyleng
+/* Code executed at the beginning of each rule, after ccctext and cccleng
  * have been set up.
  */
 #ifndef YY_USER_ACTION
@@ -777,59 +832,63 @@
 #endif
 
 #define YY_RULE_SETUP \
-	if ( yyleng > 0 ) \
-		yy_current_buffer->yy_at_bol = \
-				(yytext[yyleng - 1] == '\n'); \
+	if ( cccleng > 0 ) \
+		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
+				(ccctext[cccleng - 1] == '\n'); \
 	YY_USER_ACTION
 
+/** The main scanner function which does all the work.
+ */
 YY_DECL
-	{
+{
 	register yy_state_type yy_current_state;
 	register char *yy_cp, *yy_bp;
 	register int yy_act;
-
-#line 48 "lex.l"
+    
+#line 49 "lex.l"
 
 
-#line 794 "temp"
+#line 851 "temp"
 
-	if ( yy_init )
+	if ( (yy_init) )
 		{
-		yy_init = 0;
+		(yy_init) = 0;
 
 #ifdef YY_USER_INIT
 		YY_USER_INIT;
 #endif
 
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
 
-		if ( ! yyin )
-			yyin = stdin;
+		if ( ! cccin )
+			cccin = stdin;
 
-		if ( ! yyout )
-			yyout = stdout;
+		if ( ! cccout )
+			cccout = stdout;
 
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
+		if ( ! YY_CURRENT_BUFFER ) {
+			cccensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				ccc_create_buffer(cccin,YY_BUF_SIZE );
+		}
 
-		yy_load_buffer_state();
+		ccc_load_buffer_state( );
 		}
 
 	while ( 1 )		/* loops until end-of-file is reached */
 		{
-		yy_cp = yy_c_buf_p;
+		yy_cp = (yy_c_buf_p);
 
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
+		/* Support of ccctext. */
+		*yy_cp = (yy_hold_char);
 
 		/* yy_bp points to the position in yy_ch_buf of the start of
 		 * the current run.
 		 */
 		yy_bp = yy_cp;
 
-		yy_current_state = yy_start;
+		yy_current_state = (yy_start);
 		yy_current_state += YY_AT_BOL();
 yy_match:
 		do
@@ -837,8 +896,8 @@
 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
 			if ( yy_accept[yy_current_state] )
 				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
 				}
 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 				{
@@ -855,200 +914,199 @@
 		yy_act = yy_accept[yy_current_state];
 		if ( yy_act == 0 )
 			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
 			yy_act = yy_accept[yy_current_state];
 			}
 
 		YY_DO_BEFORE_ACTION;
 
-
 do_action:	/* This label is used only to access EOF actions. */
 
-
 		switch ( yy_act )
 	{ /* beginning of action switch */
 			case 0: /* must back up */
 			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
 			goto yy_find_action;
 
 case 1:
 YY_RULE_SETUP
-#line 50 "lex.l"
+#line 51 "lex.l"
 { return (AUTO); }
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 51 "lex.l"
+#line 52 "lex.l"
 { return (BREAK); }
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 52 "lex.l"
+#line 53 "lex.l"
 { return (CASE); }
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 53 "lex.l"
+#line 54 "lex.l"
 { return (CHAR); }
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 54 "lex.l"
+#line 55 "lex.l"
 { return (CONST); }
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 55 "lex.l"
+#line 56 "lex.l"
 { return (CONTINUE); }
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 56 "lex.l"
+#line 57 "lex.l"
 { return (DEFAULT); }
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 57 "lex.l"
+#line 58 "lex.l"
 { return (DO); }
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 58 "lex.l"
+#line 59 "lex.l"
 { return (DOUBLE);}
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 59 "lex.l"
+#line 60 "lex.l"
 { return (ELSE); }
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 60 "lex.l"
+#line 61 "lex.l"
 { return (ENUM); }
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 61 "lex.l"
+#line 62 "lex.l"
 { return (EXTERN); }
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 62 "lex.l"
+#line 63 "lex.l"
 { return (FLOAT);}
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 63 "lex.l"
+#line 64 "lex.l"
 { return (FOR); }
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 64 "lex.l"
+#line 65 "lex.l"
 { return (GOTO); }
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 65 "lex.l"
+#line 66 "lex.l"
 { return (IF); }
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 66 "lex.l"
+#line 67 "lex.l"
 { return (INT); }
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 67 "lex.l"
+#line 68 "lex.l"
 { return (LONG); }
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 68 "lex.l"
+#line 69 "lex.l"
 { return (REGISTER); }
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 69 "lex.l"
+#line 70 "lex.l"
 { return (RETURN); }
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 70 "lex.l"
+#line 71 "lex.l"
 { return (SHORT); }
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 71 "lex.l"
+#line 72 "lex.l"
 { return (SIGNED); }
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 72 "lex.l"
+#line 73 "lex.l"
 { return (SIZEOF); }
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 73 "lex.l"
+#line 74 "lex.l"
 { return (STATIC); }
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 74 "lex.l"
+#line 75 "lex.l"
 { return (STRUCT); }
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 75 "lex.l"
+#line 76 "lex.l"
 { return (SWITCH); }
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 76 "lex.l"
+#line 77 "lex.l"
 { return (TYPEDEF); }
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 77 "lex.l"
+#line 78 "lex.l"
 { return (UNION); }
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 78 "lex.l"
+#line 79 "lex.l"
 { return (UNSIGNED); }
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 79 "lex.l"
+#line 80 "lex.l"
 { return (VOID); }
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 80 "lex.l"
+#line 81 "lex.l"
 { return (VOLATILE); }
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 81 "lex.l"
+#line 82 "lex.l"
 { return (WHILE); }
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
-#line 83 "lex.l"
-{ yylval.str = strdup(yytext);
-                          if (typedef_name(yytext))
+#line 84 "lex.l"
+{ yylval.str = strdup(ccctext);
+                          if (typedef_name(ccctext))
 			      return (TYPEDEFname);
                           else
 			      return (IDENTIFIER); 
 		 	}
 	YY_BREAK
 case 34:
+/* rule 34 can match eol */
 YY_RULE_SETUP
-#line 89 "lex.l"
-{ char const *cp = yytext+6 ;
+#line 90 "lex.l"
+{ char const *cp = ccctext+6 ;
                           while(*cp != '(') cp++ ;
                           yylval.str = strdup(cp+1);
                           return CMIXTAG;
@@ -1056,297 +1114,301 @@
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 94 "lex.l"
-{ yylval.str = strdup(yytext); return (INTEGERconstant); }
+#line 95 "lex.l"
+{ yylval.str = strdup(ccctext); return (INTEGERconstant); }
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
-#line 96 "lex.l"
-{ yylval.str = strdup(yytext); return (UINTEGERconstant); }
+#line 97 "lex.l"
+{ yylval.str = strdup(ccctext); return (UINTEGERconstant); }
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
-#line 98 "lex.l"
-{ yylval.str = strdup(yytext); return (LONGconstant); }
+#line 99 "lex.l"
+{ yylval.str = strdup(ccctext); return (LONGconstant); }
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
-#line 100 "lex.l"
-{ yylval.str = strdup(yytext); return (ULONGconstant); }
+#line 101 "lex.l"
+{ yylval.str = strdup(ccctext); return (ULONGconstant); }
 	YY_BREAK
 case 39:
+/* rule 39 can match eol */
 YY_RULE_SETUP
-#line 102 "lex.l"
-{ yylval.str = strdup(yytext); return (CHARACTERconstant); }
+#line 103 "lex.l"
+{ yylval.str = strdup(ccctext); return (CHARACTERconstant); }
 	YY_BREAK
 case 40:
 YY_RULE_SETUP
-#line 104 "lex.l"
-{ yylval.str = strdup(yytext); return (FLOATINGconstant); }
+#line 105 "lex.l"
+{ yylval.str = strdup(ccctext); return (FLOATINGconstant); }
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
-#line 106 "lex.l"
-{ yylval.str = strdup(yytext); return (DOUBLEconstant); }
+#line 107 "lex.l"
+{ yylval.str = strdup(ccctext); return (DOUBLEconstant); }
 	YY_BREAK
 case 42:
+/* rule 42 can match eol */
 YY_RULE_SETUP
-#line 108 "lex.l"
-{ yylval.str = strdup(yytext); return (STRINGliteral); }
+#line 109 "lex.l"
+{ yylval.str = strdup(ccctext); return (STRINGliteral); }
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
-#line 110 "lex.l"
+#line 111 "lex.l"
 { return (ELLIPSIS); }
 	YY_BREAK
 case 44:
 YY_RULE_SETUP
-#line 111 "lex.l"
+#line 112 "lex.l"
 { return (RSassign); }
 	YY_BREAK
 case 45:
 YY_RULE_SETUP
-#line 112 "lex.l"
+#line 113 "lex.l"
 { return (LSassign); }
 	YY_BREAK
 case 46:
 YY_RULE_SETUP
-#line 113 "lex.l"
+#line 114 "lex.l"
 { return (PLUSassign); }
 	YY_BREAK
 case 47:
 YY_RULE_SETUP
-#line 114 "lex.l"
+#line 115 "lex.l"
 { return (MINUSassign); }
 	YY_BREAK
 case 48:
 YY_RULE_SETUP
-#line 115 "lex.l"
+#line 116 "lex.l"
 { return (MULTassign); }
 	YY_BREAK
 case 49:
 YY_RULE_SETUP
-#line 116 "lex.l"
+#line 117 "lex.l"
 { return (DIVassign); }
 	YY_BREAK
 case 50:
 YY_RULE_SETUP
-#line 117 "lex.l"
+#line 118 "lex.l"
 { return (MODassign); }
 	YY_BREAK
 case 51:
 YY_RULE_SETUP
-#line 118 "lex.l"
+#line 119 "lex.l"
 { return (ANDassign); }
 	YY_BREAK
 case 52:
 YY_RULE_SETUP
-#line 119 "lex.l"
+#line 120 "lex.l"
 { return (ERassign); }
 	YY_BREAK
 case 53:
 YY_RULE_SETUP
-#line 120 "lex.l"
+#line 121 "lex.l"
 { return (ORassign); }
 	YY_BREAK
 case 54:
 YY_RULE_SETUP
-#line 121 "lex.l"
+#line 122 "lex.l"
 { return (RIGHTSHIFT); }
 	YY_BREAK
 case 55:
 YY_RULE_SETUP
-#line 122 "lex.l"
+#line 123 "lex.l"
 { return (LEFTSHIFT); }
 	YY_BREAK
 case 56:
 YY_RULE_SETUP
-#line 123 "lex.l"
+#line 124 "lex.l"
 { return (ICR); }
 	YY_BREAK
 case 57:
 YY_RULE_SETUP
-#line 124 "lex.l"
+#line 125 "lex.l"
 { return (DECR); }
 	YY_BREAK
 case 58:
 YY_RULE_SETUP
-#line 125 "lex.l"
+#line 126 "lex.l"
 { return (ARROW); }
 	YY_BREAK
 case 59:
 YY_RULE_SETUP
-#line 126 "lex.l"
+#line 127 "lex.l"
 { return (ANDAND); }
 	YY_BREAK
 case 60:
 YY_RULE_SETUP
-#line 127 "lex.l"
+#line 128 "lex.l"
 { return (OROR); }
 	YY_BREAK
 case 61:
 YY_RULE_SETUP
-#line 128 "lex.l"
+#line 129 "lex.l"
 { return (LESSEQUAL); }
 	YY_BREAK
 case 62:
 YY_RULE_SETUP
-#line 129 "lex.l"
+#line 130 "lex.l"
 { return (GREATEQUAL); }
 	YY_BREAK
 case 63:
 YY_RULE_SETUP
-#line 130 "lex.l"
+#line 131 "lex.l"
 { return (EQUAL); }
 	YY_BREAK
 case 64:
 YY_RULE_SETUP
-#line 131 "lex.l"
+#line 132 "lex.l"
 { return (NOTEQUAL); }
 	YY_BREAK
 case 65:
 YY_RULE_SETUP
-#line 132 "lex.l"
+#line 133 "lex.l"
 { return(';'); }
 	YY_BREAK
 case 66:
 YY_RULE_SETUP
-#line 133 "lex.l"
+#line 134 "lex.l"
 { return('{'); }
 	YY_BREAK
 case 67:
 YY_RULE_SETUP
-#line 134 "lex.l"
+#line 135 "lex.l"
 { return('}'); }
 	YY_BREAK
 case 68:
 YY_RULE_SETUP
-#line 135 "lex.l"
+#line 136 "lex.l"
 { return(','); }
 	YY_BREAK
 case 69:
 YY_RULE_SETUP
-#line 136 "lex.l"
+#line 137 "lex.l"
 { return(':'); }
 	YY_BREAK
 case 70:
 YY_RULE_SETUP
-#line 137 "lex.l"
+#line 138 "lex.l"
 { return('='); }
 	YY_BREAK
 case 71:
 YY_RULE_SETUP
-#line 138 "lex.l"
+#line 139 "lex.l"
 { return('('); }
 	YY_BREAK
 case 72:
 YY_RULE_SETUP
-#line 139 "lex.l"
+#line 140 "lex.l"
 { return(')'); }
 	YY_BREAK
 case 73:
 YY_RULE_SETUP
-#line 140 "lex.l"
+#line 141 "lex.l"
 { return('['); }
 	YY_BREAK
 case 74:
 YY_RULE_SETUP
-#line 141 "lex.l"
+#line 142 "lex.l"
 { return(']'); }
 	YY_BREAK
 case 75:
 YY_RULE_SETUP
-#line 142 "lex.l"
+#line 143 "lex.l"
 { return('.'); }
 	YY_BREAK
 case 76:
 YY_RULE_SETUP
-#line 143 "lex.l"
+#line 144 "lex.l"
 { return('&'); }
 	YY_BREAK
 case 77:
 YY_RULE_SETUP
-#line 144 "lex.l"
+#line 145 "lex.l"
 { return('!'); }
 	YY_BREAK
 case 78:
 YY_RULE_SETUP
-#line 145 "lex.l"
+#line 146 "lex.l"
 { return('~'); }
 	YY_BREAK
 case 79:
 YY_RULE_SETUP
-#line 146 "lex.l"
+#line 147 "lex.l"
 { return('-'); }
 	YY_BREAK
 case 80:
 YY_RULE_SETUP
-#line 147 "lex.l"
+#line 148 "lex.l"
 { return('+'); }
 	YY_BREAK
 case 81:
 YY_RULE_SETUP
-#line 148 "lex.l"
+#line 149 "lex.l"
 { return('*'); }
 	YY_BREAK
 case 82:
 YY_RULE_SETUP
-#line 149 "lex.l"
+#line 150 "lex.l"
 { return('/'); }
 	YY_BREAK
 case 83:
 YY_RULE_SETUP
-#line 150 "lex.l"
+#line 151 "lex.l"
 { return('%'); }
 	YY_BREAK
 case 84:
 YY_RULE_SETUP
-#line 151 "lex.l"
+#line 152 "lex.l"
 { return('<'); }
 	YY_BREAK
 case 85:
 YY_RULE_SETUP
-#line 152 "lex.l"
+#line 153 "lex.l"
 { return('>'); }
 	YY_BREAK
 case 86:
 YY_RULE_SETUP
-#line 153 "lex.l"
+#line 154 "lex.l"
 { return('^'); }
 	YY_BREAK
 case 87:
 YY_RULE_SETUP
-#line 154 "lex.l"
+#line 155 "lex.l"
 { return('|'); }
 	YY_BREAK
 case 88:
 YY_RULE_SETUP
-#line 155 "lex.l"
+#line 156 "lex.l"
 { return('?'); }
 	YY_BREAK
 case 89:
+/* rule 89 can match eol */
 YY_RULE_SETUP
-#line 157 "lex.l"
+#line 158 "lex.l"
 { ccchere++; }
 	YY_BREAK
 case 90:
 YY_RULE_SETUP
-#line 158 "lex.l"
+#line 159 "lex.l"
 {  }
 	YY_BREAK
 case 91:
+/* rule 91 can match eol */
 YY_RULE_SETUP
-#line 159 "lex.l"
+#line 160 "lex.l"
 {
-    			  if (strlen(yytext) > 1024) {
+    			  if (strlen(ccctext) > 1024) {
                               Diagnostic(WARNING,ccchere)
                                  << "truncating filename (> 1024)";
-			      yytext[1024] = 0;
+			      ccctext[1024] = 0;
 			  }
                           {
                               int newlineno ;
                               char newfilename[1024] ;
-    			      sscanf(yytext, "# %d \"%[^\"]",
+    			      sscanf(ccctext, "# %d \"%[^\"]",
                                    &newlineno, newfilename);
                               ccchere = newfilename ;
 			      ccchere = newlineno ;
