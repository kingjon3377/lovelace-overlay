--- cmix-2.0.12.orig/src/analyzer/lex-yy.cc
+++ cmix-2.0.12/src/analyzer/lex-yy.cc
@@ -1,51 +1,87 @@
 #include <cmixconf.h>
-#define yy_create_buffer ccc_create_buffer
-#define yy_delete_buffer ccc_delete_buffer
-#define yy_scan_buffer ccc_scan_buffer
-#define yy_scan_string ccc_scan_string
-#define yy_scan_bytes ccc_scan_bytes
-#define yy_flex_debug ccc_flex_debug
-#define yy_init_buffer ccc_init_buffer
-#define yy_flush_buffer ccc_flush_buffer
-#define yy_load_buffer_state ccc_load_buffer_state
-#define yy_switch_to_buffer ccc_switch_to_buffer
-#define yyin cccin
-#define yyleng cccleng
-#define yylex ccclex
-#define yyout cccout
-#define yyrestart cccrestart
-#define yytext ccctext
+#line 2 "temp"
 
-#line 19 "temp"
-/* A lexical scanner generated by flex */
+#line 4 "temp"
 
-/* Scanner skeleton version:
- * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.89 96/05/25 21:02:21 vern Exp $
- */
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
 
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 31
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
 
+/* begin standard C headers. */
 #include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
 
+/* end standard C headers. */
 
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
 #endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
 #endif
 
+#endif /* ! FLEXINT_H */
 
 #ifdef __cplusplus
 
-#include <stdlib.h>
-#include <unistd.h>
-
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
-
 /* The "const" storage-class-modifier is valid. */
 #define YY_USE_CONST
 
@@ -53,34 +89,17 @@
 
 #if __STDC__
 
-#define YY_USE_PROTOS
 #define YY_USE_CONST
 
 #endif	/* __STDC__ */
 #endif	/* ! __cplusplus */
 
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
 #ifdef YY_USE_CONST
 #define yyconst const
 #else
 #define yyconst
 #endif
 
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
 /* Returned upon end-of-file. */
 #define YY_NULL 0
 
@@ -95,71 +114,71 @@
  * but we do it the disgusting crufty way forced on us by the ()-less
  * definition of BEGIN.
  */
-#define BEGIN yy_start = 1 + 2 *
+#define BEGIN (yy_start) = 1 + 2 *
 
 /* Translate the current start state into a value that can be later handed
  * to BEGIN to return to the state.  The YYSTATE alias is for lex
  * compatibility.
  */
-#define YY_START ((yy_start - 1) / 2)
+#define YY_START (((yy_start) - 1) / 2)
 #define YYSTATE YY_START
 
 /* Action number for EOF rule of a given start state. */
 #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
 
 /* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
+#define YY_NEW_FILE cccrestart(cccin  )
 
 #define YY_END_OF_BUFFER_CHAR 0
 
 /* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
 #define YY_BUF_SIZE 16384
+#endif
 
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
 typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
 
-extern int yyleng;
-extern FILE *yyin, *yyout;
+extern int cccleng;
+
+extern FILE *cccin, *cccout;
 
 #define EOB_ACT_CONTINUE_SCAN 0
 #define EOB_ACT_END_OF_FILE 1
 #define EOB_ACT_LAST_MATCH 2
 
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
 	do \
 		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
+		/* Undo effects of setting up ccctext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
 		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up ccctext again */ \
 		} \
 	while ( 0 )
 
-#define unput(c) yyunput( c, yytext_ptr )
+#define unput(c) yyunput( c, (yytext_ptr)  )
 
 /* The following is because we cannot portably get our hands on size_t
  * (without autoconf's help, which isn't available because we want
  * flex-generated scanners to compile on their own).
  */
-typedef unsigned int yy_size_t;
 
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef unsigned int yy_size_t;
+#endif
 
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
 struct yy_buffer_state
 	{
 	FILE *yy_input_file;
@@ -196,12 +215,16 @@
 	 */
 	int yy_at_bol;
 
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
 	int yy_fill_buffer;
 
 	int yy_buffer_status;
+
 #define YY_BUFFER_NEW 0
 #define YY_BUFFER_NORMAL 1
 	/* When an EOF's been seen but there's still some text to process
@@ -211,102 +234,138 @@
 	 * possible backing-up.
 	 *
 	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
+	 * (via cccrestart()), so that the user can continue scanning by
+	 * just pointing cccin at a new input file.
 	 */
 #define YY_BUFFER_EOF_PENDING 2
+
 	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
 
-static YY_BUFFER_STATE yy_current_buffer = 0;
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
 
 /* We provide macros for accessing buffer states in case in the
  * future we want to put the buffer states in a more general
  * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
  */
-#define YY_CURRENT_BUFFER yy_current_buffer
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
 
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
 
-/* yy_hold_char holds the character lost when yytext is formed. */
+/* yy_hold_char holds the character lost when ccctext is formed. */
 static char yy_hold_char;
-
 static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
+int cccleng;
 
 /* Points to current character in buffer. */
 static char *yy_c_buf_p = (char *) 0;
 static int yy_init = 1;		/* whether we need to initialize */
 static int yy_start = 0;	/* start state number */
 
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
+/* Flag which is used to allow cccwrap()'s to do buffer switches
+ * instead of setting up a fresh cccin.  A bit of a hack ...
  */
 static int yy_did_buffer_switch_on_eof;
 
-void yyrestart YY_PROTO(( FILE *input_file ));
+void cccrestart (FILE *input_file  );
+void ccc_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE ccc_create_buffer (FILE *file,int size  );
+void ccc_delete_buffer (YY_BUFFER_STATE b  );
+void ccc_flush_buffer (YY_BUFFER_STATE b  );
+void cccpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void cccpop_buffer_state (void );
+
+static void cccensure_buffer_stack (void );
+static void ccc_load_buffer_state (void );
+static void ccc_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER ccc_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE ccc_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE ccc_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE ccc_scan_bytes (yyconst char *bytes,int len  );
+
+void *cccalloc (yy_size_t  );
+void *cccrealloc (void *,yy_size_t  );
+void cccfree (void *  );
 
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
-
-#define yy_new_buffer yy_create_buffer
+#define yy_new_buffer ccc_create_buffer
 
 #define yy_set_interactive(is_interactive) \
 	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        cccensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ccc_create_buffer(cccin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
 	}
 
 #define yy_set_bol(at_bol) \
 	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
+	if ( ! YY_CURRENT_BUFFER ){\
+        cccensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ccc_create_buffer(cccin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
 	}
 
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
 
+/* Begin user sect3 */
 
-#define yywrap() 1
+#define cccwrap(n) 1
 #define YY_SKIP_YYWRAP
+
 typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+FILE *cccin = (FILE *) 0, *cccout = (FILE *) 0;
+
 typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
 
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+extern int ccclineno;
+
+int ccclineno = 1;
+
+extern char *ccctext;
+#define yytext_ptr ccctext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
 
 /* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
+ * corresponding action - sets up ccctext.
  */
 #define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
+	(yytext_ptr) = yy_bp; \
+	cccleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
 	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
+	(yy_c_buf_p) = yy_cp;
 
 #define YY_NUM_RULES 97
 #define YY_END_OF_BUFFER 98
-static yyconst short int yy_accept[287] =
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[287] =
     {   0,
         0,    0,   98,   96,   90,   89,   77,   96,   83,   76,
        96,   71,   72,   81,   80,   68,   79,   75,   82,   35,
@@ -341,7 +400,7 @@
        94,   94,   93,   93,   93,    0
     } ;
 
-static yyconst int yy_ec[256] =
+static yyconst flex_int32_t yy_ec[256] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
         2,    2,    2,    1,    1,    1,    1,    1,    1,    1,
@@ -373,7 +432,7 @@
         1,    1,    1,    1,    1
     } ;
 
-static yyconst int yy_meta[71] =
+static yyconst flex_int32_t yy_meta[71] =
     {   0,
         1,    1,    2,    1,    1,    1,    1,    1,    1,    3,
         4,    4,    1,    1,    1,    1,    1,    1,    5,    5,
@@ -384,7 +443,7 @@
         6,    6,    6,    6,    6,    6,    1,    1,    1,    1
     } ;
 
-static yyconst short int yy_base[298] =
+static yyconst flex_int16_t yy_base[298] =
     {   0,
         0,   69,  494,  495,   70,  495,  468,   69,  467,   68,
       452,  495,  495,  465,   64,  495,   65,   63,  464,   92,
@@ -421,7 +480,7 @@
 
     } ;
 
-static yyconst short int yy_def[298] =
+static yyconst flex_int16_t yy_def[298] =
     {   0,
       286,    1,  286,  286,  286,  286,  286,  287,  286,  286,
       288,  286,  286,  286,  286,  286,  286,  286,  286,  286,
@@ -458,7 +517,7 @@
 
     } ;
 
-static yyconst short int yy_nxt[566] =
+static yyconst flex_int16_t yy_nxt[566] =
     {   0,
         4,    5,    6,    5,    7,    8,    4,    9,   10,   11,
        12,   13,   14,   15,   16,   17,   18,   19,   20,   21,
@@ -524,7 +583,7 @@
       286,  286,  286,  286,  286
     } ;
 
-static yyconst short int yy_chk[566] =
+static yyconst flex_int16_t yy_chk[566] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -593,6 +652,9 @@
 static yy_state_type yy_last_accepting_state;
 static char *yy_last_accepting_cpos;
 
+extern int ccc_flex_debug;
+int ccc_flex_debug = 0;
+
 /* The intent behind this definition is that it'll catch
  * any uses of REJECT which flex missed.
  */
@@ -600,9 +662,8 @@
 #define yymore() yymore_used_but_not_detected
 #define YY_MORE_ADJ 0
 #define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
+char *ccctext;
 #line 1 "lex.l"
-#define INITIAL 0
 /* -*-fundamental-*-
  * Authors:  Peter Holst Andersen (txix@diku.dk)
  *           Jens Peter Secher (jpsecher@diku.dk)
@@ -616,7 +677,8 @@
 #line 13 "lex.l"
     #include <stdarg.h>
     #include <stdlib.h>
-    #include <strstream.h>
+    #include <strstream>
+    using std::ostrstream;
     #include "errno.h"
     #include "auxilary.h"
     #include "fileops.h"
@@ -633,8 +695,19 @@
 
     static int typedef_name(char *str);
 
-#define YY_NO_UNPUT 1
-#line 637 "temp"
+#line 698 "temp"
+
+#define INITIAL 0
+
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
 
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
@@ -642,65 +715,28 @@
 
 #ifndef YY_SKIP_YYWRAP
 #ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
+extern "C" int cccwrap (void );
 #else
-extern int yywrap YY_PROTO(( void ));
+extern int cccwrap (void );
 #endif
 #endif
 
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
-
 #ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+static void yy_flex_strncpy (char *,yyconst char *,int );
 #endif
 
 #ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
+static int yy_flex_strlen (yyconst char * );
 #endif
 
 #ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
 
+#ifdef __cplusplus
+static int yyinput (void );
 #else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
+static int input (void );
 #endif
 
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
 #endif
 
 /* Amount of stuff to slurp up with each read. */
@@ -709,12 +745,11 @@
 #endif
 
 /* Copy whatever the last rule matched to the standard output. */
-
 #ifndef ECHO
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#define ECHO (void) fwrite( ccctext, cccleng, 1, cccout )
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -722,21 +757,35 @@
  */
 #ifndef YY_INPUT
 #define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
 		{ \
-		int c = '*', n; \
+		int c = '*'; \
+		size_t n; \
 		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			     (c = getc( cccin )) != EOF && c != '\n'; ++n ) \
 			buf[n] = (char) c; \
 		if ( c == '\n' ) \
 			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
+		if ( c == EOF && ferror( cccin ) ) \
 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
 		result = n; \
 		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, cccin))==0 && ferror(cccin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(cccin); \
+			} \
+		}\
+\
+
 #endif
 
 /* No semi-colon after return; correct usage is to write "yyterminate();" -
@@ -757,14 +806,20 @@
 #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
 #endif
 
+/* end tables serialization structures and prototypes */
+
 /* Default declaration of generated scanner - a define so the user can
  * easily add parameters.
  */
 #ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
+#define YY_DECL_IS_OURS 1
+
+extern int ccclex (void);
+
+#define YY_DECL int ccclex (void)
+#endif /* !YY_DECL */
 
-/* Code executed at the beginning of each rule, after yytext and yyleng
+/* Code executed at the beginning of each rule, after ccctext and cccleng
  * have been set up.
  */
 #ifndef YY_USER_ACTION
@@ -777,59 +832,63 @@
 #endif
 
 #define YY_RULE_SETUP \
-	if ( yyleng > 0 ) \
-		yy_current_buffer->yy_at_bol = \
-				(yytext[yyleng - 1] == '\n'); \
+	if ( cccleng > 0 ) \
+		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
+				(ccctext[cccleng - 1] == '\n'); \
 	YY_USER_ACTION
 
+/** The main scanner function which does all the work.
+ */
 YY_DECL
-	{
+{
 	register yy_state_type yy_current_state;
 	register char *yy_cp, *yy_bp;
 	register int yy_act;
-
-#line 48 "lex.l"
+    
+#line 49 "lex.l"
 
 
-#line 794 "temp"
+#line 851 "temp"
 
-	if ( yy_init )
+	if ( (yy_init) )
 		{
-		yy_init = 0;
+		(yy_init) = 0;
 
 #ifdef YY_USER_INIT
 		YY_USER_INIT;
 #endif
 
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
 
-		if ( ! yyin )
-			yyin = stdin;
+		if ( ! cccin )
+			cccin = stdin;
 
-		if ( ! yyout )
-			yyout = stdout;
+		if ( ! cccout )
+			cccout = stdout;
 
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
+		if ( ! YY_CURRENT_BUFFER ) {
+			cccensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				ccc_create_buffer(cccin,YY_BUF_SIZE );
+		}
 
-		yy_load_buffer_state();
+		ccc_load_buffer_state( );
 		}
 
 	while ( 1 )		/* loops until end-of-file is reached */
 		{
-		yy_cp = yy_c_buf_p;
+		yy_cp = (yy_c_buf_p);
 
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
+		/* Support of ccctext. */
+		*yy_cp = (yy_hold_char);
 
 		/* yy_bp points to the position in yy_ch_buf of the start of
 		 * the current run.
 		 */
 		yy_bp = yy_cp;
 
-		yy_current_state = yy_start;
+		yy_current_state = (yy_start);
 		yy_current_state += YY_AT_BOL();
 yy_match:
 		do
@@ -837,8 +896,8 @@
 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
 			if ( yy_accept[yy_current_state] )
 				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
 				}
 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 				{
@@ -855,200 +914,199 @@
 		yy_act = yy_accept[yy_current_state];
 		if ( yy_act == 0 )
 			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
 			yy_act = yy_accept[yy_current_state];
 			}
 
 		YY_DO_BEFORE_ACTION;
 
-
 do_action:	/* This label is used only to access EOF actions. */
 
-
 		switch ( yy_act )
 	{ /* beginning of action switch */
 			case 0: /* must back up */
 			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
 			goto yy_find_action;
 
 case 1:
 YY_RULE_SETUP
-#line 50 "lex.l"
+#line 51 "lex.l"
 { return (AUTO); }
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 51 "lex.l"
+#line 52 "lex.l"
 { return (BREAK); }
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 52 "lex.l"
+#line 53 "lex.l"
 { return (CASE); }
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 53 "lex.l"
+#line 54 "lex.l"
 { return (CHAR); }
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 54 "lex.l"
+#line 55 "lex.l"
 { return (CONST); }
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 55 "lex.l"
+#line 56 "lex.l"
 { return (CONTINUE); }
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 56 "lex.l"
+#line 57 "lex.l"
 { return (DEFAULT); }
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 57 "lex.l"
+#line 58 "lex.l"
 { return (DO); }
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 58 "lex.l"
+#line 59 "lex.l"
 { return (DOUBLE);}
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 59 "lex.l"
+#line 60 "lex.l"
 { return (ELSE); }
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 60 "lex.l"
+#line 61 "lex.l"
 { return (ENUM); }
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 61 "lex.l"
+#line 62 "lex.l"
 { return (EXTERN); }
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 62 "lex.l"
+#line 63 "lex.l"
 { return (FLOAT);}
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 63 "lex.l"
+#line 64 "lex.l"
 { return (FOR); }
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 64 "lex.l"
+#line 65 "lex.l"
 { return (GOTO); }
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 65 "lex.l"
+#line 66 "lex.l"
 { return (IF); }
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 66 "lex.l"
+#line 67 "lex.l"
 { return (INT); }
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 67 "lex.l"
+#line 68 "lex.l"
 { return (LONG); }
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 68 "lex.l"
+#line 69 "lex.l"
 { return (REGISTER); }
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 69 "lex.l"
+#line 70 "lex.l"
 { return (RETURN); }
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 70 "lex.l"
+#line 71 "lex.l"
 { return (SHORT); }
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 71 "lex.l"
+#line 72 "lex.l"
 { return (SIGNED); }
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 72 "lex.l"
+#line 73 "lex.l"
 { return (SIZEOF); }
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 73 "lex.l"
+#line 74 "lex.l"
 { return (STATIC); }
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 74 "lex.l"
+#line 75 "lex.l"
 { return (STRUCT); }
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 75 "lex.l"
+#line 76 "lex.l"
 { return (SWITCH); }
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 76 "lex.l"
+#line 77 "lex.l"
 { return (TYPEDEF); }
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 77 "lex.l"
+#line 78 "lex.l"
 { return (UNION); }
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 78 "lex.l"
+#line 79 "lex.l"
 { return (UNSIGNED); }
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 79 "lex.l"
+#line 80 "lex.l"
 { return (VOID); }
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 80 "lex.l"
+#line 81 "lex.l"
 { return (VOLATILE); }
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 81 "lex.l"
+#line 82 "lex.l"
 { return (WHILE); }
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
-#line 83 "lex.l"
-{ yylval.str = strdup(yytext);
-                          if (typedef_name(yytext))
+#line 84 "lex.l"
+{ yylval.str = strdup(ccctext);
+                          if (typedef_name(ccctext))
 			      return (TYPEDEFname);
                           else
 			      return (IDENTIFIER); 
 		 	}
 	YY_BREAK
 case 34:
+/* rule 34 can match eol */
 YY_RULE_SETUP
-#line 89 "lex.l"
-{ char const *cp = yytext+6 ;
+#line 90 "lex.l"
+{ char const *cp = ccctext+6 ;
                           while(*cp != '(') cp++ ;
                           yylval.str = strdup(cp+1);
                           return CMIXTAG;
@@ -1056,297 +1114,301 @@
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 94 "lex.l"
-{ yylval.str = strdup(yytext); return (INTEGERconstant); }
+#line 95 "lex.l"
+{ yylval.str = strdup(ccctext); return (INTEGERconstant); }
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
-#line 96 "lex.l"
-{ yylval.str = strdup(yytext); return (UINTEGERconstant); }
+#line 97 "lex.l"
+{ yylval.str = strdup(ccctext); return (UINTEGERconstant); }
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
-#line 98 "lex.l"
-{ yylval.str = strdup(yytext); return (LONGconstant); }
+#line 99 "lex.l"
+{ yylval.str = strdup(ccctext); return (LONGconstant); }
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
-#line 100 "lex.l"
-{ yylval.str = strdup(yytext); return (ULONGconstant); }
+#line 101 "lex.l"
+{ yylval.str = strdup(ccctext); return (ULONGconstant); }
 	YY_BREAK
 case 39:
+/* rule 39 can match eol */
 YY_RULE_SETUP
-#line 102 "lex.l"
-{ yylval.str = strdup(yytext); return (CHARACTERconstant); }
+#line 103 "lex.l"
+{ yylval.str = strdup(ccctext); return (CHARACTERconstant); }
 	YY_BREAK
 case 40:
 YY_RULE_SETUP
-#line 104 "lex.l"
-{ yylval.str = strdup(yytext); return (FLOATINGconstant); }
+#line 105 "lex.l"
+{ yylval.str = strdup(ccctext); return (FLOATINGconstant); }
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
-#line 106 "lex.l"
-{ yylval.str = strdup(yytext); return (DOUBLEconstant); }
+#line 107 "lex.l"
+{ yylval.str = strdup(ccctext); return (DOUBLEconstant); }
 	YY_BREAK
 case 42:
+/* rule 42 can match eol */
 YY_RULE_SETUP
-#line 108 "lex.l"
-{ yylval.str = strdup(yytext); return (STRINGliteral); }
+#line 109 "lex.l"
+{ yylval.str = strdup(ccctext); return (STRINGliteral); }
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
-#line 110 "lex.l"
+#line 111 "lex.l"
 { return (ELLIPSIS); }
 	YY_BREAK
 case 44:
 YY_RULE_SETUP
-#line 111 "lex.l"
+#line 112 "lex.l"
 { return (RSassign); }
 	YY_BREAK
 case 45:
 YY_RULE_SETUP
-#line 112 "lex.l"
+#line 113 "lex.l"
 { return (LSassign); }
 	YY_BREAK
 case 46:
 YY_RULE_SETUP
-#line 113 "lex.l"
+#line 114 "lex.l"
 { return (PLUSassign); }
 	YY_BREAK
 case 47:
 YY_RULE_SETUP
-#line 114 "lex.l"
+#line 115 "lex.l"
 { return (MINUSassign); }
 	YY_BREAK
 case 48:
 YY_RULE_SETUP
-#line 115 "lex.l"
+#line 116 "lex.l"
 { return (MULTassign); }
 	YY_BREAK
 case 49:
 YY_RULE_SETUP
-#line 116 "lex.l"
+#line 117 "lex.l"
 { return (DIVassign); }
 	YY_BREAK
 case 50:
 YY_RULE_SETUP
-#line 117 "lex.l"
+#line 118 "lex.l"
 { return (MODassign); }
 	YY_BREAK
 case 51:
 YY_RULE_SETUP
-#line 118 "lex.l"
+#line 119 "lex.l"
 { return (ANDassign); }
 	YY_BREAK
 case 52:
 YY_RULE_SETUP
-#line 119 "lex.l"
+#line 120 "lex.l"
 { return (ERassign); }
 	YY_BREAK
 case 53:
 YY_RULE_SETUP
-#line 120 "lex.l"
+#line 121 "lex.l"
 { return (ORassign); }
 	YY_BREAK
 case 54:
 YY_RULE_SETUP
-#line 121 "lex.l"
+#line 122 "lex.l"
 { return (RIGHTSHIFT); }
 	YY_BREAK
 case 55:
 YY_RULE_SETUP
-#line 122 "lex.l"
+#line 123 "lex.l"
 { return (LEFTSHIFT); }
 	YY_BREAK
 case 56:
 YY_RULE_SETUP
-#line 123 "lex.l"
+#line 124 "lex.l"
 { return (ICR); }
 	YY_BREAK
 case 57:
 YY_RULE_SETUP
-#line 124 "lex.l"
+#line 125 "lex.l"
 { return (DECR); }
 	YY_BREAK
 case 58:
 YY_RULE_SETUP
-#line 125 "lex.l"
+#line 126 "lex.l"
 { return (ARROW); }
 	YY_BREAK
 case 59:
 YY_RULE_SETUP
-#line 126 "lex.l"
+#line 127 "lex.l"
 { return (ANDAND); }
 	YY_BREAK
 case 60:
 YY_RULE_SETUP
-#line 127 "lex.l"
+#line 128 "lex.l"
 { return (OROR); }
 	YY_BREAK
 case 61:
 YY_RULE_SETUP
-#line 128 "lex.l"
+#line 129 "lex.l"
 { return (LESSEQUAL); }
 	YY_BREAK
 case 62:
 YY_RULE_SETUP
-#line 129 "lex.l"
+#line 130 "lex.l"
 { return (GREATEQUAL); }
 	YY_BREAK
 case 63:
 YY_RULE_SETUP
-#line 130 "lex.l"
+#line 131 "lex.l"
 { return (EQUAL); }
 	YY_BREAK
 case 64:
 YY_RULE_SETUP
-#line 131 "lex.l"
+#line 132 "lex.l"
 { return (NOTEQUAL); }
 	YY_BREAK
 case 65:
 YY_RULE_SETUP
-#line 132 "lex.l"
+#line 133 "lex.l"
 { return(';'); }
 	YY_BREAK
 case 66:
 YY_RULE_SETUP
-#line 133 "lex.l"
+#line 134 "lex.l"
 { return('{'); }
 	YY_BREAK
 case 67:
 YY_RULE_SETUP
-#line 134 "lex.l"
+#line 135 "lex.l"
 { return('}'); }
 	YY_BREAK
 case 68:
 YY_RULE_SETUP
-#line 135 "lex.l"
+#line 136 "lex.l"
 { return(','); }
 	YY_BREAK
 case 69:
 YY_RULE_SETUP
-#line 136 "lex.l"
+#line 137 "lex.l"
 { return(':'); }
 	YY_BREAK
 case 70:
 YY_RULE_SETUP
-#line 137 "lex.l"
+#line 138 "lex.l"
 { return('='); }
 	YY_BREAK
 case 71:
 YY_RULE_SETUP
-#line 138 "lex.l"
+#line 139 "lex.l"
 { return('('); }
 	YY_BREAK
 case 72:
 YY_RULE_SETUP
-#line 139 "lex.l"
+#line 140 "lex.l"
 { return(')'); }
 	YY_BREAK
 case 73:
 YY_RULE_SETUP
-#line 140 "lex.l"
+#line 141 "lex.l"
 { return('['); }
 	YY_BREAK
 case 74:
 YY_RULE_SETUP
-#line 141 "lex.l"
+#line 142 "lex.l"
 { return(']'); }
 	YY_BREAK
 case 75:
 YY_RULE_SETUP
-#line 142 "lex.l"
+#line 143 "lex.l"
 { return('.'); }
 	YY_BREAK
 case 76:
 YY_RULE_SETUP
-#line 143 "lex.l"
+#line 144 "lex.l"
 { return('&'); }
 	YY_BREAK
 case 77:
 YY_RULE_SETUP
-#line 144 "lex.l"
+#line 145 "lex.l"
 { return('!'); }
 	YY_BREAK
 case 78:
 YY_RULE_SETUP
-#line 145 "lex.l"
+#line 146 "lex.l"
 { return('~'); }
 	YY_BREAK
 case 79:
 YY_RULE_SETUP
-#line 146 "lex.l"
+#line 147 "lex.l"
 { return('-'); }
 	YY_BREAK
 case 80:
 YY_RULE_SETUP
-#line 147 "lex.l"
+#line 148 "lex.l"
 { return('+'); }
 	YY_BREAK
 case 81:
 YY_RULE_SETUP
-#line 148 "lex.l"
+#line 149 "lex.l"
 { return('*'); }
 	YY_BREAK
 case 82:
 YY_RULE_SETUP
-#line 149 "lex.l"
+#line 150 "lex.l"
 { return('/'); }
 	YY_BREAK
 case 83:
 YY_RULE_SETUP
-#line 150 "lex.l"
+#line 151 "lex.l"
 { return('%'); }
 	YY_BREAK
 case 84:
 YY_RULE_SETUP
-#line 151 "lex.l"
+#line 152 "lex.l"
 { return('<'); }
 	YY_BREAK
 case 85:
 YY_RULE_SETUP
-#line 152 "lex.l"
+#line 153 "lex.l"
 { return('>'); }
 	YY_BREAK
 case 86:
 YY_RULE_SETUP
-#line 153 "lex.l"
+#line 154 "lex.l"
 { return('^'); }
 	YY_BREAK
 case 87:
 YY_RULE_SETUP
-#line 154 "lex.l"
+#line 155 "lex.l"
 { return('|'); }
 	YY_BREAK
 case 88:
 YY_RULE_SETUP
-#line 155 "lex.l"
+#line 156 "lex.l"
 { return('?'); }
 	YY_BREAK
 case 89:
+/* rule 89 can match eol */
 YY_RULE_SETUP
-#line 157 "lex.l"
+#line 158 "lex.l"
 { ccchere++; }
 	YY_BREAK
 case 90:
 YY_RULE_SETUP
-#line 158 "lex.l"
+#line 159 "lex.l"
 {  }
 	YY_BREAK
 case 91:
+/* rule 91 can match eol */
 YY_RULE_SETUP
-#line 159 "lex.l"
+#line 160 "lex.l"
 {
-    			  if (strlen(yytext) > 1024) {
+    			  if (strlen(ccctext) > 1024) {
                               Diagnostic(WARNING,ccchere)
                                  << "truncating filename (> 1024)";
-			      yytext[1024] = 0;
+			      ccctext[1024] = 0;
 			  }
                           {
                               int newlineno ;
                               char newfilename[1024] ;
-    			      sscanf(yytext, "# %d \"%[^\"]",
+    			      sscanf(ccctext, "# %d \"%[^\"]",
                                    &newlineno, newfilename);
                               ccchere = newfilename ;
 			      ccchere = newlineno ;
@@ -1354,31 +1416,32 @@
 		        }
 	YY_BREAK
 case 92:
+/* rule 92 can match eol */
 YY_RULE_SETUP
-#line 174 "lex.l"
-{ ccchere = atoi(yytext+2); }
+#line 175 "lex.l"
+{ ccchere = atoi(ccctext+2); }
 	YY_BREAK
 case 93:
 YY_RULE_SETUP
-#line 175 "lex.l"
+#line 176 "lex.l"
 {{
-                            const char *pc = yytext ;
+                            const char *pc = ccctext ;
                             while ( *pc != 'x' ) pc++ ;
                             JamInDirective(pc+1,ccchere) ;
                         }}
 	YY_BREAK
 case 94:
 YY_RULE_SETUP
-#line 180 "lex.l"
-{{  const char *pc = yytext ;
+#line 181 "lex.l"
+{{  const char *pc = ccctext ;
                             while ( *pc != '#' ) pc++ ;
                             Diagnostic(WARNING,ccchere) << "ignoring " << pc ;
                         }}
 	YY_BREAK
 case 95:
 YY_RULE_SETUP
-#line 184 "lex.l"
-{{  const char *pc = yytext ;
+#line 185 "lex.l"
+{{  const char *pc = ccctext ;
                             while ( *pc != 'o' ) pc++ ;
                             pc += 2 ;
                             while ( *pc == ' ' || *pc == '\t' ) pc++ ;
@@ -1387,43 +1450,43 @@
 	YY_BREAK
 case 96:
 YY_RULE_SETUP
-#line 190 "lex.l"
+#line 191 "lex.l"
 { Diagnostic(ERROR,ccchere) << "bad character '"
-                                                    << (char)yytext[0] << '\'';
+                                                    << (char)ccctext[0] << '\'';
                         }
 	YY_BREAK
 case 97:
 YY_RULE_SETUP
-#line 194 "lex.l"
+#line 195 "lex.l"
 ECHO;
 	YY_BREAK
-#line 1400 "temp"
+#line 1463 "temp"
 case YY_STATE_EOF(INITIAL):
 	yyterminate();
 
 	case YY_END_OF_BUFFER:
 		{
 		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
 
 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
+		*yy_cp = (yy_hold_char);
 		YY_RESTORE_YY_MORE_OFFSET
 
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
 			{
 			/* We're scanning a new file or input source.  It's
 			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
+			 * just pointed cccin at a new source and called
+			 * ccclex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
 			 * globals.  Here is the right place to do so, because
 			 * this is the first action (other than possibly a
 			 * back-up) that will match for the new input source.
 			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = cccin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
 			}
 
 		/* Note that here we test for yy_c_buf_p "<=" to the position
@@ -1433,13 +1496,13 @@
 		 * end-of-buffer state).  Contrast this with the test
 		 * in input().
 		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
 			{ /* This was really a NUL. */
 			yy_state_type yy_next_state;
 
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
 
-			yy_current_state = yy_get_previous_state();
+			yy_current_state = yy_get_previous_state(  );
 
 			/* Okay, we're now positioned to make the NUL
 			 * transition.  We couldn't have
@@ -1452,41 +1515,41 @@
 
 			yy_next_state = yy_try_NUL_trans( yy_current_state );
 
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 
 			if ( yy_next_state )
 				{
 				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
+				yy_cp = ++(yy_c_buf_p);
 				yy_current_state = yy_next_state;
 				goto yy_match;
 				}
 
 			else
 				{
-				yy_cp = yy_c_buf_p;
+				yy_cp = (yy_c_buf_p);
 				goto yy_find_action;
 				}
 			}
 
-		else switch ( yy_get_next_buffer() )
+		else switch ( yy_get_next_buffer(  ) )
 			{
 			case EOB_ACT_END_OF_FILE:
 				{
-				yy_did_buffer_switch_on_eof = 0;
+				(yy_did_buffer_switch_on_eof) = 0;
 
-				if ( yywrap() )
+				if ( cccwrap( ) )
 					{
 					/* Note: because we've taken care in
 					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
+					 * ccctext, we can now set up
 					 * yy_c_buf_p so that if some total
 					 * hoser (like flex itself) wants to
 					 * call the scanner after we return the
 					 * YY_NULL, it'll still work - another
 					 * YY_NULL will get returned.
 					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
 
 					yy_act = YY_STATE_EOF(YY_START);
 					goto do_action;
@@ -1494,30 +1557,30 @@
 
 				else
 					{
-					if ( ! yy_did_buffer_switch_on_eof )
+					if ( ! (yy_did_buffer_switch_on_eof) )
 						YY_NEW_FILE;
 					}
 				break;
 				}
 
 			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
 
-				yy_current_state = yy_get_previous_state();
+				yy_current_state = yy_get_previous_state(  );
 
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 				goto yy_match;
 
 			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
 
-				yy_current_state = yy_get_previous_state();
+				yy_current_state = yy_get_previous_state(  );
 
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 				goto yy_find_action;
 			}
 		break;
@@ -1528,8 +1591,7 @@
 			"fatal flex scanner internal error--no action found" );
 	} /* end of action switch */
 		} /* end of scanning one token */
-	} /* end of yylex */
-
+} /* end of ccclex */
 
 /* yy_get_next_buffer - try to read in a new buffer
  *
@@ -1538,21 +1600,20 @@
  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
  *	EOB_ACT_END_OF_FILE - end of file
  */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
 	register int number_to_move, i;
 	int ret_val;
 
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
 		YY_FATAL_ERROR(
 		"fatal flex scanner internal error--end of buffer missed" );
 
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
 		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
 			{
 			/* We matched a single character, the EOB, so
 			 * treat this as a final EOF.
@@ -1572,34 +1633,30 @@
 	/* Try to read more data. */
 
 	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
 
 	for ( i = 0; i < number_to_move; ++i )
 		*(dest++) = *(source++);
 
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
 		/* don't do the read, it's not guaranteed to return an EOF,
 		 * just force an EOF
 		 */
-		yy_n_chars = 0;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
 
 	else
 		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
+			size_t num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
 
 		while ( num_to_read <= 0 )
 			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
 
 			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
 
 			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
 
 			if ( b->yy_is_our_buffer )
 				{
@@ -1612,8 +1669,7 @@
 
 				b->yy_ch_buf = (char *)
 					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
+					cccrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
 				}
 			else
 				/* Can't grow it, we don't own it. */
@@ -1623,33 +1679,35 @@
 				YY_FATAL_ERROR(
 				"fatal error - scanner input buffer overflow" );
 
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
 
-			num_to_read = yy_current_buffer->yy_buf_size -
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
 						number_to_move - 1;
-#endif
+
 			}
 
 		if ( num_to_read > YY_READ_BUF_SIZE )
 			num_to_read = YY_READ_BUF_SIZE;
 
 		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
 		}
 
-	if ( yy_n_chars == 0 )
+	if ( (yy_n_chars) == 0 )
 		{
 		if ( number_to_move == YY_MORE_ADJ )
 			{
 			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
+			cccrestart(cccin  );
 			}
 
 		else
 			{
 			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
 				YY_BUFFER_EOF_PENDING;
 			}
 		}
@@ -1657,33 +1715,32 @@
 	else
 		ret_val = EOB_ACT_CONTINUE_SCAN;
 
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
 
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
 
 	return ret_val;
-	}
-
+}
 
 /* yy_get_previous_state - get the state just before the EOB char was reached */
 
-static yy_state_type yy_get_previous_state()
-	{
+    static yy_state_type yy_get_previous_state (void)
+{
 	register yy_state_type yy_current_state;
 	register char *yy_cp;
-
-	yy_current_state = yy_start;
+    
+	yy_current_state = (yy_start);
 	yy_current_state += YY_AT_BOL();
 
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
 		{
 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
 		if ( yy_accept[yy_current_state] )
 			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
 			}
 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 			{
@@ -1695,30 +1752,23 @@
 		}
 
 	return yy_current_state;
-	}
-
+}
 
 /* yy_try_NUL_trans - try to make a transition on the NUL character
  *
  * synopsis
  *	next_state = yy_try_NUL_trans( current_state );
  */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
 	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
+    	register char *yy_cp = (yy_c_buf_p);
 
 	register YY_CHAR yy_c = 1;
 	if ( yy_accept[yy_current_state] )
 		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
 		}
 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 		{
@@ -1730,89 +1780,59 @@
 	yy_is_jam = (yy_current_state == 286);
 
 	return yy_is_jam ? 0 : yy_current_state;
-	}
-
-
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
-
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
-
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
-		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
-
-		while ( source > yy_current_buffer->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		yy_n_chars = yy_current_buffer->yy_buf_size;
-
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
+}
 
+#ifndef YY_NO_INPUT
 #ifdef __cplusplus
-static int yyinput()
+    static int yyinput (void)
 #else
-static int input()
+    static int input  (void)
 #endif
-	{
-	int c;
 
-	*yy_c_buf_p = yy_hold_char;
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
 
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
 		{
 		/* yy_c_buf_p now points to the character we want to return.
 		 * If this occurs *before* the EOB characters, then it's a
 		 * valid NUL; if not, then we've hit the end of the buffer.
 		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
 			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
+			*(yy_c_buf_p) = '\0';
 
 		else
 			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
 
-			switch ( yy_get_next_buffer() )
+			switch ( yy_get_next_buffer(  ) )
 				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					cccrestart(cccin );
+
+					/*FALLTHROUGH*/
+
 				case EOB_ACT_END_OF_FILE:
 					{
-					if ( yywrap() )
-						{
-						yy_c_buf_p = yytext_ptr + offset;
+					if ( cccwrap( ) )
 						return EOF;
-						}
 
-					if ( ! yy_did_buffer_switch_on_eof )
+					if ( ! (yy_did_buffer_switch_on_eof) )
 						YY_NEW_FILE;
 #ifdef __cplusplus
 					return yyinput();
@@ -1822,181 +1842,173 @@
 					}
 
 				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
+					(yy_c_buf_p) = (yytext_ptr) + offset;
 					break;
-
-				case EOB_ACT_LAST_MATCH:
-#ifdef __cplusplus
-					YY_FATAL_ERROR(
-					"unexpected last match in yyinput()" );
-#else
-					YY_FATAL_ERROR(
-					"unexpected last match in input()" );
-#endif
 				}
 			}
 		}
 
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve ccctext */
+	(yy_hold_char) = *++(yy_c_buf_p);
 
-	yy_current_buffer->yy_at_bol = (c == '\n');
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
 
 	return c;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+}
+#endif	/* ifndef YY_NO_INPUT */
 
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void cccrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        cccensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            ccc_create_buffer(cccin,YY_BUF_SIZE );
 	}
 
+	ccc_init_buffer(YY_CURRENT_BUFFER,input_file );
+	ccc_load_buffer_state( );
+}
 
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void ccc_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		cccpop_buffer_state();
+	 *		cccpush_buffer_state(new_buffer);
+     */
+	cccensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
 		return;
 
-	if ( yy_current_buffer )
+	if ( YY_CURRENT_BUFFER )
 		{
 		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
 		}
 
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	ccc_load_buffer_state( );
 
 	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
+	 * EOF (cccwrap()) processing, but the only time this flag
+	 * is looked at is after cccwrap() is called, so it's safe
 	 * to go ahead and always set it.
 	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
+	(yy_did_buffer_switch_on_eof) = 1;
+}
 
+static void ccc_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	cccin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
 
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE ccc_create_buffer  (FILE * file, int  size )
+{
 	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+    
+	b = (YY_BUFFER_STATE) cccalloc(sizeof( struct yy_buffer_state )  );
 	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+		YY_FATAL_ERROR( "out of dynamic memory in ccc_create_buffer()" );
 
 	b->yy_buf_size = size;
 
 	/* yy_ch_buf has to be 2 characters longer than the size given because
 	 * we need to put in 2 end-of-buffer characters.
 	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	b->yy_ch_buf = (char *) cccalloc(b->yy_buf_size + 2  );
 	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+		YY_FATAL_ERROR( "out of dynamic memory in ccc_create_buffer()" );
 
 	b->yy_is_our_buffer = 1;
 
-	yy_init_buffer( b, file );
+	ccc_init_buffer(b,file );
 
 	return b;
-	}
-
+}
 
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
+/** Destroy the buffer.
+ * @param b a buffer created with ccc_create_buffer()
+ * 
+ */
+    void ccc_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
 	if ( ! b )
 		return;
 
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
 
 	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
-
+		cccfree((void *) b->yy_ch_buf  );
 
-#ifndef YY_ALWAYS_INTERACTIVE
-#ifndef YY_NEVER_INTERACTIVE
-extern int isatty YY_PROTO(( int ));
-#endif
-#endif
-
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
+	cccfree((void *) b  );
+}
 
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a cccrestart() or at EOF.
+ */
+    static void ccc_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
 
-	{
-	yy_flush_buffer( b );
+{
+	int oerrno = errno;
+    
+	ccc_flush_buffer(b );
 
 	b->yy_input_file = file;
 	b->yy_fill_buffer = 1;
 
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
+    /* If b is the current buffer, then ccc_init_buffer was _probably_
+     * called from cccrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
 
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
 
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void ccc_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
 
-	{
 	b->yy_n_chars = 0;
 
 	/* We always need two end-of-buffer characters.  The first causes
@@ -2011,31 +2023,123 @@
 	b->yy_at_bol = 1;
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
+	if ( b == YY_CURRENT_BUFFER )
+		ccc_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void cccpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	cccensure_buffer_stack();
+
+	/* This block is copied from ccc_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from ccc_switch_to_buffer. */
+	ccc_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void cccpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	ccc_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		ccc_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
 	}
+}
 
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void cccensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
 
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)cccalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)cccrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
 
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE ccc_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
 	if ( size < 2 ||
 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
 		/* They forgot to leave room for the EOB's. */
 		return 0;
 
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	b = (YY_BUFFER_STATE) cccalloc(sizeof( struct yy_buffer_state )  );
 	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+		YY_FATAL_ERROR( "out of dynamic memory in ccc_scan_buffer()" );
 
 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
 	b->yy_buf_pos = b->yy_ch_buf = base;
@@ -2047,58 +2151,53 @@
 	b->yy_fill_buffer = 0;
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
-	yy_switch_to_buffer( b );
+	ccc_switch_to_buffer(b  );
 
 	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *str )
-#else
-YY_BUFFER_STATE yy_scan_string( str )
-yyconst char *str;
-#endif
-	{
-	int len;
-	for ( len = 0; str[len]; ++len )
-		;
-
-	return yy_scan_bytes( str, len );
-	}
-#endif
+}
 
+/** Setup the input buffer state to scan a string. The next call to ccclex() will
+ * scan from a @e copy of @a str.
+ * @param str a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       ccc_scan_bytes() instead.
+ */
+YY_BUFFER_STATE ccc_scan_string (yyconst char * str )
+{
+    
+	return ccc_scan_bytes(str,strlen(str) );
+}
 
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
+/** Setup the input buffer state to scan the given bytes. The next call to ccclex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE ccc_scan_bytes  (yyconst char * bytes, int  len )
+{
 	YY_BUFFER_STATE b;
 	char *buf;
 	yy_size_t n;
 	int i;
-
+    
 	/* Get memory for full buffer, including space for trailing EOB's. */
 	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
+	buf = (char *) cccalloc(n  );
 	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+		YY_FATAL_ERROR( "out of dynamic memory in ccc_scan_bytes()" );
 
 	for ( i = 0; i < len; ++i )
 		buf[i] = bytes[i];
 
 	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
 
-	b = yy_scan_buffer( buf, n );
+	b = ccc_scan_buffer(buf,n );
 	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+		YY_FATAL_ERROR( "bad buffer in ccc_scan_bytes()" );
 
 	/* It's okay to grow etc. this buffer, and we should throw it
 	 * away when we're done.
@@ -2106,148 +2205,164 @@
 	b->yy_is_our_buffer = 1;
 
 	return b;
-	}
-#endif
-
+}
 
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
 #endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
 
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
 
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
+/* Redefine yyless() so it works in section 3 code. */
 
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up ccctext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		ccctext[cccleng] = (yy_hold_char); \
+		(yy_c_buf_p) = ccctext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		cccleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
 
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
+/* Accessor  methods (get/set functions) to struct members. */
 
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
+/** Get the current line number.
+ * 
+ */
+int cccget_lineno  (void)
+{
+        
+    return ccclineno;
+}
 
-	BEGIN(new_state);
-	}
-#endif
+/** Get the input stream.
+ * 
+ */
+FILE *cccget_in  (void)
+{
+        return cccin;
+}
 
+/** Get the output stream.
+ * 
+ */
+FILE *cccget_out  (void)
+{
+        return cccout;
+}
 
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
+/** Get the length of the current token.
+ * 
+ */
+int cccget_leng  (void)
+{
+        return cccleng;
+}
 
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
+/** Get the current token.
+ * 
+ */
 
+char *cccget_text  (void)
+{
+        return ccctext;
+}
 
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void cccset_lineno (int  line_number )
+{
+    
+    ccclineno = line_number;
+}
 
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see ccc_switch_to_buffer
+ */
+void cccset_in (FILE *  in_str )
+{
+        cccin = in_str ;
+}
 
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
+void cccset_out (FILE *  out_str )
+{
+        cccout = out_str ;
+}
 
+int cccget_debug  (void)
+{
+        return ccc_flex_debug;
+}
 
+void cccset_debug (int  bdebug )
+{
+        ccc_flex_debug = bdebug ;
+}
 
-/* Redefine yyless() so it works in section 3 code. */
+/* ccclex_destroy is for both reentrant and non-reentrant scanners. */
+int ccclex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		ccc_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		cccpop_buffer_state();
+	}
 
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
+	/* Destroy the stack itself. */
+	cccfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
 
+    return 0;
+}
 
-/* Internal utility routines. */
+/*
+ * Internal utility routines.
+ */
 
 #ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
 	register int i;
-	for ( i = 0; i < n; ++i )
+    	for ( i = 0; i < n; ++i )
 		s1[i] = s2[i];
-	}
+}
 #endif
 
 #ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
+static int yy_flex_strlen (yyconst char * s )
+{
 	register int n;
-	for ( n = 0; s[n]; ++n )
+    	for ( n = 0; s[n]; ++n )
 		;
 
 	return n;
-	}
+}
 #endif
 
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
+void *cccalloc (yy_size_t  size )
+{
 	return (void *) malloc( size );
-	}
+}
 
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
+void *cccrealloc  (void * ptr, yy_size_t  size )
+{
 	/* The cast to (char *) in the following accommodates both
 	 * implementations that use char* generic pointers, and those
 	 * that use void* generic pointers.  It works with the latter
@@ -2256,26 +2371,29 @@
 	 * as though doing an assignment.
 	 */
 	return (void *) realloc( (char *) ptr, size );
-	}
+}
 
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
+void cccfree (void * ptr )
+{
+	free( (char *) ptr );	/* see cccrealloc() for (char *) cast */
+}
 
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
+#define YYTABLES_NAME "yytables"
+
+#undef YY_NEW_FILE
+#undef YY_FLUSH_BUFFER
+#undef yy_set_bol
+#undef yy_new_buffer
+#undef yy_set_interactive
+#undef yytext_ptr
+#undef YY_DO_BEFORE_ACTION
+
+#ifdef YY_DECL_IS_OURS
+#undef YY_DECL_IS_OURS
+#undef YY_DECL
 #endif
-#line 194 "lex.l"
+#line 195 "lex.l"
+
 
 
 static int typedef_name(char *str) {
@@ -2318,7 +2436,7 @@
     else
         ost << CPP ;
     ost << " " << cppargs
-        << " -D__CMIX=__CMIX -D__STDC__ -I" ;
+        << " -D__CMIX=__CMIX -I" ;
     if ( getenv("CMIX_SHADOW_DIR") )
 	ost << getenv("CMIX_SHADOW_DIR") ;
     else
@@ -2347,7 +2465,7 @@
       while( (c=getc(f)) != EOF )
           cout << (unsigned char)c;
     } else  {
-        yy_switch_to_buffer(yy_create_buffer(f,YY_BUF_SIZE)) ;
+        ccc_switch_to_buffer(ccc_create_buffer(f,YY_BUF_SIZE)) ;
         ccchere = filename ;
         ccchere = 1 ;
         ok = 1 ;
@@ -2361,9 +2479,10 @@
 
 cccLexWrapper::~cccLexWrapper() {
   if ( ok )
-    yy_delete_buffer(YY_CURRENT_BUFFER);
+    ccc_delete_buffer(YY_CURRENT_BUFFER);
   if ( f )
     if ( pclose(f) != 0 )
       Diagnostic(ERROR,Position()) << "preprocessor failed" ;
   InUse-- ;
 }
+
